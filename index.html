<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pay Me - Card Game</title>
    <!-- React and React DOM libraries for building UI components -->

    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    
 

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
            overflow: hidden;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: #333;
        }

        .game-container {
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .header {
            background: white;
            border-radius: 12px;
            padding: clamp(10px, 1.2vh, 16px) clamp(15px, 2vw, 25px);
            margin: clamp(8px, 1vh, 12px);
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .header-top-row {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            justify-content: space-between;
            gap: 15px;
        }

        .header h1 {
            color: #1e3c72;
            margin: 0;
            font-size: clamp(18px, 1.8vw, 24px);
            flex-shrink: 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .header h1 span {
            display: inline;
        }
        
        @media (max-width: 800px) {
            .header h1 {
                flex-direction: column;
                gap: 2px;
                font-size: 14px;
                line-height: 1;
                text-align: center;
            }
            
            .header h1 span {
                display: block;
            }
        }
        
        @media (max-width: 730px) {
            .header {
                padding: 10px 15px;
            }
            
            /* 4-column grid: left | center | right | pause */
            .header-top-row {
                display: grid;
                grid-template-columns: 1fr auto 1fr auto;
                align-items: center;
                gap: 10px;
                width: 100%;
            }
            
            .header-top-row > h1 {
                grid-column: 1;
                grid-row: 1;
                justify-self: start;
            }
            
            .header-top-row > .game-info {
                grid-column: 1 / 5;
                grid-row: 1;
                display: contents;
            }
            
            /* Hide Round and Wild Cards */
            .game-info .info-item:nth-child(1),
            .game-info .info-item:nth-child(3) {
                display: none;
            }
            
            /* Cards in absolute center */
            .game-info .info-item:nth-child(2) {
                grid-column: 2;
                grid-row: 1;
                justify-self: center;
                text-align: center;
            }
            
            /* Dealer far right - span to pause column */
            .game-info .info-item:nth-child(4) {
                grid-column: 3 / 5;
                grid-row: 1;
                justify-self: end;
            }
            
            /* Second row: Message spans columns 1-4 */
            .header-message {
                grid-column: 1 / 4;
                grid-row: 2;
                margin: 5px 10px 0 0;
            }
            
            .header-message .message-pill {
                width: 100%;
                text-align: center;
                display: block;
            }
            
            /* Pause button in column 4 */
            .header-actions {
                grid-column: 4;
                grid-row: 2;
                justify-self: end;
                margin: 5px 0 0 0;
            }
        }

        .game-info {
            display: flex;
            gap: clamp(15px, 2vw, 25px);
            flex-wrap: wrap;
            align-items: center;
            font-size: clamp(12px, 1vw, 14px);
            flex-shrink: 1;
            min-width: 0;
        }
        
        .header-actions {
            display: flex;
            gap: 10px;
            flex-shrink: 0;
            align-items: center;
            margin-left: auto;
        }
        
        .pause-button {
            background: #f8f9fa;
            border: 2px solid #dee2e6;
            border-radius: 6px;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 18px;
            transition: all 0.2s;
        }
        
        .pause-button:hover {
            background: #e9ecef;
            transform: scale(1.05);
        }

        .info-item {
            display: flex;
            flex-direction: column;
        }

        .info-label {
            color: #666;
            font-size: 11px;
            margin-bottom: 2px;
        }

        .info-value {
            font-weight: 600;
            color: #1e3c72;
            font-size: 14px;
        }

        .setup-screen {
            background: white;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            max-width: 500px;
            margin: 100px auto;
            margin-left: auto;
            margin-right: auto;
            width: calc(100% - 40px);
        }
        
        .game-content-wrapper {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        
        /* Scoreboard Panel - repurposed from side-panel */
        .side-panel {
            width: 280px;
            background: white;
            border-right: 2px solid #dee2e6;
            overflow-y: auto;
            transition: margin-left 0.3s ease;
            flex-shrink: 0;
        }
        
        .side-panel.collapsed {
            margin-left: -280px;
        }
        
        .side-panel-toggle {
            position: fixed;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            background: white;
            border: 2px solid #dee2e6;
            border-left: none;
            border-radius: 0 8px 8px 0;
            padding: 12px 6px;
            cursor: pointer;
            z-index: 50;
            transition: left 0.3s ease;
            font-size: 18px;
        }
        
        .side-panel-toggle.expanded {
            left: 280px;
        }

        /* Table Layout for Players */
        /* Z-index hierarchy: 
         * - Side panel toggle: 50 (highest, always accessible)
         * - Hand area: 40 (player's cards, must be on top)
         * - Deck area: 20 (draw/discard piles)
         * - Winner hand fixed: 15 (winner's melds)
         * - Table player positions: 15 (player info cards)
         * - Table players container: 10 (overlay container)
         */
        .table-players-container {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none; /* Allow clicks to pass through to game area */
            z-index: 10;
        }

        .table-player-position {
            position: absolute;
            background: white;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            padding: 8px 12px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            min-width: 140px;
            max-width: 180px;
            pointer-events: auto; /* Enable clicks on player cards */
            z-index: 15; /* Higher than container to ensure proper stacking */
        }

        .table-player-position.active {
            border-color: #2a5298;
            background: #e3f2fd;
            box-shadow: 0 4px 8px rgba(42, 82, 152, 0.3);
        }

        .table-player-position.winner {
            border-color: #28a745;
            background: #d4edda;
        }

        /* Player positions around the table */
        /* Bottom center (human player) */
        .table-player-position.position-0 {
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
        }

        /* Top left */
        .table-player-position.position-1 {
            top: 10px;
            left: 10px;
        }

        /* Top center */
        .table-player-position.position-2 {
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
        }

        /* Top right */
        .table-player-position.position-3 {
            top: 10px;
            right: 10px;
        }

        /* Right center */
        .table-player-position.position-4 {
            top: 50%;
            right: 10px;
            transform: translateY(-50%);
        }

        /* Bottom right */
        .table-player-position.position-5 {
            bottom: 10px;
            right: 10px;
        }

        /* Bottom left */
        .table-player-position.position-6 {
            bottom: 10px;
            left: 10px;
        }

        /* Left center */
        .table-player-position.position-7 {
            top: 50%;
            left: 10px;
            transform: translateY(-50%);
        }

        .table-player-name {
            font-weight: 600;
            font-size: 13px;
            color: #1e3c72;
            display: flex;
            align-items: center;
            gap: 4px;
            margin-bottom: 4px;
        }

        .table-player-avatar {
            font-size: 18px;
        }

        .table-player-stats {
            font-size: 11px;
            color: #666;
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .table-player-quarters {
            position: absolute;
            top: 6px;
            right: 6px;
            background: linear-gradient(135deg, #ffd700 0%, #ffed4e 50%, #ffd700 100%);
            border: 2px solid #b8860b;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 11px;
            color: #1a1a1a;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }
        
        .main-game-area {
            flex: 1;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            position: relative;
        }
        
        .game-screen {
            background: transparent;
            border-radius: 0;
            margin: 0;
            box-shadow: none;
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: clamp(12px, 1.5vw, 20px);
            gap: clamp(12px, 2vh, 20px);
            min-height: 0;
            overflow: visible;
        }

        .setup-screen h2 {
            color: #1e3c72;
            margin-bottom: 20px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #333;
        }

        input, select {
            width: 100%;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 16px;
        }

        input:focus, select:focus {
            outline: none;
            border-color: #2a5298;
        }

        button {
            background: #2a5298;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s;
        }

        button:hover {
            background: #1e3c72;
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        button.secondary {
            background: #6c757d;
        }

        button.secondary:hover {
            background: #5a6268;
        }

        button.danger {
            background: #dc3545;
        }

        button.danger:hover {
            background: #c82333;
        }

        button.success {
            background: #28a745;
            color: white;
        }

        button.success:hover {
            background: #218838;
            color: white;
        }

        .players-grid {
            padding: 10px;
        }

        .player-card {
            background: #f8f9fa;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            padding: clamp(8px, 1vw, 15px);
            position: relative;
            margin-bottom: 10px;
        }

        .player-card.active {
            border-color: #2a5298;
            background: #e3f2fd;
        }

        .player-card.winner {
            border-color: #28a745;
            background: #d4edda;
        }

        /* Winner pulse animation removed to prevent layout jumping */

        .player-name {
            font-weight: 600;
            margin-bottom: 6px;
            color: #1e3c72;
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: clamp(13px, 1.1vw, 16px);
        }

        .player-avatar {
            font-size: clamp(16px, 1.5vw, 24px);
        }

        .player-stats {
            font-size: clamp(10px, 0.85vw, 13px);
            color: #666;
        }

        .player-stats div {
            margin-bottom: 3px;
        }

        .player-dialogue {
            margin-top: 6px;
            font-size: clamp(10px, 0.8vw, 12px);
            font-style: italic;
            color: #555;
            background: white;
            padding: 6px;
            border-radius: 4px;
            min-height: 30px;
        }

        .player-final-hand {
            margin-top: 8px;
            padding: 8px;
            background: white;
            border-radius: 6px;
            border: 1px solid #dee2e6;
        }

        .player-final-hand h5 {
            font-size: 11px;
            color: #666;
            margin-bottom: 6px;
        }

        .mini-cards {
            display: flex;
            flex-wrap: wrap;
            gap: 2px;
        }

        .mini-card {
            font-size: 14px;
            padding: 3px 4px;
            background: white;
            border: 1.5px solid #333;
            border-radius: 3px;
            width: 30px;
            height: 42px;
            min-width: 30px;
            min-height: 42px;
            max-width: 30px;
            max-height: 42px;
            text-align: center;
            display: inline-flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            box-sizing: border-box;
            line-height: 1.1;
        }
        
        /* Winner hand cards - 20% smaller than regular cards */
        .winner-hand-card {
            width: clamp(45px, 7.5vw, 85px);
            height: clamp(68px, 11.25vw, 128px);
            border: 2px solid #333;
            border-radius: 5px;
            display: inline-flex;
            flex-direction: column;
            justify-content: space-between;
            margin: clamp(2px, 0.4vw, 3px);
            cursor: default;
            transition: all 0.2s;
            background: linear-gradient(to bottom, #ffffff 0%, #f5f5f5 100%);
            position: relative;
            padding: clamp(2px, 0.4vw, 5px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            font-size: clamp(6px, 1vw, 10px);
        }
        
        .winner-hand-card.red {
            color: #dc3545;
            border-color: #dc3545;
        }

        .winner-hand-card.black {
            color: #1a1a1a;
            border-color: #1a1a1a;
        }

        .winner-hand-card.wild {
            background: linear-gradient(135deg, #ffd700 0%, #ffed4e 50%, #ffd700 100%);
            border-color: #b8860b;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
        }
        
        .winner-hand-card.face-card {
            background: white;
            border: none;
            box-shadow: none;
            padding: 0;
            width: clamp(45px, 7.5vw, 85px);
            height: clamp(68px, 11.25vw, 128px);
        }
        
        .winner-hand-card.face-card.red {
            border: none;
        }
        
        .winner-hand-card.face-card.black {
            border: none;
        }
        
        .winner-hand-card.face-card .card-decorative-border {
            display: none;
        }
        
        .winner-hand-card .card-corner {
            display: flex;
            flex-direction: column;
            align-items: center;
            line-height: 1;
        }

        .winner-hand-card .card-corner.top-left {
            position: absolute;
            top: clamp(2px, 0.4vw, 5px);  /* 80% of clamp(3px, 0.5vw, 6px) */
            left: clamp(2px, 0.4vw, 5px);
        }

        .winner-hand-card .card-corner.bottom-right {
            position: absolute;
            bottom: clamp(2px, 0.4vw, 5px);  /* 80% of clamp(3px, 0.5vw, 6px) */
            right: clamp(2px, 0.4vw, 5px);
            transform: rotate(180deg);
        }

        .winner-hand-card .card-rank-corner {
            font-size: clamp(11px, 2vw, 16px);  /* 80% of clamp(14px, 2.5vw, 20px) */
            font-weight: 700;
            font-family: Georgia, serif;
        }

        .winner-hand-card .card-suit-corner {
            font-size: clamp(9px, 1.6vw, 13px);  /* 80% of clamp(11px, 2vw, 16px) */
            margin-top: 1px;
        }

        .winner-hand-card .card-center {
            display: flex;
            align-items: center;
            justify-content: center;
            flex: 1;
            font-size: clamp(16px, 4vw, 32px);  /* 80% of clamp(20px, 5vw, 40px) */
            margin: clamp(6px, 1.6vw, 13px) 0;  /* 80% of clamp(8px, 2vw, 16px) */
        }

        .winner-hand-card .face-card-label {
            font-size: clamp(6px, 0.8vw, 8px);  /* 80% of clamp(7px, 1vw, 10px) */
            font-weight: 600;
            text-align: center;
            margin-top: 1px;
            font-family: Georgia, serif;
            letter-spacing: 0.4px;
        }
        
        .winner-hand-card .card-decorative-border {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: 5px;
            pointer-events: none;
        }

        .winner-hand-card.red .card-decorative-border {
            border: 1.5px solid rgba(220, 53, 69, 0.1);
            margin: 3px;
        }

        .winner-hand-card.black .card-decorative-border {
            border: 1.5px solid rgba(26, 26, 26, 0.1);
            margin: 3px;
        }

        .mini-card.red {
            color: #dc3545;
            border-color: #dc3545;
        }

        .mini-card.black {
            color: #1a1a1a;
            border-color: #1a1a1a;
        }

        .mini-card.wild {
            background: #ffd700;
            border-color: #b8860b;
        }

        .celebration-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            animation: fadeIn 0.3s;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .celebration-content {
            background: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            max-width: 500px;
            animation: bounceIn 0.5s;
        }

        @keyframes bounceIn {
            0% { transform: scale(0.3); opacity: 0; }
            50% { transform: scale(1.05); }
            70% { transform: scale(0.9); }
            100% { transform: scale(1); opacity: 1; }
        }

        .celebration-content h2 {
            font-size: 48px;
            color: #28a745;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }

        .celebration-content .winner-name {
            font-size: 32px;
            color: #1e3c72;
            margin-bottom: 10px;
        }

        .celebration-content .coins {
            font-size: 64px;
            margin: 20px 0;
            animation: coinSpin 1s ease-in-out infinite;
        }

        @keyframes coinSpin {
            0%, 100% { transform: rotateY(0deg); }
            50% { transform: rotateY(180deg); }
        }

        .score-details-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: white;
            display: flex;
            flex-direction: column;
            animation: bounceIn 0.3s;
            z-index: 1001;
        }
        .score-details-header {
            padding: 20px;
            border-bottom: 2px solid #dee2e6;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #f8f9fa;
            flex-shrink: 0;
        }
        .score-details-header h2 {
            color: #1e3c72;
            margin: 0;
            font-size: 24px;
        }
        .score-details-content {
            padding: 20px;
            overflow-y: auto;
            flex: 1;
            min-height: 0;
        }
        .score-detail-table {
            width: 100%;
            border-collapse: collapse;
        }
        .score-detail-table th {
            background: #1e3c72;
            color: white;
            padding: 12px;
            text-align: left;
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        .score-detail-table td {
            padding: 12px;
            border-bottom: 1px solid #dee2e6;
            vertical-align: top;
        }
        .score-detail-table tr:hover {
            background: #f8f9fa;
        }
        .score-detail-table tr.winner-round {
            background: #d4edda;
        }
        .score-detail-table tr.winner-round:hover {
            background: #c3e6cb;
        }

        .confetti {
            position: fixed;
            width: 10px;
            height: 10px;
            background: #f0f;
            position: absolute;
            animation: confettiFall 3s linear;
        }

        @keyframes confettiFall {
            to {
                transform: translateY(100vh) rotate(360deg);
                opacity: 0;
            }
        }

        .game-area {
            margin: 20px 0;
            display: flex;
            flex-direction: column;
        }

        .deck-area {
            display: flex;
            gap: clamp(12px, 2vw, 25px);
            justify-content: center;
            margin: 0 12px 0 0;
            flex-wrap: wrap;
            flex: 0 0 auto;
            flex-shrink: 0;
            background: white;
            border: 2px solid #dee2e6;
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            position: relative;
            z-index: 20;
        }

        .deck-pile, .discard-pile {
            text-align: center;
        }

        .pile-label {
            font-size: 11px;
            color: #666;
            margin-bottom: 6px;
            font-weight: 600;
        }

        .card-stack {
            width: clamp(70px, 9vw, 110px);
            height: clamp(105px, 13.5vw, 165px);
            border: 2px solid #333;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(9px, 1.2vw, 12px);
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            background: white;
            position: relative;
        }
        
        .discard-card {
            width: clamp(70px, 9vw, 110px);
            height: clamp(105px, 13.5vw, 165px);
            border: 2px solid #333;
            border-radius: 6px;
            display: inline-flex;
            flex-direction: column;
            justify-content: space-between;
            margin: 0;
            cursor: pointer;
            transition: all 0.2s;
            background: linear-gradient(to bottom, #ffffff 0%, #f5f5f5 100%);
            position: relative;
            padding: clamp(3px, 0.5vw, 6px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            font-size: clamp(8px, 1.2vw, 12px);
        }
        
        .discard-card .card-corner {
            display: flex;
            flex-direction: column;
            align-items: center;
            line-height: 1;
        }
        
        .discard-card .card-corner.top-left {
            position: absolute;
            top: clamp(3px, 0.5vw, 6px);
            left: clamp(3px, 0.5vw, 6px);
        }
        
        .discard-card .card-corner.bottom-right {
            position: absolute;
            bottom: clamp(3px, 0.5vw, 6px);
            right: clamp(3px, 0.5vw, 6px);
            transform: rotate(180deg);
        }
        
        .discard-card .card-rank-corner {
            font-size: clamp(14px, 2.5vw, 20px);
            font-weight: 700;
            font-family: Georgia, serif;
        }
        
        .discard-card .card-suit-corner {
            font-size: clamp(11px, 2vw, 16px);
            margin-top: 1px;
        }
        
        .discard-card .card-center {
            display: flex;
            align-items: center;
            justify-content: center;
            flex: 1;
            font-size: clamp(20px, 5vw, 40px);
            margin: clamp(8px, 2vw, 16px) 0;
        }
        
        .discard-card .face-card-label {
            font-size: clamp(7px, 1vw, 10px);
            font-weight: 600;
            text-align: center;
            margin-top: 1px;
            font-family: Georgia, serif;
            letter-spacing: 0.4px;
        }
        
        .discard-card.red {
            color: #dc3545;
            border-color: #dc3545;
        }
        
        .discard-card.black {
            color: #1a1a1a;
            border-color: #1a1a1a;
        }
        
        .discard-card.wild {
            background: linear-gradient(135deg, #ffd700 0%, #ffed4e 50%, #ffd700 100%);
            border-color: #b8860b;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.4);
        }
        
        .discard-card .card-decorative-border {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: 5px;
            pointer-events: none;
        }
        
        .discard-card.red .card-decorative-border {
            border: 1px solid rgba(220, 53, 69, 0.1);
            margin: 2px;
        }
        
        .discard-card.black .card-decorative-border {
            border: 1px solid rgba(26, 26, 26, 0.1);
            margin: 2px;
        }

        .card-stack:hover:not(.disabled) {
            transform: translateY(-3px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .card-stack.disabled {
            cursor: not-allowed;
            opacity: 0.5;
        }

        .card {
            width: clamp(70px, 9vw, 110px);
            height: clamp(105px, 13.5vw, 165px);
            border: 2px solid #333;
            border-radius: 6px;
            display: inline-flex;
            flex-direction: column;
            justify-content: space-between;
            margin: clamp(2px, 0.4vw, 3px);
            cursor: pointer;
            transition: all 0.2s;
            background: linear-gradient(to bottom, #ffffff 0%, #f5f5f5 100%);
            position: relative;
            padding: clamp(3px, 0.5vw, 6px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            font-size: clamp(8px, 1.2vw, 12px);
        }
        
        .card[draggable="true"] {
            cursor: grab;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            touch-action: none; /* Prevent default touch behaviors */
        }
        
        .card[draggable="true"]:active {
            cursor: grabbing;
        }

        .card.red {
            color: #dc3545;
            border-color: #dc3545;
        }

        .card.black {
            color: #1a1a1a;
            border-color: #1a1a1a;
        }

        .card.wild {
            background: linear-gradient(135deg, #ffd700 0%, #ffed4e 50%, #ffd700 100%);
            border-color: #b8860b;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
            animation: shimmer 2s infinite;
        }
        
        .card.face-card {
            background: white;
            border: none;
            box-shadow: none;
            padding: 0;
            width: clamp(70px, 9vw, 110px);
            height: clamp(105px, 13.5vw, 165px);
        }
        
        .card.face-card.red {
            border: none;
        }
        
        .card.face-card.black {
            border: none;
        }
        
        .card.face-card .card-decorative-border {
            display: none;
        }

        @keyframes shimmer {
            0%, 100% { box-shadow: 0 0 20px rgba(255, 215, 0, 0.5); }
            50% { box-shadow: 0 0 30px rgba(255, 215, 0, 0.8); }
        }

        .card.selected {
            transform: translateY(-10px);
            box-shadow: 0 8px 16px rgba(42, 82, 152, 0.4);
            border-color: #2a5298;
            border-width: 3px;
        }

        .card:hover:not(.disabled) {
            transform: translateY(-4px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .card.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        /* Saved melds cards should be draggable */
        .melds-area .card {
            opacity: 1 !important;
            cursor: grab !important;
        }
        
        .melds-area .card:active {
            cursor: grabbing !important;
        }

        .card.in-meld {
            opacity: 0.6;
        }

        .card.dragging {
            opacity: 0.3;
        }

        .card-insertion-indicator {
            position: relative;
            width: 4px;
            margin: 0 8px;
            background: #28a745;
            border-radius: 2px;
            box-shadow: 0 0 15px rgba(40, 167, 69, 0.8);
            animation: pulse 0.6s ease-in-out infinite;
        }

        .card-insertion-indicator::before {
            content: 'â¬‡';
            position: absolute;
            top: -40px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 32px;
            font-weight: bold;
            color: #28a745;
            text-shadow: 0 0 10px rgba(40, 167, 69, 0.8);
            animation: bounce 0.6s ease-in-out infinite;
        }

        @keyframes bounce {
            0%, 100% { top: -40px; opacity: 1; }
            50% { top: -47px; opacity: 0.7; }
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 1; }
        }

        .dealing-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            animation: fadeIn 0.3s ease-in;
            padding: 15px;
            box-sizing: border-box;
            overflow-y: auto;
        }

        .dealing-content {
            text-align: center;
            color: white;
        }

        .dealer-announcement {
            font-size: clamp(24px, 8vw, 48px);
            font-weight: bold;
            margin-bottom: clamp(10px, 3vw, 20px);
            color: #ffd700;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }

        .dealer-avatar {
            font-size: clamp(40px, 15vw, 80px);
            margin: clamp(10px, 3vw, 20px) 0;
            animation: dealerPulse 1s ease-in-out infinite;
        }

        @keyframes dealerPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .dealing-info {
            font-size: clamp(14px, 4vw, 24px);
            margin: clamp(5px, 1.5vw, 10px) 0;
            color: #e0e0e0;
        }

        .card-corner {
            display: flex;
            flex-direction: column;
            align-items: center;
            line-height: 1;
        }

        .card-corner.top-left {
            position: absolute;
            top: clamp(3px, 0.5vw, 6px);
            left: clamp(3px, 0.5vw, 6px);
        }

        .card-corner.bottom-right {
            position: absolute;
            bottom: clamp(3px, 0.5vw, 6px);
            right: clamp(3px, 0.5vw, 6px);
            transform: rotate(180deg);
        }

        .card-rank-corner {
            font-size: clamp(18px, 3vw, 24px);
            font-weight: 700;
            font-family: Georgia, serif;
        }

        .card-suit-corner {
            font-size: clamp(13px, 2.4vw, 20px);
            margin-top: 1px;
        }

        .card-center {
            display: flex;
            align-items: center;
            justify-content: center;
            flex: 1;
            font-size: clamp(28px, 6vw, 52px);
            margin: clamp(8px, 2vw, 16px) 0;
        }

        .card-decorative-border {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: 7px;
            pointer-events: none;
        }

        .card.red .card-decorative-border {
            border: 2px solid rgba(220, 53, 69, 0.1);
            margin: 4px;
        }

        .card.black .card-decorative-border {
            border: 2px solid rgba(26, 26, 26, 0.1);
            margin: 4px;
        }

        .face-card-label {
            font-size: clamp(9px, 1.2vw, 12px);
            font-weight: 600;
            text-align: center;
            margin-top: 1px;
            font-family: Georgia, serif;
            letter-spacing: 0.5px;
        }

        .hand-area {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin: 0;
            position: relative;
            z-index: 10;
            flex: 0 0 auto;
        }

        .hand-label {
            font-weight: 600;
            margin-bottom: 12px;
            color: #1e3c72;
            text-align: center;
        }

        .cards-container {
            display: flex;
            flex-wrap: nowrap;
            gap: clamp(4px, 1vw, 8px);
            justify-content: center;
            overflow-x: auto;
        }

        .actions {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        /* Middle content area that expands to fill space between deck and hand */
        .middle-content-spacer {
            flex: 1 1 auto;
            min-height: 200px;
            max-height: calc(100vh - 400px);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            overflow-x: hidden;
        }

        .message-box {
            background: #e3f2fd;
            border-left: 4px solid #2a5298;
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
        }

        .message-box.success {
            background: #d4edda;
            border-color: #28a745;
        }

        .message-box.warning {
            background: #fff3cd;
            border-color: #ffc107;
        }

        .message-box.error {
            background: #f8d7da;
            border-color: #dc3545;
        }

        .melds-area {
            margin: 4px 0;
            flex: 1 1 auto;
            min-height: 200px;
            max-height: calc(100vh - 400px);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }
        
        /* Stable container for winner's hand to prevent jumping */
        .melds-area.winner-melds {
            min-height: 180px;
            background: rgba(212, 237, 218, 0.3);
            border: 2px solid #28a745;
            border-radius: 12px;
            padding: 12px;
        }
        
        /* Fixed winner's hand at top of main game area */
        .winner-hand-fixed {
            flex: 0 0 auto;
            background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%);
            border: 2px solid #28a745;
            border-radius: 12px;
            padding: 8px 12px;
            margin: 0 12px 8px 0;
            box-shadow: 0 4px 12px rgba(40, 167, 69, 0.2);
            max-height: 25vh;
            min-height: 100px;
            overflow-y: auto;
            position: relative;
            z-index: 15;
        }
        
        .hand-area {
            order: 3;
        }

        .meld-group {
            margin-bottom: 15px;
            background: #f8f9fa;
            padding: clamp(12px, 1.5vh, 18px);
            border-radius: 8px;
            border: 2px solid #dee2e6;
        }
        
        .meld-building-area .meld-group {
            margin-bottom: 8px;
            padding: clamp(10px, 1.2vh, 14px);
            min-height: 140px;
        }

        .meld-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .meld-building-area .meld-header {
            margin-bottom: 6px;
        }

        .meld-label {
            font-size: 14px;
            color: #666;
            font-weight: 600;
        }
        
        .meld-building-area .meld-label {
            font-size: 12px;
        }

        .meld-building-area {
            background: linear-gradient(135deg, #fff3cd 0%, #ffeaa7 100%);
            border: 2px solid #ffc107;
            padding: clamp(10px, 1.5vh, 16px) clamp(12px, 2vw, 20px);
            border-radius: 12px;
            margin: clamp(8px, 1vh, 12px) clamp(10px, 1.5vw, 16px);
            box-shadow: 0 4px 12px rgba(255, 193, 7, 0.2);
            box-sizing: border-box;
            max-width: calc(100% - 2 * clamp(10px, 1.5vw, 16px));
            align-self: stretch;
            flex: 1 1 auto;
            min-height: 250px;
            max-height: calc(100vh - 400px);
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        /* Make cards in meld-building area smaller (same as winner-hand-card) */
        .meld-building-area .card {
            width: clamp(45px, 7.5vw, 85px) !important;
            height: clamp(68px, 11.25vw, 128px) !important;
            padding: clamp(2px, 0.4vw, 5px) !important;
            font-size: clamp(6px, 1vw, 10px) !important;
        }
        
        .meld-building-area .card .card-rank-corner {
            font-size: clamp(11px, 2vw, 16px) !important;
        }
        
        .meld-building-area .card .card-suit-corner {
            font-size: clamp(9px, 1.6vw, 13px) !important;
        }
        
        .meld-building-area .card .card-center {
            font-size: clamp(16px, 4vw, 32px) !important;
            margin: clamp(6px, 1.6vw, 13px) 0 !important;
        }
        
        .meld-building-area .card .face-card-label {
            font-size: clamp(6px, 0.8vw, 8px) !important;
        }
        
        /* Joker emoji sizing for smaller cards in meld-building area - match winner-hand-card */
        .meld-building-area .card > div[style*="position: absolute"][style*="fontSize"] {
            font-size: clamp(60px, 9vw, 110px) !important;
        }
        
        /* Represents indicator for jokers in meld-building area */
        .meld-building-area .card > div > div[style*="bottom"][style*="transform: translateX(-50%)"] {
            bottom: clamp(6px, 1vw, 12px) !important;
            font-size: clamp(9px, 1.2vw, 12px) !important;
        }
        
        /* Override inline styles for joker display in meld-building area - match any joker container */
        .meld-building-area .card > div[style*="position: absolute"][style*="top"][style*="left"][style*="right"][style*="bottom"] {
            font-size: clamp(60px, 9vw, 110px) !important;
        }
        
        /* Override represents indicator for jokers in meld-building area */
        .meld-building-area .card > div[style*="position: absolute"][style*="bottom"][style*="transform"] {
            bottom: clamp(8px, 1.2vw, 12px) !important;
            font-size: clamp(9px, 1.2vw, 12px) !important;
            padding: 2px 4px !important;
        }
        
        /* Additional specific targeting for current-meld-section jokers */
        .current-meld-section .card > div[style*="position: absolute"][style*="fontSize"] {
            font-size: clamp(60px, 9vw, 110px) !important;
        }
        
        .current-meld-section .card > div[style*="position: absolute"][style*="top"][style*="left"][style*="right"][style*="bottom"] {
            font-size: clamp(60px, 9vw, 110px) !important;
        }
        
        /* Target joker container in current meld - most specific rule */
        .current-meld-section .cards-container .card > div[style*="position: absolute"] {
            font-size: clamp(60px, 9vw, 110px) !important;
        }
        
        .meld-building-content {
            display: flex;
            gap: clamp(10px, 1.5vw, 16px);
            flex: 1 1 auto;
            min-height: 150px;
            overflow-x: auto;
            overflow-y: visible;
            flex-wrap: nowrap;
            align-items: flex-start;
            padding: 4px;
        }
        
        .your-melds-section {
            display: flex;
            gap: 12px;
            flex-shrink: 0;
            align-items: flex-start;
        }
        
        .current-meld-section {
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            min-width: clamp(280px, 40vw, 500px);
            max-width: none;
        }
        
        @media (max-width: 900px) {
            .meld-building-content {
                flex-direction: row;
                overflow-x: auto;
            }
            
            .your-melds-section,
            .current-meld-section {
                max-width: none;
                min-width: clamp(250px, 35vw, 400px);
            }
            
            .meld-building-area {
                min-height: 180px;
                padding: clamp(8px, 1.2vh, 12px) clamp(10px, 1.5vw, 14px);
            }
        }
        
        .saved-meld-item {
            flex-shrink: 0;
            min-width: fit-content;
            display: flex;
            flex-direction: column;
        }

        .meld-building-area h3 {
            color: #856404;
            margin: 0 0 6px 0;
            font-size: 15px;
        }
        
        .meld-building-area p {
            margin: 0 0 6px 0;
            font-size: 12px;
        }

        .scoreboard {
            background: white;
            border-radius: 8px;
            padding: 20px;
            margin-top: 20px;
        }

        .scoreboard h3 {
            color: #1e3c72;
            margin-bottom: 15px;
        }

        .score-table {
            width: 100%;
            border-collapse: collapse;
        }

        .score-table th, .score-table td {
            padding: 8px;
            text-align: left;
            border-bottom: 1px solid #dee2e6;
        }

        .score-table th {
            background: #f8f9fa;
            font-weight: 600;
            color: #1e3c72;
        }

        .flying-card {
            position: fixed;
            pointer-events: none;
            z-index: 9999;
            transition: all 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }
        
        @keyframes cardFlip {
            0%, 100% { transform: rotateY(0deg); }
            50% { transform: rotateY(180deg); }
        }

        @media  (max-width: 1000px) {
            .game-container {
                padding: 10px;
            }

            .header {
                padding: 15px;
                flex-wrap: wrap;
            }

            .game-info {
                gap: 15px;
            }
            
            /* Move message and pause to second row */
            .header-message {
                order: 10;
                flex: 1 1 100%;
                margin: 5px 10px 0 0;
                min-width: 0;
            }
            
            .header-message .message-pill {
                width: 100%;
            }
            
            .header-actions {
                order: 11;
                flex: 0 0 auto;
                margin: 5px 0 0 0;
            }

            .card {
                width: 90px;
                height: 135px;
                padding: 6px;
            }

            .card-rank-corner {
                font-size: 20px;
            }

            .card-suit-corner {
                font-size: 16px;
            }

            .card-center {
                font-size: 40px;
            }
            
            .side-panel {
                position: fixed;
                left: 0;
                top: 0;
                bottom: 0;
                z-index: 100;
                width: 280px;
            }
            
            .side-panel.collapsed {
                margin-left: -280px;
            }
            
            .side-panel-toggle {
                position: fixed;
                left: 0;
                z-index: 101;
            }
            
            .side-panel-toggle.expanded {
                left: 280px;
            }
            
            .main-game-area {
                padding-left: 0;
            }
            
            .deck-area {
                flex-direction: row;
                justify-content: center;
                gap: 20px;
            }
        }
        
        /* Additional responsive breakpoints for very small screens */
        @media  (max-width: 600px) {
            .header {
                flex-wrap: wrap;
                gap: 6px;
                padding: 8px;
            }
            
            .header h1 {
                font-size: 14px;
                display: flex;
                flex-direction: column;
                align-items: center;
                line-height: 1;
                gap: 2px;
            }
            
            .game-info {
                flex-wrap: wrap;
                gap: 8px;
            }
            
            /* Hide Round and Wild Cards on mobile */
            .game-info .info-item:nth-child(1),
            .game-info .info-item:nth-child(3) {
                display: none;
            }
            
            .info-item {
                font-size: 11px;
                text-align: center;
            }
            
            .header-actions {
                order: 3;
            }
            
            .header-message {
                /* Removed width and order overrides - let flex layout handle it */
                margin: 5px 0 0 0;
            }
            
            .pause-button {
                padding: 6px 10px;
                font-size: 16px;
            }
            
            .card {
                width: 70px;
                height: 105px;
                padding: 4px;
            }
            
            .card-rank-corner {
                font-size: 14px;
            }
            
            .card-suit-corner {
                font-size: 12px;
            }
            
            .card-center {
                font-size: 24px;
            }
            
            .card-stack {
                width: 70px;
                height: 105px;
                font-size: 28px;
            }
            
            .hand-area, .melds-area {
                padding: 10px;
            }
            
            .cards-container {
                gap: 4px;
                justify-content: center;
            }
            
            .deck-area {
                gap: 15px;
            }
            
            .pile-label {
                font-size: 11px;
            }
            
            .message-box {
                font-size: 13px;
                padding: 8px;
            }
            
            .actions button {
                font-size: 14px;
                padding: 10px 16px;
            }
            
            .meld-building-area {
                min-height: 160px;
                margin: 6px 8px;
                padding: 8px 10px;
            }
            
            .meld-building-area h3 {
                font-size: 14px;
            }
            
            .meld-building-content {
                gap: 8px;
                min-height: 130px;
            }
            
            .current-meld-section {
                min-width: clamp(220px, 80vw, 300px);
            }
            
            .meld-group {
                padding: 8px;
                margin-bottom: 6px;
            }
            
            .meld-building-area .meld-group {
                min-height: 120px;
            }
            
            .winner-hand-fixed {
                padding: 6px 8px;
                margin: 0 8px 8px 0;
            }
            
            .winner-hand-fixed h3 {
                font-size: 12px;
                margin-bottom: 6px;
            }
        }
        
        @media  (max-width: 400px) {
            .card {
                width: 60px;
                height: 90px;
                padding: 3px;
            }
            
            .card-rank-corner {
                font-size: 13px;
            }
            
            .card-suit-corner {
                font-size: 11px;
            }
            
            .card-center {
                font-size: 20px;
            }
            
            .card-stack {
                width: 60px;
                height: 90px;
                font-size: 24px;
            }
            
            .header h1 {
                font-size: 16px;
            }
            
            .info-item {
                font-size: 11px;
            }
            
            .actions button {
                font-size: 13px;
                padding: 8px 12px;
            }
            
            .meld-building-area {
                min-height: 140px;
                margin: 4px 6px;
                padding: 6px 8px;
            }
            
            .meld-building-content {
                min-height: 110px;
            }
            
            .current-meld-section {
                min-width: 200px;
            }
            
            .meld-building-area .meld-group {
                min-height: 100px;
            }
        }
    
/* --- Layout override --- */

/* Layout C: Compact mode (more table, less chrome) */
.header{ margin: 6px; padding: 8px 12px; border-radius: 10px; }
.header h1{ font-size: 22px; }
.header .stats{ gap: 12px; }
.main-game-area{ padding-left: 12px; }
.game-screen{ padding: 10px 12px; }
.message-container{ margin: 6px; }
.message-box{ margin: 8px 0; padding: 8px 10px; }
.meld-group{ margin-bottom: 8px; padding: 10px; }
.actions{ margin: 8px 0; gap: 8px; }
/* Sticky hand and reduced padding */
.hand-area{ position: sticky; bottom: 0; left: 0; z-index: 40; margin: 8px 0 0 0; border-radius: 12px; background: rgba(248,249,250,0.98); backdrop-filter: blur(6px); box-shadow: 0 -6px 16px rgba(0,0,0,0.10); padding: 8px 10px; }
.hand-label{ margin-bottom: 6px; font-size: 14px; }
.cards-container{ gap: 6px; }
.card{ box-shadow: 0 2px 6px rgba(0,0,0,0.10); }
/* Default-collapse side panel on narrower screens */
  @media (max-width: 1400px){ .side-panel{ width: 240px; } .side-panel-toggle.expanded{ left: 240px; } .side-panel.collapsed{ margin-left: -240px; } }
  @media (max-width: 768px){ 
      .side-panel{ width: 260px; } 
      .side-panel-toggle.expanded{ left: 260px; } 
      .side-panel.collapsed{ margin-left: -260px; }
      
      /* Adjust table player positions for smaller screens */
      .table-player-position {
          min-width: 110px;
          max-width: 140px;
          padding: 6px 8px;
          font-size: 11px;
      }
      
      .table-player-name {
          font-size: 11px;
      }
      
      .table-player-avatar {
          font-size: 14px;
      }
      
      .table-player-stats {
          font-size: 10px;
      }
      
      .table-player-quarters {
          width: 20px;
          height: 20px;
          font-size: 10px;
      }
  }


        .header-message{
            display:flex;
            flex-direction:column;
            gap:6px;
            flex: 1 1 auto;
            align-items: stretch;
            justify-content: center;
            margin: 0 10px;
            min-width: 0;
        }
        .message-pill{
            display:block;
            padding: 8px 16px;
            border-radius: 999px;
            background: #d4edda;
            color: #155724;
            font-size: clamp(11px, 3vw, 13px);
            font-weight: 600;
            line-height: 1.3;
            text-align: center;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .message-pill.success{
            background:#d4edda;
            color:#155724;
        }
        .message-pill.warning{
            background:#fff3cd;
            color:#856404;
        }
        .ai-highlight .card-stack{
            box-shadow: 0 0 0 3px rgba(40,167,69,0.65);
            border-radius: 10px;
            animation: aiPulse 0.9s ease-in-out 1;
        }
        @keyframes aiPulse{
            0%{ transform: scale(1); }
            40%{ transform: scale(1.04); }
            100%{ transform: scale(1); }
        }
        .sticky-winner{
            position: relative;
            z-index: 10;
            background: rgba(255,255,255,0.98);
            border-radius: 12px;
            padding: 8px 10px;
            box-shadow: 0 6px 14px rgba(0,0,0,0.12);
            min-height: 240px; /* fixed min-height prevents jump */
            max-height: 300px;
            overflow-y: auto;
            margin-bottom: 10px;
        }
        
        .wild-picker-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        
        .wild-picker-modal {
            background: white;
            border-radius: 12px;
            padding: 20px;
            max-width: 400px;
            width: 90%;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        }
        
        .wild-picker-modal h3 {
            margin: 0 0 15px 0;
            color: #1e3c72;
            text-align: center;
        }
        
        .wild-picker-cards {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: center;
            margin-bottom: 15px;
        }
        
        .wild-picker-card {
            width: 50px;
            height: 70px;
            border: 2px solid #333;
            border-radius: 6px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            background: linear-gradient(to bottom, #ffffff 0%, #f5f5f5 100%);
            font-weight: bold;
        }
        
        .wild-picker-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        
        .wild-picker-card.red {
            color: #dc3545;
            border-color: #dc3545;
        }
        
        .wild-picker-card.black {
            color: #1a1a1a;
            border-color: #1a1a1a;
        }
        
        .wild-picker-card .rank {
            font-size: 18px;
        }
        
        .wild-picker-card .suit {
            font-size: 20px;
        }
        
        .wild-picker-cancel {
            display: block;
            width: 100%;
            padding: 10px;
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
        }
        
        .wild-picker-cancel:hover {
            background: #5a6268;
        }
</style>

<style>
/* --- Contained sticky bottom bar (Your Hand) ---
   We pin the hand to the bottom of the viewport BUT offset it so it sits only under the right panel,
   not underneath the left side panel. We use :has() so it tracks the collapsed state without JS.
*/
.game-content-wrapper { position: relative; }

/* Default: assume side panel is visible (280px). */
.hand-area.sticky-hand,
.your-hand-panel{
  position: fixed;
  /* inset within the right panel bounds */
  bottom: clamp(12px, 1.5vw, 20px);
  left: calc(280px + clamp(12px, 1.5vw, 20px));
  right: clamp(12px, 1.5vw, 20px);
  z-index: 60;

  /* match the rounded, card-like panels */
  background: #fff7d6;
  border: 2px solid #e0b84f;
  border-radius: 18px;
  box-shadow: 0 -6px 18px rgba(0,0,0,0.14);

  padding-bottom: env(safe-area-inset-bottom);
}

/* If the side panel is collapsed, keep the same inset but start at the left edge */
.game-content-wrapper:has(.side-panel.collapsed) .hand-area.sticky-hand,
.game-content-wrapper:has(.side-panel.collapsed) .your-hand-panel{
  left: clamp(12px, 1.5vw, 20px);
}

/* Ensure the right panel has space for the fixed hand at bottom */
.game-screen{
  padding-bottom: clamp(180px, 22vh, 220px);
}

/* --- Your Final Play Panel (matches Your Hand styling) --- */
.your-final-play-panel {
  position: fixed;
  bottom: clamp(12px, 1.5vw, 20px);
  left: calc(280px + clamp(12px, 1.5vw, 20px));
  right: clamp(12px, 1.5vw, 20px);
  z-index: 60;
  
  /* Match Your Hand panel styling */
  background: #fff7d6;
  border: 2px solid #e0b84f;
  border-radius: 18px;
  box-shadow: 0 -6px 18px rgba(0,0,0,0.14);
  padding-bottom: env(safe-area-inset-bottom);
  
  /* Structure for scrollable content */
  padding: 8px 12px;
  box-sizing: border-box;
  display: flex;
  flex-direction: column;
  
  /* Limit height to ensure the panel doesn't cover too much of the game area */
  max-height: 50vh;
  overflow: hidden;
}

/* If the side panel is collapsed, adjust left position */
.game-content-wrapper:has(.side-panel.collapsed) .your-final-play-panel{
  left: clamp(12px, 1.5vw, 20px);
}

/* Inner content area that can scroll if needed */
.your-final-play-panel .final-play-content {
  flex: 1;
  min-height: 0;
  overflow-y: auto;
  overflow-x: visible;
}

/* Header styling */
.your-final-play-panel h3 {
  color: #856404;
  margin: 0 0 8px 0;
  font-size: 16px;
  flex-shrink: 0;
}
</style>


<style>
/* Winner hand header row + inline tip */
.winner-hand-header-row{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:8px;}
.winner-tip-pill{background:#d1ecf1;border:1px solid #bee5eb;color:#0c5460;font-weight:700;font-size:13px;padding:6px 10px;border-radius:10px;white-space:nowrap;}
</style>


<style>
<style>
/* Meld-building containers: keep the nice boxed area, but let cards use the SAME sizing as the Winning Hand cards (default .card clamp sizes). */
.meld-group .cards-container,
.meld-building-area .cards-container{
  padding: 12px;
  background: rgba(255,255,255,0.55);
  border: 1px solid rgba(0,0,0,0.12);
  border-radius: 12px;
  min-height: 120px;
  overflow-x: auto;
  flex-wrap: nowrap;
  justify-content: flex-start;
}
</style>


<style>
/* Side panel joker sizing: match card size with ~1px padding */
.side-panel .joker-icon,
.player-panel .joker-icon {
  width: calc(var(--card-width) - 2px);
  height: calc(var(--card-height) - 2px);
  padding: 1px;
  box-sizing: border-box;
}
.side-panel .joker-icon img,
.player-panel .joker-icon img {
  width: 100%;
  height: 100%;
  object-fit: contain;
}
</style>

</head>
<body>
    <div id="root"></div>

    <!-- Main application script with JSX syntax. Uses type="text/babel" for Babel transpilation -->
    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        const CARD_VALUES = {
            '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10,
            'J': 11, 'Q': 12, 'K': 13, 'A': 14
        };

        const SUITS = ['â™ ', 'â™¥', 'â™¦', 'â™£'];
        const RANKS = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];

        // More realistic AI characters with actual names
        const AI_CHARACTERS = [
            {
                name: "Heather",
                avatar: "ðŸ‘©â€ðŸ’»",
                dialogues: {
                    start: ["Let's do this!", "Ready to win!", "Here we go!"],
                    draw: ["Come on, good card...", "What do I have?", "Let's see..."],
                    discard: ["Don't need this.", "Out you go.", "This one."],
                    payme: ["PAY ME! Yes!", "Got it! Everyone pay!", "Pay up, everyone!"],
                    lose: ["Darn it.", "So close!", "Next time."]
                }
            },
            {
                name: "Holly",
                avatar: "ðŸ‘©â€âš•ï¸",
                dialogues: {
                    start: ["Excited!", "Let's play!", "Ready!"],
                    draw: ["Ooh, what is it?", "Come on...", "Please be good!"],
                    discard: ["Bye!", "This one goes.", "Don't want it."],
                    payme: ["PAY ME! Woohoo!", "Yes! Pay me!", "I won! Pay up!"],
                    lose: ["Aww!", "Oh well!", "Almost!"]
                }
            },
            {
                name: "Andy",
                avatar: "ðŸ‘¨â€ðŸ¦³",
                dialogues: {
                    start: ["Alright.", "Let's go.", "Ready."],
                    draw: ["What've we got?", "Here goes.", "Let's see."],
                    discard: ["This one.", "Out.", "Gone."],
                    payme: ["PAY ME! Got it!", "Pay up everyone!", "That's how it's done!"],
                    lose: ["Damn.", "Not this time.", "Whatever."]
                }
            },
            {
                name: "Stefan",
                avatar: "ðŸ‘¨â€ðŸ”¬",
                dialogues: {
                    start: ["Time to focus.", "Concentrating now.", "Let's analyze."],
                    draw: ["Interesting...", "Hmm.", "Calculating..."],
                    discard: ["Optimal choice.", "This goes.", "Logical."],
                    payme: ["PAY ME! Perfect!", "Calculated correctly!", "Everyone pay!"],
                    lose: ["Interesting hand.", "The math didn't work out.", "Next calculation."]
                }
            },
            {
                name: "Michelle",
                avatar: "ðŸ‘©â€ðŸ’¼",
                dialogues: {
                    start: ["This is fun!", "Love this!", "Ready to play!"],
                    draw: ["What's it gonna be?", "Exciting!", "Ooh!"],
                    discard: ["This one!", "Bye card!", "Out!"],
                    payme: ["PAY ME! Amazing!", "Yes! Everyone pay!", "Got it!"],
                    lose: ["Great game!", "Well played everyone!", "Fun round!"]
                }
            },
            {
                name: "Joanne",
                avatar: "ðŸ‘©â€ðŸ¦±",
                dialogues: {
                    start: ["Here we go again.", "Another round.", "Alright."],
                    draw: ["Let's see what we have.", "Hmm.", "Okay."],
                    discard: ["This one goes.", "There.", "Done."],
                    payme: ["PAY ME! Finally!", "About time! Pay up!", "Everyone pay!"],
                    lose: ["Oh dear.", "Not my round.", "That's fine."]
                }
            },
            {
                name: "Ashley",
                avatar: "ðŸ‘±â€â™€ï¸",
                dialogues: {
                    start: ["Let's have fun!", "Ready!", "Excited!"],
                    draw: ["What do I get?", "Come on!", "Let's see!"],
                    discard: ["Don't need this.", "Out!", "This one."],
                    payme: ["PAY ME! Yay!", "Got it! Pay up!", "Everyone pay me!"],
                    lose: ["Aww well.", "Next time!", "Good game!"]
                }
            },
            {
                name: "Jim",
                avatar: "ðŸ‘·â€â™‚ï¸",
                dialogues: {
                    start: ["Let's play.", "Ready.", "Here we go."],
                    draw: ["What's this?", "Alright.", "Let me see."],
                    discard: ["This one.", "Out.", "There."],
                    payme: ["PAY ME! Ha!", "Got it! Everyone pay!", "Pay up!"],
                    lose: ["Good round.", "Well played.", "Nice game."]
                }
            },
            {
                name: "Andi",
                avatar: "ðŸ‘¨â€ðŸ¦³",
                dialogues: {
                    start: ["Chill vibes.", "Let's go.", "Ready."],
                    draw: ["Cool.", "Alright.", "Let's see."],
                    discard: ["Later.", "Peace.", "Out."],
                    payme: ["PAY ME! Nice!", "Sweet! Pay up!", "Got it!"],
                    lose: ["All good.", "No worries.", "It happens."]
                }
            },
            {
                name: "Jordan",
                avatar: "ðŸ‘©â€ðŸ¦°",
                dialogues: {
                    start: ["Ready to crush this.", "Watch this.", "Easy."],
                    draw: ["Give me gold.", "Here it comes.", "Perfect."],
                    discard: ["Trash.", "Don't need it.", "Gone."],
                    payme: ["PAY ME! Too easy!", "Boom! Pay up!", "Who's the best?"],
                    lose: ["Just warming up.", "Lucky hand.", "I'll get you."]
                }
            },
            {
                name: "Morgan",
                avatar: "ðŸ‘©â€ðŸ¦±",
                dialogues: {
                    start: ["Let's see what happens.", "Okay.", "Ready."],
                    draw: ["What is it?", "Hmm.", "Alright."],
                    discard: ["This.", "Out.", "Gone."],
                    payme: ["PAY ME! Great!", "Yes! Pay up!", "Got it!"],
                    lose: ["Oh well.", "Not this time.", "Good game."]
                }
            },
            {
                name: "Matt",
                avatar: "ðŸ‘¨â€ðŸ¦±",
                dialogues: {
                    start: ["Optimizing strategy.", "Calculating.", "Ready."],
                    draw: ["Analyzing.", "Processing.", "Let's see."],
                    discard: ["Best move.", "This one.", "Optimal."],
                    payme: ["PAY ME! Calculated!", "Perfect! Pay up!", "As predicted!"],
                    lose: ["Suboptimal hand.", "Recalculating.", "Interesting."]
                }
            },
            {
                name: "Peyton",
                avatar: "ðŸ§‘",
                dialogues: {
                    start: ["Let's go!", "Ready!", "Here we go!"],
                    draw: ["What is it?", "Come on...", "Let's see..."],
                    discard: ["This one.", "Out.", "Done."],
                    payme: ["PAY ME! Yes!", "Got it!", "Pay up!"],
                    lose: ["Aww.", "Next time.", "Good game."]
                }
            },
            {
                name: "Brian",
                avatar: "ðŸ‘¨â€ðŸ¦²",
                dialogues: {
                    start: ["Ready to play.", "Let's do this.", "Here we go."],
                    draw: ["What've we got?", "Alright.", "Let's see."],
                    discard: ["This one.", "Out.", "Gone."],
                    payme: ["PAY ME! Perfect!", "Got it! Pay up!", "Everyone pay!"],
                    lose: ["Good game.", "Well played.", "Next round."]
                }
            },
            {
                name: "Helen",
                avatar: "ðŸ‘©â€ðŸ¦³",
                dialogues: {
                    start: ["Let's have fun!", "Ready!", "Here we go!"],
                    draw: ["What is it?", "Come on...", "Let's see!"],
                    discard: ["This one.", "Out!", "Done."],
                    payme: ["PAY ME! Wonderful!", "Yes! Pay up!", "Got it!"],
                    lose: ["Oh well.", "Good game!", "Next time."]
                }
            }
        ];

        // Global unique card id counter to avoid collisions when using multiple decks
        let __cardIdCounter = 0;

        function createDeck() {
            const deck = [];
            for (let suit of SUITS) {
                for (let rank of RANKS) {
                    deck.push({
                        rank,
                        suit,
                        isRed: suit === 'â™¥' || suit === 'â™¦',
                        // IMPORTANT: IDs must be unique across *all* decks in play
                        id: `${rank}${suit}-${__cardIdCounter++}`
                    });
                }
            }
            deck.push({ rank: 'JOKER', suit: 'ðŸƒ', isRed: true, id: `JOKER-${__cardIdCounter++}` });
            deck.push({ rank: 'JOKER', suit: 'ðŸƒ', isRed: false, id: `JOKER-${__cardIdCounter++}` });
            return deck;
        }
function shuffle(array) {
            const newArray = [...array];
            for (let i = newArray.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
            }
            return newArray;
        }

        function getDialogue(character, situation) {
            const dialogues = character.dialogues[situation] || [];
            return dialogues[Math.floor(Math.random() * dialogues.length)] || "";
        }

        function isWild(card, round) {
            if (!card) return false; // Safety check for undefined cards
            if (card.rank === 'JOKER') return true;
            const roundCardCount = round + 2;
            return card.rank === roundCardCount.toString() || 
                   (roundCardCount === 11 && card.rank === 'J') ||
                   (roundCardCount === 12 && card.rank === 'Q') ||
                   (roundCardCount === 13 && card.rank === 'K');
        }

        function sortMeld(meld, round) {
            // Sort a meld so runs are in rank order and sets are in suit order
            if (!meld || meld.length === 0) return meld;
            
            const isRun = isValidRun(meld, round);
            const isSet = isValidSet(meld, round);
            
            // If it's a run, sort by rank
            if (isRun) {
                const rankOrder = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
                
                // Get the rank of each card (including what wilds represent)
                // PRESERVE all card properties including addedBy
                const cardsWithRanks = meld.map(card => {
                    let effectiveRank = card.rank;
                    
                    if (card.representsCard) {
                        // Extract rank from representsCard (e.g., "7â™¥" -> "7")
                        const match = card.representsCard.match(/^(A|[2-9]|10|J|Q|K)/);
                        if (match) {
                            effectiveRank = match[1];
                        }
                    }
                    
                    const rankIndex = rankOrder.indexOf(effectiveRank);
                    return { card: {...card}, rankIndex };
                });
                
                // Check if we have an Ace-high run (Ace at end, like J-Q-K-A)
                const hasAce = cardsWithRanks.some(c => c.rankIndex === 0);
                const hasHighCards = cardsWithRanks.some(c => c.rankIndex >= 10); // J, Q, or K
                
                if (hasAce && hasHighCards) {
                    // This might be an Ace-high run - check if Ace should be at the end
                    // Consider ALL ranks including what wilds represent
                    const allRankIndices = cardsWithRanks.map(c => c.rankIndex).filter(i => i >= 0);
                    const nonAceIndices = allRankIndices.filter(i => i !== 0);
                    
                    if (nonAceIndices.length === 0) {
                        // Only Ace - shouldn't happen in valid run
                        cardsWithRanks.sort((a, b) => a.rankIndex - b.rankIndex);
                        return cardsWithRanks.map(c => c.card);
                    }
                    
                    const minNonAce = Math.min(...nonAceIndices);
                    const maxNonAce = Math.max(...nonAceIndices);
                    
                    // If the lowest non-Ace card is 10 or higher (index >= 9), OR
                    // if the highest card is K (index 12) and there are high cards, treat Ace as high
                    if (minNonAce >= 9 || (maxNonAce === 12 && hasHighCards)) {
                        // Sort with Ace as 14 (after K which is 12)
                        const sorted = cardsWithRanks.map(c => ({
                            ...c,
                            sortIndex: c.rankIndex === 0 ? 13 : c.rankIndex
                        })).sort((a, b) => a.sortIndex - b.sortIndex);
                        
                        return sorted.map(c => c.card);
                    }
                }
                
                // Normal sort (Ace low)
                cardsWithRanks.sort((a, b) => a.rankIndex - b.rankIndex);
                return cardsWithRanks.map(c => c.card);
            }
            
            // If it's a set, sort by suit order (â™  â™¥ â™¦ â™£)
            if (isSet) {
                const suitOrder = { 'â™ ': 0, 'â™¥': 1, 'â™¦': 2, 'â™£': 3 };
                
                // PRESERVE all card properties including addedBy
                const cardsWithSuits = meld.map(card => {
                    let effectiveSuit = card.suit;
                    
                    // If it's a wild with representsCard, use the represented suit
                    if (card.representsCard) {
                        const match = card.representsCard.match(/([â™¥â™¦â™£â™ ])$/);
                        if (match) {
                            effectiveSuit = match[1];
                        }
                    }
                    
                    const suitIndex = suitOrder[effectiveSuit] !== undefined ? suitOrder[effectiveSuit] : 999;
                    return { card: {...card}, suitIndex };
                });
                
                cardsWithSuits.sort((a, b) => a.suitIndex - b.suitIndex);
                return cardsWithSuits.map(c => c.card);
            }
            
            // Not a valid meld, return as-is
            return meld;
        }

        function isValidRun(cards, round) {
            if (cards.length < 3) return false;
            // Preserve isWildForRound if explicitly set to true, otherwise recalculate
            const markedCards = cards.map(c => ({
                ...c, 
                isWildForRound: c.isWildForRound === true ? true : isWild(c, round)
            }));
            
            // Treat assigned wilds as the cards they represent
            const processedCards = markedCards.map(c => {
                if (c.isWildForRound && c.representsCard) {
                    // Extract rank and suit from representsCard (e.g., "7â™¥")
                    const match = c.representsCard.match(/^(A|[2-9]|10|J|Q|K)([â™¥â™¦â™£â™ ])$/);
                    if (match) {
                        return { ...c, rank: match[1], suit: match[2], isWildForRound: false };
                    }
                }
                return c;
            });
            
            const nonWilds = processedCards.filter(c => !c.isWildForRound);
            if (nonWilds.length === 0) return false;
            const suit = nonWilds[0].suit;
            const suitCheckPassed = nonWilds.every(c => c.suit === suit);
            if (!suitCheckPassed) {
                return false;
            }
            const rankOrder = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
            const indices = nonWilds.map(c => rankOrder.indexOf(c.rank)).sort((a, b) => a - b);
            
            // Check for duplicate ranks (not allowed in runs)
            for (let i = 1; i < indices.length; i++) {
                if (indices[i] === indices[i-1]) {
                    return false; // Duplicate rank found
                }
            }
            
            const wilds = processedCards.length - nonWilds.length;
            
            // Try normal sequence (A is low)
            let gapsNeeded = 0;
            for (let i = 1; i < indices.length; i++) {
                gapsNeeded += indices[i] - indices[i-1] - 1;
            }
            if (gapsNeeded <= wilds) return true;
            
            // Try with Ace high (if we have an Ace at position 0)
            // Convert A (index 0) to position 13 (after K)
            if (indices[0] === 0) {
                const indicesAceHigh = indices.slice(1).concat([13]);
                let gapsNeededAceHigh = 0;
                for (let i = 1; i < indicesAceHigh.length; i++) {
                    gapsNeededAceHigh += indicesAceHigh[i] - indicesAceHigh[i-1] - 1;
                }
                if (gapsNeededAceHigh <= wilds) return true;
            }
            
            return false;
        }

        function assignJokersInRun(meld, round) {
            // For a run with jokers, determine what card each joker represents
            if (!meld || meld.length === 0) return meld;
            
            // Filter out any undefined or null cards
            const validMeld = meld.filter(c => c && c.rank && c.suit);
            if (validMeld.length === 0) return meld;
            
            const markedCards = validMeld.map(c => ({...c, isWildForRound: isWild(c, round)}));
            const nonWilds = markedCards.filter(c => !c.isWildForRound);
            const wilds = markedCards.filter(c => c.isWildForRound);
            
            if (wilds.length === 0) return validMeld; // No jokers to assign
            if (nonWilds.length === 0) return validMeld; // Can't assign without non-wilds
            
            const suit = nonWilds[0].suit;
            const rankOrder = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
            let nonWildRanks = nonWilds.map(c => rankOrder.indexOf(c.rank)).sort((a, b) => a - b);
            
            // Determine if this is an Ace-high run
            // Check if treating Ace as high creates a better sequence
            let useAceHigh = false;
            if (nonWildRanks[0] === 0 && nonWildRanks.length > 1) {
                // We have an Ace - check if Ace-high makes more sense
                const gapsAceLow = nonWildRanks[nonWildRanks.length - 1] - nonWildRanks[0] - (nonWildRanks.length - 1);
                
                // Try Ace high (move Ace from position 0 to position 13)
                const ranksAceHigh = nonWildRanks.slice(1).concat([13]).sort((a, b) => a - b);
                const gapsAceHigh = ranksAceHigh[ranksAceHigh.length - 1] - ranksAceHigh[0] - (ranksAceHigh.length - 1);
                
                if (gapsAceHigh < gapsAceLow) {
                    useAceHigh = true;
                    nonWildRanks = ranksAceHigh;
                }
            }
            
            // Fill gaps between existing cards and potentially extend the sequence
            const result = [...validMeld];
            
            // Strategy: Fill gaps first, then extend at ends
            const allRanks = [];
            for (let i = 0; i < nonWildRanks.length - 1; i++) {
                allRanks.push(nonWildRanks[i]);
                // Fill gaps between consecutive non-wilds
                for (let gap = nonWildRanks[i] + 1; gap < nonWildRanks[i + 1]; gap++) {
                    allRanks.push(gap);
                }
            }
            allRanks.push(nonWildRanks[nonWildRanks.length - 1]);
            
            // Extend sequence if we still have wilds
            let remaining = wilds.length - (allRanks.length - nonWildRanks.length);
            let lowIdx = allRanks[0];
            let highIdx = allRanks[allRanks.length - 1];
            
            while (remaining > 0 && lowIdx > 0) {
                allRanks.unshift(lowIdx - 1);
                lowIdx--;
                remaining--;
            }
            while (remaining > 0 && highIdx < (useAceHigh ? 13 : 12)) {
                allRanks.push(highIdx + 1);
                highIdx++;
                remaining--;
            }
            
            // Now assign representsCard to each wild that doesn't already have one
            const assignedRanks = new Set(nonWildRanks);
            
            // First, mark ranks that are already represented by manually-assigned wilds
            result.forEach(card => {
                if (isWild(card, round) && card.representsCard) {
                    // This wild already has a manual assignment - preserve it
                    const match = card.representsCard.match(/^(A|[2-9]|10|J|Q|K)/);
                    if (match) {
                        const rankStr = match[1];
                        const rankIdx = rankStr === 'A' && useAceHigh ? 13 : rankOrder.indexOf(rankStr);
                        if (rankIdx >= 0) {
                            assignedRanks.add(rankIdx);
                        }
                    }
                }
            });
            
            // Then assign only the wilds that don't have a representsCard yet
            result.forEach(card => {
                if (isWild(card, round) && !card.representsCard) {
                    // Find next unassigned rank from allRanks
                    for (let rank of allRanks) {
                        if (!assignedRanks.has(rank)) {
                            // Convert rank index to card notation
                            let rankStr;
                            if (rank === 13) {
                                rankStr = 'A'; // Ace high
                            } else {
                                rankStr = rankOrder[rank];
                            }
                            card.representsCard = `${rankStr}${suit}`;
                            assignedRanks.add(rank);
                            break;
                        }
                    }
                }
            });
            
            return result;
        }

        // Auto-assign wild cards in a run when there's only one possible position for each
        function autoAssignWildsInRun(meld, round) {
            if (!meld || meld.length === 0) return meld;
            
            const result = meld.map(c => ({...c})); // Deep copy
            const rankOrder = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
            
            // Get non-wild cards and their positions
            const nonWilds = result.filter(c => !isWild(c, round));
            const unassignedWilds = result.filter(c => isWild(c, round) && !c.representsCard);
            
            if (nonWilds.length === 0 || unassignedWilds.length === 0) return result;
            
            // Determine the suit from non-wild cards
            const suit = nonWilds[0].suit;
            
            // Get the rank indices of non-wild cards
            let nonWildRanks = nonWilds.map(c => rankOrder.indexOf(c.rank)).sort((a, b) => a - b);
            
            // Check for Ace-high run possibility
            let useAceHigh = false;
            if (nonWildRanks.includes(0) && nonWildRanks.length > 1) {
                // Check if Ace-high makes more sense
                const maxRankWithoutAce = Math.max(...nonWildRanks.filter(r => r !== 0));
                if (maxRankWithoutAce >= 10) { // J, Q, K territory
                    useAceHigh = true;
                    nonWildRanks = nonWildRanks.filter(r => r !== 0).concat([13]); // Ace becomes 13
                    nonWildRanks.sort((a, b) => a - b);
                }
            }
            
            // Also count already-assigned wilds
            const assignedWilds = result.filter(c => isWild(c, round) && c.representsCard);
            const assignedRanks = new Set(nonWildRanks);
            assignedWilds.forEach(card => {
                const match = card.representsCard.match(/^(A|[2-9]|10|J|Q|K)/);
                if (match) {
                    const rankStr = match[1];
                    const rankIdx = rankStr === 'A' && useAceHigh ? 13 : rankOrder.indexOf(rankStr);
                    if (rankIdx >= 0) assignedRanks.add(rankIdx);
                }
            });
            
            // Find the range that the run must span
            const minRank = Math.min(...assignedRanks);
            const maxRank = Math.max(...assignedRanks);
            const totalCardsNeeded = maxRank - minRank + 1;
            const totalCardsAvailable = nonWilds.length + assignedWilds.length + unassignedWilds.length;
            
            // Find gaps that MUST be filled (positions between min and max that aren't occupied)
            const gaps = [];
            for (let r = minRank; r <= maxRank; r++) {
                if (!assignedRanks.has(r)) {
                    gaps.push(r);
                }
            }
            
            // If gaps exactly equal unassigned wilds, each wild has exactly one position
            if (gaps.length === unassignedWilds.length) {
                // Auto-assign each wild to fill the gaps
                gaps.sort((a, b) => a - b);
                unassignedWilds.forEach((wild, idx) => {
                    const rankIdx = gaps[idx];
                    const rankStr = rankIdx === 13 ? 'A' : rankOrder[rankIdx];
                    // Find this wild in result array and assign it
                    const wildInResult = result.find(c => c === wild || (c.id === wild.id && isWild(c, round) && !c.representsCard));
                    if (wildInResult) {
                        wildInResult.representsCard = `${rankStr}${suit}`;
                    }
                });
            }
            // If we have more wilds than gaps, there are multiple possible assignments - don't auto-assign
            // If we have fewer wilds than gaps, the run is invalid anyway
            
            return result;
        }

        // Strict check: For runs, a card can only be added if it EXTENDS the run on one end (not in the middle),
        // and (if non-wild) it must match the run suit. Uses existing wild assignments via representsCard.
        function canExtendRunOnEnd(meld, card, round) {
            if (!meld || meld.length < 3 || !card) return false;

            // Determine effective suit/ranks of the current run, honoring representsCard assignments
            const rankOrder = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
            const effective = meld.map(c => {
                if (c && c.representsCard) {
                    const match = c.representsCard.match(/^(A|[2-9]|10|J|Q|K)([â™¥â™¦â™£â™ ])$/);
                    if (match) return { rank: match[1], suit: match[2] };
                }
                return { rank: c.rank, suit: c.suit };
            }).filter(x => x.rank && x.suit);

            if (effective.length === 0) return false;
            const runSuit = effective[0].suit;

            // Build rank indices (with Ace potentially high if run is Ace-high like J-Q-K-A)
            let indices = effective.map(c => rankOrder.indexOf(c.rank)).filter(i => i >= 0);
            if (indices.length === 0) return false;

            const hasAce = indices.includes(0);
            const hasHigh = indices.some(i => i >= 10); // J/Q/K
            const hasLowBeyondAce = indices.some(i => i >= 1 && i <= 8); // 2..9
            // If Ace exists with high cards and no low cards, treat Ace as high (13) for bounds
            if (hasAce && hasHigh && !hasLowBeyondAce) {
                indices = indices.map(i => i === 0 ? 13 : i);
            }

            const minIdx = Math.min(...indices);
            const maxIdx = Math.max(...indices);

            const below = minIdx - 1;
            const above = maxIdx + 1;

            const possibleRanks = [];
            if (below >= 0) possibleRanks.push(below);
            if (above <= 13) possibleRanks.push(above);

            // Card must be same suit if non-wild; wilds may represent needed card in runSuit
            const cardIsWild = isWild(card, round);

            if (!cardIsWild) {
                if (card.suit !== runSuit) return false;
                const cardIdx = rankOrder.indexOf(card.rank);
                // If Ace-high run bounds used 13, allow A to match 13
                const normalizedIdx = (cardIdx === 0 && maxIdx === 13) ? 13 : cardIdx;
                return possibleRanks.includes(normalizedIdx);
            } else {
                // Wild: it is valid only if it can represent one of the needed ranks in the run suit
                return possibleRanks.some(idx => {
                    const rank = (idx === 13) ? 'A' : rankOrder[idx];
                    return !!rank && !!runSuit;
                });
            }
        }

        function isValidSet(cards, round) {
            if (cards.length < 3) return false;
            const markedCards = cards.map(c => ({...c, isWildForRound: isWild(c, round)}));
            const nonWilds = markedCards.filter(c => !c.isWildForRound);
            if (nonWilds.length === 0) return false;
            const rank = nonWilds[0].rank;
            return nonWilds.every(c => c.rank === rank);
        }

        function assignWildsInSet(meld, round) {
            // For sets, assign wild cards to represent different suits of the same rank
            const result = meld.map(c => ({...c}));
            const nonWilds = result.filter(c => !isWild(c, round));
            
            if (nonWilds.length === 0) return result;
            
            const setRank = nonWilds[0].rank;
            const usedSuits = new Set(nonWilds.map(c => c.suit));
            
            // Also track already-assigned wilds
            result.forEach(c => {
                if (isWild(c, round) && c.representsCard) {
                    const match = c.representsCard.match(/([â™¥â™¦â™£â™ ])$/);
                    if (match) usedSuits.add(match[1]);
                }
            });
            
            // Assign unassigned wilds to unused suits first, then allow duplicates
            const availableSuits = SUITS.filter(s => !usedSuits.has(s));
            let suitIndex = 0;
            
            result.forEach(card => {
                if (isWild(card, round) && !card.representsCard) {
                    let suit;
                    if (suitIndex < availableSuits.length) {
                        suit = availableSuits[suitIndex];
                        suitIndex++;
                    } else {
                        // Allow duplicates - pick a random suit
                        suit = SUITS[Math.floor(Math.random() * SUITS.length)];
                    }
                    card.representsCard = `${setRank}${suit}`;
                }
            });
            
            return result;
        }

        // Unified function to detect meld type
        function getMeldType(meld, round) {
            const meldWithWilds = meld.map(c => ({ 
                ...c, 
                isWildForRound: isWild(c, round)
            }));
            
            const canBeSet = isValidSet(meldWithWilds, round);
            const canBeRun = isValidRun(meldWithWilds, round);
            
            return { canBeSet, canBeRun, meldWithWilds };
        }

        // Generate all valid ways a meld with wilds could be interpreted
        function getPossibleMeldInterpretations(cards, round) {
            // Constants for option limits
            const MAX_SET_COMBINATIONS = 5;
            const MAX_EXTENSION_OPTIONS = 3;
            const MAX_ACE_HIGH_OPTIONS = 2;
            
            const options = [];
            const markedCards = cards.map(c => ({ ...c, isWildForRound: isWild(c, round) }));
            const nonWilds = markedCards.filter(c => !c.isWildForRound);
            const wilds = markedCards.filter(c => c.isWildForRound);
            
            // If no non-wilds, this is an all-wilds meld - needs multi-step picker
            if (nonWilds.length === 0) {
                return { allWilds: true, options: [] };
            }
            
            const { canBeSet, canBeRun } = getMeldType(cards, round);
            
            // Generate set interpretations
            if (canBeSet && nonWilds.length > 0) {
                const setRank = nonWilds[0].rank;
                
                // For sets, always generate only ONE interpretation
                // Suit assignment will be handled automatically when the set is selected
                options.push({
                    type: 'set',
                    rank: setRank, // Include rank for reference and potential future use
                    display: `Set of ${setRank}s`,
                    assignments: {}, // Empty - will be auto-assigned by assignWildsInSet
                    needsAutoAssignment: wilds.length > 0 // Flag to indicate auto-assignment needed
                });
            }
            
            // Generate run interpretations
            if (canBeRun && nonWilds.length > 0) {
                const suit = nonWilds[0].suit;
                const rankOrder = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
                let nonWildRanks = nonWilds.map(c => rankOrder.indexOf(c.rank)).sort((a, b) => a - b);
                
                // Check if Ace-high makes sense
                const hasAce = nonWildRanks.includes(0);
                const aceHighOptions = [];
                const aceLowOptions = [];
                
                if (wilds.length > 0) {
                    // Generate possible run positions for wilds
                    const minRank = nonWildRanks[0];
                    const maxRank = nonWildRanks[nonWildRanks.length - 1];
                    const span = maxRank - minRank + 1;
                    const gapsNeeded = span - nonWildRanks.length;
                    const wildsAvailable = wilds.length;
                    
                    // Fill gaps and extend
                    const allRanks = [];
                    for (let i = 0; i < nonWildRanks.length - 1; i++) {
                        allRanks.push(nonWildRanks[i]);
                        for (let gap = nonWildRanks[i] + 1; gap < nonWildRanks[i + 1]; gap++) {
                            allRanks.push(gap);
                        }
                    }
                    allRanks.push(nonWildRanks[nonWildRanks.length - 1]);
                    
                    // Generate extension options
                    const wildsLeft = wildsAvailable - (allRanks.length - nonWildRanks.length);
                    
                    // Try extending low, high, or both
                    const extensionOptions = [];
                    
                    for (let extendLow = 0; extendLow <= wildsLeft && extendLow <= allRanks[0]; extendLow++) {
                        const extendHigh = wildsLeft - extendLow;
                        if (extendHigh >= 0 && allRanks[allRanks.length - 1] + extendHigh <= 12) {
                            const runRanks = [];
                            for (let i = allRanks[0] - extendLow; i < allRanks[0]; i++) runRanks.push(i);
                            runRanks.push(...allRanks);
                            for (let i = allRanks[allRanks.length - 1] + 1; i <= allRanks[allRanks.length - 1] + extendHigh; i++) runRanks.push(i);
                            
                            extensionOptions.push(runRanks);
                        }
                    }
                    
                    // Handle Ace-high extensions
                    // Include Ace-high options when:
                    // 1. There's already an Ace in the meld (hasAce && maxRank >= 10), OR
                    // 2. The highest rank is Q or K and we have wilds that could extend to Ace
                    const shouldConsiderAceHigh = (hasAce && maxRank >= 10) || (maxRank >= 11 && wildsLeft > 0);
                    
                    if (shouldConsiderAceHigh) {
                        // Try Ace-high interpretations
                        const ranksAceHigh = nonWildRanks.filter(r => r !== 0).concat([13]).sort((a, b) => a - b);
                        const aceHighAllRanks = [];
                        for (let i = 0; i < ranksAceHigh.length - 1; i++) {
                            aceHighAllRanks.push(ranksAceHigh[i]);
                            for (let gap = ranksAceHigh[i] + 1; gap < ranksAceHigh[i + 1]; gap++) {
                                aceHighAllRanks.push(gap);
                            }
                        }
                        aceHighAllRanks.push(ranksAceHigh[ranksAceHigh.length - 1]);
                        
                        const wildsLeftAceHigh = wildsAvailable - (aceHighAllRanks.length - ranksAceHigh.length);
                        
                        if (wildsLeftAceHigh >= 0) {
                            for (let extendLow = 0; extendLow <= wildsLeftAceHigh && extendLow <= aceHighAllRanks[0]; extendLow++) {
                                const extendHigh = wildsLeftAceHigh - extendLow;
                                if (extendHigh >= 0 && aceHighAllRanks[aceHighAllRanks.length - 1] + extendHigh <= 13) {
                                    const runRanks = [];
                                    for (let i = aceHighAllRanks[0] - extendLow; i < aceHighAllRanks[0]; i++) runRanks.push(i);
                                    runRanks.push(...aceHighAllRanks);
                                    for (let i = aceHighAllRanks[aceHighAllRanks.length - 1] + 1; i <= aceHighAllRanks[aceHighAllRanks.length - 1] + extendHigh; i++) runRanks.push(i);
                                    
                                    aceHighOptions.push(runRanks);
                                }
                            }
                        }
                    }
                    
                    // Limit options using constants
                    const allRunOptions = [...extensionOptions.slice(0, MAX_EXTENSION_OPTIONS), ...aceHighOptions.slice(0, MAX_ACE_HIGH_OPTIONS)];
                    
                    for (const runRanks of allRunOptions) {
                        // Build display array preserving normal cards and showing wild assignments
                        const display = [];
                        const assignments = {};
                        // Track which card ID corresponds to each display position in runs
                        // This is necessary ONLY for runs where display array gets reordered by rank,
                        // while currentMeld maintains the original user click order (arbitrary).
                        // Without this mapping, normal cards can be incorrectly shown as wild cards in the UI.
                        const cardIds = [];
                        
                        // Create a map of rank to original card for normal cards
                        // Note: In a valid run, each rank appears at most once, so no overwrites should occur
                        const normalCardsByRank = new Map();
                        nonWilds.forEach(c => {
                            // For Ace in Ace-high runs (Q-K-A), map to position 13 instead of 0
                            // Since a run can only have one Ace (either low or high), this is unambiguous
                            const rankIdx = c.rank === 'A' && runRanks.includes(13) ? 13 : rankOrder.indexOf(c.rank);
                            normalCardsByRank.set(rankIdx, c);
                        });
                        
                        // Process each position in the run
                        let wildIdx = 0;
                        runRanks.forEach(r => {
                            const rank = r === 13 ? 'A' : rankOrder[r];
                            
                            if (normalCardsByRank.has(r)) {
                                // This position has a normal card - use its original rank and suit
                                const originalCard = normalCardsByRank.get(r);
                                display.push(`${originalCard.rank}${originalCard.suit}`);
                                cardIds.push(originalCard.id); // Track the card ID
                            } else if (wildIdx < wilds.length) {
                                // This position needs a wild card
                                display.push(`${rank}${suit}`);
                                assignments[wilds[wildIdx].id] = `${rank}${suit}`;
                                cardIds.push(wilds[wildIdx].id); // Track the wild card ID
                                wildIdx++;
                            }
                        });
                        
                        options.push({
                            type: 'run',
                            display: display,
                            assignments: assignments,
                            cardIds: cardIds // Add card ID mapping
                        });
                    }
                } else {
                    // No wilds - just one run interpretation
                    options.push({
                        type: 'run',
                        display: nonWilds.map(c => `${c.rank}${c.suit}`),
                        assignments: {},
                        cardIds: nonWilds.map(c => c.id) // Add card ID mapping for no-wild runs
                    });
                }
            }
            
            return { allWilds: false, options: options };
        }

        function calculateScore(cards) {
            return cards.reduce((sum, card) => {
                if (card.rank === 'JOKER') return sum + 20;
                return sum + CARD_VALUES[card.rank];
            }, 0);
        }

        function makeAIDecision(hand, discardPile, round, deckCount, justDrawnCard = null) {
            const topDiscard = discardPile[discardPile.length - 1];
            let drawFromDiscard = false;
            if (topDiscard) {
                if (isWild(topDiscard, round)) {
                    // Always take a wild card!
                    drawFromDiscard = true;
                } else {
                    // Check for set opportunity (1+ matching ranks - can complete or build toward a set)
                    const matchingCards = hand.filter(c => c.rank === topDiscard.rank);
                    const wildCards = hand.filter(c => isWild(c, round));
                    
                    // Take if we have 2+ matching, OR 1 matching + a wild
                    if (matchingCards.length >= 2 || (matchingCards.length >= 1 && wildCards.length >= 1)) {
                        drawFromDiscard = true;
                    } else {
                        // Check for run opportunity - see if this card would help form a run
                        const rankOrder = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
                        const discardRankIdx = rankOrder.indexOf(topDiscard.rank);
                        const discardSuit = topDiscard.suit;
                        
                        // Look for cards 1 or 2 ranks away in the same suit (or wilds)
                        const nearbyCards = hand.filter(c => {
                            if (isWild(c, round)) return true; // Wilds can help complete runs
                            if (c.suit !== discardSuit) return false;
                            const cardRankIdx = rankOrder.indexOf(c.rank);
                            const distance = Math.abs(cardRankIdx - discardRankIdx);
                            return distance <= 2 && distance > 0;
                        });
                        
                        // If we have 2+ cards that could form a run with this discard, take it
                        // Also take if we have 1 nearby card + a wild
                        if (nearbyCards.length >= 2) {
                            drawFromDiscard = true;
                        } else if (nearbyCards.length >= 1) {
                            // Check if one of those nearby is adjacent (distance 1) - stronger run potential
                            const adjacentCards = hand.filter(c => {
                                if (isWild(c, round)) return false;
                                if (c.suit !== discardSuit) return false;
                                const cardRankIdx = rankOrder.indexOf(c.rank);
                                return Math.abs(cardRankIdx - discardRankIdx) === 1;
                            });
                            if (adjacentCards.length >= 1) {
                                drawFromDiscard = true;
                            }
                        }
                    }
                }
            }
            
            // Smart discard: find the card with least meld potential
            const rankOrder = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
            let worstCardIndex = -1; // Changed from 0 to -1 to detect if no card was chosen
            let worstScore = -Infinity;
            
            hand.forEach((card, index) => {
                // CRITICAL FIX: Never discard the card we just drew from the discard pile
                if (justDrawnCard && card.id === justDrawnCard.id) {
                    return;
                }
                
                if (isWild(card, round)) {
                    // Never discard wilds
                    return;
                }
                
                let score = 0;
                
                // 1. Penalty for high point value (we want to discard high cards)
                const pointValue = CARD_VALUES[card.rank] || 0;
                score -= pointValue * 2; // Multiply by 2 to prioritize point reduction
                
                // 2. Bonus for being part of a potential set (cards with same rank)
                const sameRankCount = hand.filter(c => c.rank === card.rank && c.id !== card.id).length;
                if (sameRankCount >= 2) {
                    score += 50; // Strong bonus - part of a set
                } else if (sameRankCount === 1) {
                    score += 20; // Moderate bonus - potential set
                }
                
                // 3. Bonus for being part of a potential run (cards near in rank, same suit)
                const cardRankIdx = rankOrder.indexOf(card.rank);
                const sameSuitNearby = hand.filter(c => {
                    if (c.suit !== card.suit || c.id === card.id) return false;
                    if (isWild(c, round)) return true; // Wilds can help runs
                    const otherRankIdx = rankOrder.indexOf(c.rank);
                    const distance = Math.abs(otherRankIdx - cardRankIdx);
                    return distance <= 2 && distance > 0;
                }).length;
                
                if (sameSuitNearby >= 2) {
                    score += 40; // Strong bonus - part of a run
                } else if (sameSuitNearby === 1) {
                    score += 15; // Moderate bonus - potential run
                }
                
                // 4. Small bonus for mid-range ranks (more flexible for runs)
                if (cardRankIdx >= 3 && cardRankIdx <= 9) { // 4-10
                    score += 5;
                }
                
                // The card with the WORST score (most negative) gets discarded
                if (score < worstScore) {
                    worstScore = score;
                    worstCardIndex = index;
                }
            });
            
            // Safety check: if worstCardIndex is still -1, find first non-wild card that's not the drawn card
            if (worstCardIndex === -1) {
                worstCardIndex = hand.findIndex(card => !isWild(card, round) && (!justDrawnCard || card.id !== justDrawnCard.id));
                // If still -1, hand is all wild cards or only the drawn card - discard the last non-drawn card
                if (worstCardIndex === -1) {
                    worstCardIndex = hand.findIndex(card => !justDrawnCard || card.id !== justDrawnCard.id);
                    if (worstCardIndex === -1) {
                        worstCardIndex = hand.length - 1; // Last resort
                    }
                }
            }
            
            return { drawFromDiscard, discardIndex: worstCardIndex };
        }

        // Find the best combination of melds from a hand of cards
        // @param {Array} hand - The cards to form melds from
        // @param {Number} round - The current round number
        // @param {Boolean} reserveForDiscard - If true, ensures at least 1 card remains unmelded for the required discard.
        //                                      Should always be true in normal gameplay since every player must discard.
        //                                      Only set to false in special scenarios (if any future logic needs it).
        function findBestMelds(hand, round, reserveForDiscard = true) {
            const markedHand = hand.map(card => ({ ...card, isWildForRound: isWild(card, round) }));
            
            // Try to find the optimal combination of melds that maximizes cards used
            // or minimizes remaining points
            function findAllPossibleMelds(cards) {
                const possibleMelds = [];
                
                // Check all combinations of 3+ cards
                for (let size = 3; size <= cards.length; size++) {
                    const combos = combinations(cards, size);
                    for (let combo of combos) {
                        if (isValidSet(combo, round) || isValidRun(combo, round)) {
                            possibleMelds.push(combo);
                        }
                    }
                }
                
                return possibleMelds;
            }
            
            function combinations(array, size) {
                if (size > array.length) return [];
                if (size === array.length) return [array];
                if (size === 1) return array.map(item => [item]);
                const combos = [];
                for (let i = 0; i <= array.length - size; i++) {
                    const head = array[i];
                    const tailCombos = combinations(array.slice(i + 1), size - 1);
                    for (let tail of tailCombos) {
                        combos.push([head, ...tail]);
                    }
                }
                return combos;
            }
            
            function findBestMeldCombination(cards, allMelds) {
                // Recursive function to find the best non-overlapping set of melds
                let bestSolution = { melds: [], cardsUsed: 0, remainingPoints: Infinity };
                
                function tryMelds(currentMelds, usedCards, meldIndex) {
                    // Calculate current solution quality
                    const cardsUsed = usedCards.size;
                    const remaining = cards.filter(c => !usedCards.has(c.id));
                    const remainingPoints = remaining.reduce((sum, c) => sum + (CARD_VALUES[c.rank] || 0), 0);
                    
                    // Update best if this is better
                    if (cardsUsed > bestSolution.cardsUsed || 
                        (cardsUsed === bestSolution.cardsUsed && remainingPoints < bestSolution.remainingPoints)) {
                        bestSolution = { 
                            melds: [...currentMelds], 
                            cardsUsed, 
                            remainingPoints,
                            remaining 
                        };
                    }
                    
                    // Try adding more melds
                    for (let i = meldIndex; i < allMelds.length; i++) {
                        const meld = allMelds[i];
                        
                        // Check if this meld overlaps with already used cards
                        const overlaps = meld.some(card => usedCards.has(card.id));
                        if (overlaps) continue;
                        
                        // Add this meld and recurse
                        const newUsedCards = new Set(usedCards);
                        meld.forEach(card => newUsedCards.add(card.id));
                        
                        tryMelds([...currentMelds, meld], newUsedCards, i + 1);
                    }
                }
                
                tryMelds([], new Set(), 0);
                return bestSolution;
            }
            
            const allPossibleMelds = findAllPossibleMelds(markedHand);
            let bestCombination = findBestMeldCombination(markedHand, allPossibleMelds);
            
            // If reserveForDiscard is true AND all cards would be in melds, remove one card from a meld
            if (reserveForDiscard && bestCombination.remaining.length === 0 && bestCombination.melds.length > 0) {
                // Find the smallest meld and remove the lowest-value non-wild card from it
                let smallestMeldIdx = 0;
                let smallestSize = bestCombination.melds[0].length;
                for (let i = 1; i < bestCombination.melds.length; i++) {
                    if (bestCombination.melds[i].length < smallestSize) {
                        smallestSize = bestCombination.melds[i].length;
                        smallestMeldIdx = i;
                    }
                }
                
                const smallestMeld = [...bestCombination.melds[smallestMeldIdx]];
                
                // Find lowest-value non-wild card in the meld
                let lowestValueIdx = -1;
                let lowestValue = Infinity;
                for (let i = 0; i < smallestMeld.length; i++) {
                    const card = smallestMeld[i];
                    if (!isWild(card, round)) {
                        const value = CARD_VALUES[card.rank] || 0;
                        if (value < lowestValue) {
                            lowestValue = value;
                            lowestValueIdx = i;
                        }
                    }
                }
                
                // If no non-wild found (all wilds), just take the last card
                if (lowestValueIdx === -1) {
                    lowestValueIdx = smallestMeld.length - 1;
                }
                
                // Remove the card from the meld
                const removedCard = smallestMeld.splice(lowestValueIdx, 1)[0];
                
                // Update bestCombination
                const updatedMelds = [...bestCombination.melds];
                
                // If meld is now invalid (< 3 cards), dissolve it completely
                if (smallestMeld.length < 3) {
                    // Add all cards from this meld to remaining
                    bestCombination.remaining = [...bestCombination.remaining, ...smallestMeld, removedCard];
                    updatedMelds.splice(smallestMeldIdx, 1);
                } else {
                    // Keep the meld with the card removed
                    updatedMelds[smallestMeldIdx] = smallestMeld;
                    bestCombination.remaining = [...bestCombination.remaining, removedCard];
                }
                
                bestCombination = {
                    ...bestCombination,
                    melds: updatedMelds
                };
            }
            
            // Assign wild cards and sort all melds
            const finalMelds = bestCombination.melds.map(meld => {
                const hasWilds = meld.some(card => isWild(card, round));
                if (hasWilds) {
                    if (isValidRun(meld, round)) {
                        const meldWithAssignedWilds = assignJokersInRun(meld, round);
                        return sortMeld(meldWithAssignedWilds, round);
                    } else if (isValidSet(meld, round)) {
                        const meldWithAssignedWilds = assignWildsInSet(meld, round);
                        return sortMeld(meldWithAssignedWilds, round);
                    }
                }
                return sortMeld(meld, round);
            });
            
            return { 
                melds: finalMelds, 
                remaining: bestCombination.remaining || markedHand 
            };
        }

        function Celebration({ playerName, onClose }) {
            useEffect(() => {
                const timer = setTimeout(onClose, 3000);
                return () => clearTimeout(timer);
            }, []);

            return (
                <div className="celebration-overlay">
                    <div className="celebration-content">
                        <h2>ðŸ’° PAY ME! ðŸ’°</h2>
                        <div className="winner-name">{playerName}</div>
                        <div className="coins">ðŸ’µðŸ’µðŸ’µ</div>
                        <p style={{fontSize: '20px', color: '#666'}}>Everyone pays up!</p>
                    </div>
                </div>
            );
        }

        function ScoreDetailsModal({ player, round, onClose }) {
            if (!player) return null;

            return (
                <div className="celebration-overlay" onClick={onClose}>
                    <div className="score-details-modal" onClick={(e) => e.stopPropagation()}>
                        <div className="score-details-header">
                            <h2>{player.avatar} {player.name} - Score History</h2>
                            <button onClick={onClose} style={{fontSize: '24px', padding: '5px 15px'}}>Ã—</button>
                        </div>
                        <div className="score-details-content">
                            {player.roundHistory && player.roundHistory.length > 0 ? (
                                <table className="score-detail-table">
                                    <thead>
                                        <tr>
                                            <th>Round</th>
                                            <th>Melds</th>
                                            <th>Remaining</th>
                                            <th>Points</th>
                                            <th>Total</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        {player.roundHistory.map((roundData, idx) => (
                                            <tr key={idx} className={roundData.wasWinner ? 'winner-round' : ''}>
                                                <td>
                                                    <strong>Round {roundData.round}</strong>
                                                    {roundData.wasWinner && <span style={{marginLeft: '5px'}}>ðŸ†</span>}
                                                </td>
                                                <td>
                                                    {roundData.melds.length > 0 ? (
                                                        roundData.melds.map((meld, meldIdx) => (
                                                            <div key={meldIdx} className="mini-cards" style={{marginBottom: '4px'}}>
                                                                {meld.map((card, cardIdx) => (
                                                                    <MiniCard key={cardIdx} card={{...card, isWildForRound: isWild(card, roundData.round)}} />
                                                                ))}
                                                            </div>
                                                        ))
                                                    ) : (
                                                        <span style={{color: '#999'}}>None</span>
                                                    )}
                                                </td>
                                                <td>
                                                    {roundData.remainingCards.length > 0 ? (
                                                        <div className="mini-cards">
                                                            {roundData.remainingCards.filter(c => !c.addedBy).map((card, cardIdx) => (
                                                                <MiniCard key={cardIdx} card={{...card, isWildForRound: isWild(card, roundData.round)}} />
                                                            ))}
                                                        </div>
                                                    ) : (
                                                        <span style={{color: '#28a745', fontWeight: 'bold'}}>None</span>
                                                    )}
                                                    {roundData.playedOnCards && roundData.playedOnCards.length > 0 && (
                                                        <>
                                                            <div style={{fontSize: '11px', color: '#666', marginTop: '4px'}}>Played off:</div>
                                                            <div className="mini-cards" style={{opacity: 0.7}}>
                                                                {roundData.playedOnCards.map((card, cardIdx) => (
                                                                    <MiniCard key={cardIdx} card={{...card, isWildForRound: isWild(card, roundData.round)}} />
                                                                ))}
                                                            </div>
                                                        </>
                                                    )}
                                                </td>
                                                <td>
                                                    <strong style={{color: roundData.roundScore === 0 ? '#28a745' : '#dc3545'}}>
                                                        {roundData.roundScore === 0 ? '0' : `+${roundData.roundScore}`}
                                                    </strong>
                                                </td>
                                                <td><strong>{roundData.runningScore}</strong></td>
                                            </tr>
                                        ))}
                                    </tbody>
                                </table>
                            ) : (
                                <p style={{textAlign: 'center', color: '#666', padding: '20px'}}>
                                    No rounds completed yet.
                                </p>
                            )}
                        </div>
                    </div>
                </div>
            );
        }

        function MiniCard({ card, isWinnerHand }) {
            // If this is for the winner's hand, use the full card component
            if (isWinnerHand) {
                // If card has addedBy, don't show ORIGINAL tag
                return <WinnerHandCard card={card} showOriginalTag={!card.addedBy} />;
            }
            
            // Otherwise use the compact mini-card for sidebar
            const isJoker = card.rank === 'JOKER';
            const representsCard = card.representsCard;
            // Don't show addedBy in sidebar - that's only for winner's hand display
            // Use the card's ACTUAL suit for the card color (not the represented suit)
            const isRed = card.suit === 'â™¥' || card.suit === 'â™¦';
            // But determine the represented suit's color for the =X display
            const representedSuit = representsCard ? representsCard.slice(-1) : null;
            const representedIsRed = representedSuit === 'â™¥' || representedSuit === 'â™¦';
            
            if (isJoker) {
                // Joker: emoji filling entire card to border with =X overlaid
                return (
                    <div 
                        className={`mini-card ${card.isWildForRound ? 'wild' : ''}`}
                        title={representsCard ? `Represents ${representsCard}` : ''}
                        style={{
                            position: 'relative', 
                            display: 'inline-flex',
                            alignItems: 'center',
                            justifyContent: 'center',
                            padding: '0'
                        }}
                    >
                        <div style={{
                            position: 'absolute',
                            top: 0,
                            left: 0,
                            right: 0,
                            bottom: 0,
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center',
                            fontSize: '38px',
                            lineHeight: '1'
                        }}>ðŸƒ</div>
                        {representsCard && (
                            <div style={{
                                position: 'absolute',
                                bottom: '1px',
                                right: '1px',
                                fontSize: '7px',
                                fontWeight: 'bold',
                                color: representedIsRed ? '#e74c3c' : '#000',
                                background: 'rgba(255,255,255,0.95)',
                                padding: '0px 2px',
                                borderRadius: '2px',
                                zIndex: 10,
                                border: '0.5px solid #b8860b',
                                lineHeight: '1.1'
                            }}>
                                ={representsCard}
                            </div>
                        )}
                    </div>
                );
            }
            
            // Regular card: rank on top, suit below
            return (
                <div 
                    className={`mini-card ${isRed ? 'red' : 'black'} ${card.isWildForRound ? 'wild' : ''}`}
                    title={representsCard ? `Represents ${representsCard}` : ''}
                    style={{
                        position: 'relative', 
                        display: 'inline-flex',
                        flexDirection: 'column',
                        alignItems: 'center',
                        justifyContent: 'center',
                        gap: '2px'
                    }}
                >
                    <div style={{fontSize: '12px', fontWeight: 'bold', lineHeight: '1'}}>{card.rank}</div>
                    <div style={{fontSize: '14px', lineHeight: '1'}}>{card.suit}</div>
                    {representsCard && (
                        <div style={{
                            position: 'absolute',
                            bottom: '1px',
                            fontSize: '8px',
                            fontWeight: 'bold',
                            color: representedIsRed ? '#e74c3c' : '#000',
                            opacity: 0.8
                        }}>
                            ={representsCard}
                        </div>
                    )}
                </div>
            );
        }
        
        function WinnerHandCard({ card, showOriginalTag = true }) {
            const isJoker = card.rank === 'JOKER';
            const isFaceCard = ['J', 'Q', 'K'].includes(card.rank);
            const isWildCard = card.isWildForRound && !isJoker;
            const representsCard = card.representsCard;
            const addedBy = card.addedBy;
            // Use the card's ACTUAL suit for the card color (not the represented suit)
            const isRed = card.suit === 'â™¥' || card.suit === 'â™¦';
            // But determine the represented suit's color for the =X display
            const representedSuit = representsCard ? representsCard.slice(-1) : null;
            const representedIsRed = representedSuit === 'â™¥' || representedSuit === 'â™¦';
            const className = `winner-hand-card ${isFaceCard ? 'face-card' : ''} ${isRed ? 'red' : 'black'} ${card.isWildForRound ? 'wild' : ''}`;
            
            const getFaceCardName = (rank) => {
                if (rank === 'J') return 'JACK';
                if (rank === 'Q') return 'QUEEN';
                if (rank === 'K') return 'KING';
                return '';
            };
            
            // Generate suit pattern for number cards (smaller version)
            const getSuitPattern = (rank, suit) => {
                const patterns = {
                    '2': [{ top: '25%', left: '50%' }, { top: '75%', left: '50%', rotate: 180 }],
                    '3': [{ top: '19%', left: '50%' }, { top: '50%', left: '50%' }, { top: '80%', left: '50%', rotate: 180 }],
                    '4': [
                        { top: '25%', left: '35%' }, { top: '25%', left: '65%' },
                        { top: '75%', left: '35%', rotate: 180 }, { top: '75%', left: '65%', rotate: 180 }
                    ],
                    '5': [
                        { top: '20%', left: '35%' }, { top: '20%', left: '65%' },
                        { top: '50%', left: '50%' },
                        { top: '80%', left: '35%', rotate: 180 }, { top: '80%', left: '65%', rotate: 180 }
                    ],
                    '6': [
                        { top: '20%', left: '35%' }, { top: '20%', left: '65%' },
                        { top: '50%', left: '35%' }, { top: '50%', left: '65%' },
                        { top: '80%', left: '35%', rotate: 180 }, { top: '80%', left: '65%', rotate: 180 }
                    ],
                    '7': [
                        { top: '17%', left: '35%' }, { top: '17%', left: '65%' },
                        { top: '35%', left: '50%' },
                        { top: '50%', left: '35%' }, { top: '50%', left: '65%' },
                        { top: '83%', left: '35%', rotate: 180 }, { top: '83%', left: '65%', rotate: 180 }
                    ],
                    '8': [
                        { top: '15%', left: '35%' }, { top: '15%', left: '65%' },
                        { top: '35%', left: '50%' },
                        { top: '50%', left: '35%' }, { top: '50%', left: '65%' },
                        { top: '65%', left: '50%', rotate: 180 },
                        { top: '85%', left: '35%', rotate: 180 }, { top: '85%', left: '65%', rotate: 180 }
                    ],
                    '9': [
                        { top: '15%', left: '35%' }, { top: '15%', left: '65%' },
                        { top: '32%', left: '35%' }, { top: '32%', left: '65%' },
                        { top: '50%', left: '50%' },
                        { top: '68%', left: '35%', rotate: 180 }, { top: '68%', left: '65%', rotate: 180 },
                        { top: '85%', left: '35%', rotate: 180 }, { top: '85%', left: '65%', rotate: 180 }
                    ],
                    '10': [
                        { top: '6%', left: '35%' }, { top: '6%', left: '65%' },
                        { top: '19%', left: '50%' },
                        { top: '32%', left: '35%' }, { top: '32%', left: '65%' },
                        { top: '68%', left: '35%', rotate: 180 }, { top: '68%', left: '65%', rotate: 180 },
                        { top: '81%', left: '50%', rotate: 180 },
                        { top: '94%', left: '35%', rotate: 180 }, { top: '94%', left: '65%', rotate: 180 }
                    ],
                    'A': [{ top: '50%', left: '50%' }]
                };
                
                return patterns[rank] || [];
            };
            
            // Get Unicode playing card character for face cards
            const getFaceCardUnicode = (rank, suit) => {
                const cards = {
                    'Jâ™ ': 'ðŸ‚«', 'Jâ™¥': 'ðŸ‚»', 'Jâ™¦': 'ðŸƒ‹', 'Jâ™£': 'ðŸƒ›',
                    'Qâ™ ': 'ðŸ‚­', 'Qâ™¥': 'ðŸ‚½', 'Qâ™¦': 'ðŸƒ', 'Qâ™£': 'ðŸƒ',
                    'Kâ™ ': 'ðŸ‚®', 'Kâ™¥': 'ðŸ‚¾', 'Kâ™¦': 'ðŸƒŽ', 'Kâ™£': 'ðŸƒž'
                };
                return cards[`${rank}${suit}`] || 'ðŸ‚ ';
            };
            
            return (
                <div className={className} style={{
                    boxShadow: addedBy ? '0 0 0 3px #28a745' : '0 0 0 2px rgba(30, 60, 114, 0.2)',
                    position: 'relative'
                }}>
                    <div className="card-decorative-border"></div>
                    
                    {/* Label for original meld cards */}
                    {showOriginalTag && !addedBy && (
                        <div style={{
                            position: 'absolute',
                            top: '-8px',
                            left: '50%',
                            transform: 'translateX(-50%)',
                            background: '#1e3c72',
                            color: 'white',
                            fontSize: '8px',
                            padding: '2px 6px',
                            borderRadius: '3px',
                            fontWeight: 'bold',
                            whiteSpace: 'nowrap',
                            zIndex: 10,
                            boxShadow: '0 1px 3px rgba(0,0,0,0.3)'
                        }}>
                            ORIGINAL
                        </div>
                    )}
                    
                    {/* Avatar badge in top right corner */}
                    {addedBy && (
                        <div style={{
                            position: 'absolute',
                            top: '4px',
                            right: '4px',
                            fontSize: '14px',
                            background: 'rgba(255,255,255,0.9)',
                            borderRadius: '50%',
                            width: '20px',
                            height: '20px',
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center',
                            border: '2px solid #28a745',
                            boxShadow: '0 2px 4px rgba(0,0,0,0.2)',
                            zIndex: 10
                        }}>
                            {addedBy}
                        </div>
                    )}
                    
                    {!isJoker && (
                        <>
                            {/* Card corners - only for number cards and aces */}
                            {!isFaceCard && (
                                <>
                                    <div className="card-corner top-left">
                                        <div className="card-rank-corner">{card.rank}</div>
                                        <div className="card-suit-corner">{card.suit}</div>
                                    </div>
                                    <div className="card-corner bottom-right">
                                        <div className="card-rank-corner">{card.rank}</div>
                                        <div className="card-suit-corner">{card.suit}</div>
                                    </div>
                                </>
                            )}
                            
                            {/* Card center - different rendering for face cards vs number cards */}
                            {isFaceCard ? (
                                <div style={{
                                    width: '100%',
                                    height: '100%',
                                    display: 'flex',
                                    alignItems: 'center',
                                    justifyContent: 'center'
                                }}>
                                    <div style={{
                                        fontSize: 'clamp(68px, 11.25vw, 128px)',
                                        lineHeight: '1'
                                    }}>
                                        {getFaceCardUnicode(card.rank, card.suit)}
                                    </div>
                                </div>
                            ) : (
                                <div style={{ position: 'absolute', top: '0', left: '0', width: '100%', height: '100%' }}>
                                    {getSuitPattern(card.rank, card.suit).map((pos, idx) => (
                                        <div 
                                            key={idx}
                                            style={{
                                                position: 'absolute',
                                                top: pos.top,
                                                left: pos.left,
                                                transform: `translate(-50%, -50%) ${pos.rotate ? `rotate(${pos.rotate}deg)` : ''}`,
                                                fontSize: 'clamp(12px, 2.5vw, 20px)',
                                                lineHeight: '1'
                                            }}
                                        >
                                            {card.suit}
                                        </div>
                                    ))}
                                </div>
                            )}
                            
                            {representsCard && isWildCard && (
                                <div style={{
                                    position: 'absolute',
                                    bottom: '16px',
                                    left: '50%',
                                    transform: 'translateX(-50%)',
                                    fontSize: '9px',
                                    fontWeight: '600',
                                    background: 'rgba(255,255,255,0.9)',
                                    padding: '2px 5px',
                                    borderRadius: '3px',
                                    border: '1px solid #b8860b',
                                    color: ['â™¥', 'â™¦'].includes(representsCard.slice(-1)) ? '#e74c3c' : '#000',
                                    zIndex: 11
                                }}>
                                    = {representsCard}
                                </div>
                            )}
                        </>
                    )}
                    {isJoker && (
                        <>
                            <div style={{
                                position: 'absolute',
                                top: '3px',
                                left: '3px',
                                right: '3px',
                                bottom: '3px',
                                display: 'flex',
                                alignItems: 'center',
                                justifyContent: 'center',
                                fontSize: 'clamp(60px, 9vw, 110px)',
                                lineHeight: '1'
                            }}>
                                ðŸƒ
                            </div>
                            {representsCard && (
                                <div style={{
                                    position: 'absolute',
                                    bottom: 'clamp(6px, 1vw, 12px)',
                                    left: '50%',
                                    transform: 'translateX(-50%)',
                                    fontSize: 'clamp(9px, 1.2vw, 12px)',
                                    fontWeight: '600',
                                    background: 'rgba(255,255,255,0.95)',
                                    padding: '2px 5px',
                                    borderRadius: '3px',
                                    border: '1px solid #b8860b',
                                    color: ['â™¥', 'â™¦'].includes(representsCard.slice(-1)) ? '#e74c3c' : '#000',
                                    zIndex: 10,
                                    whiteSpace: 'nowrap'
                                }}>
                                    = {representsCard}
                                </div>
                            )}
                        </>
                    )}
                </div>
            );
        }
        function Card({ card, onClick, onDoubleClick, selected, disabled, inMeld, draggable, onDragStart, onDragOver, onDrop, onDragEnd, isDragging, onTouchStart, onTouchMove, onTouchEnd }) {
            const isJoker = card.rank === 'JOKER';
            const isFaceCard = ['J', 'Q', 'K'].includes(card.rank);
            const isWildCard = card.isWildForRound && !isJoker; // Wild number cards
            const representsCard = card.representsCard;
            const addedBy = card.addedBy; // Avatar of player who added this card
            const className = `card ${isFaceCard ? 'face-card' : ''} ${card.isRed ? 'red' : 'black'} ${selected ? 'selected' : ''} ${disabled ? 'disabled' : ''} ${card.isWildForRound ? 'wild' : ''} ${inMeld ? 'in-meld' : ''} ${isDragging ? 'dragging' : ''}`;
            
            const getFaceCardName = (rank) => {
                if (rank === 'J') return 'JACK';
                if (rank === 'Q') return 'QUEEN';
                if (rank === 'K') return 'KING';
                return '';
            };
            
            // Generate suit pattern for number cards
            const getSuitPattern = (rank, suit) => {
                const patterns = {
                    '2': [{ top: '25%', left: '50%' }, { top: '75%', left: '50%', rotate: 180 }],
                    '3': [{ top: '19%', left: '50%' }, { top: '50%', left: '50%' }, { top: '80%', left: '50%', rotate: 180 }],
                    '4': [
                        { top: '25%', left: '35%' }, { top: '25%', left: '65%' },
                        { top: '75%', left: '35%', rotate: 180 }, { top: '75%', left: '65%', rotate: 180 }
                    ],
                    '5': [
                        { top: '20%', left: '35%' }, { top: '20%', left: '65%' },
                        { top: '50%', left: '50%' },
                        { top: '80%', left: '35%', rotate: 180 }, { top: '80%', left: '65%', rotate: 180 }
                    ],
                    '6': [
                        { top: '20%', left: '35%' }, { top: '20%', left: '65%' },
                        { top: '50%', left: '35%' }, { top: '50%', left: '65%' },
                        { top: '80%', left: '35%', rotate: 180 }, { top: '80%', left: '65%', rotate: 180 }
                    ],
                    '7': [
                        { top: '17%', left: '35%' }, { top: '17%', left: '65%' },
                        { top: '35%', left: '50%' },
                        { top: '50%', left: '35%' }, { top: '50%', left: '65%' },
                        { top: '83%', left: '35%', rotate: 180 }, { top: '83%', left: '65%', rotate: 180 }
                    ],
                    '8': [
                        { top: '15%', left: '35%' }, { top: '15%', left: '65%' },
                        { top: '35%', left: '50%' },
                        { top: '50%', left: '35%' }, { top: '50%', left: '65%' },
                        { top: '65%', left: '50%', rotate: 180 },
                        { top: '85%', left: '35%', rotate: 180 }, { top: '85%', left: '65%', rotate: 180 }
                    ],
                    '9': [
                        { top: '15%', left: '35%' }, { top: '15%', left: '65%' },
                        { top: '32%', left: '35%' }, { top: '32%', left: '65%' },
                        { top: '50%', left: '50%' },
                        { top: '68%', left: '35%', rotate: 180 }, { top: '68%', left: '65%', rotate: 180 },
                        { top: '85%', left: '35%', rotate: 180 }, { top: '85%', left: '65%', rotate: 180 }
                    ],
                    '10': [
                        { top: '6%', left: '35%' }, { top: '6%', left: '65%' },
                        { top: '19%', left: '50%' },
                        { top: '32%', left: '35%' }, { top: '32%', left: '65%' },
                        { top: '68%', left: '35%', rotate: 180 }, { top: '68%', left: '65%', rotate: 180 },
                        { top: '81%', left: '50%', rotate: 180 },
                        { top: '94%', left: '35%', rotate: 180 }, { top: '94%', left: '65%', rotate: 180 }
                    ],
                    'A': [{ top: '50%', left: '50%' }]
                };
                
                return patterns[rank] || [];
            };
            
            // Get Unicode playing card character for face cards
            const getFaceCardUnicode = (rank, suit) => {
                const cards = {
                    'Jâ™ ': 'ðŸ‚«', 'Jâ™¥': 'ðŸ‚»', 'Jâ™¦': 'ðŸƒ‹', 'Jâ™£': 'ðŸƒ›',
                    'Qâ™ ': 'ðŸ‚­', 'Qâ™¥': 'ðŸ‚½', 'Qâ™¦': 'ðŸƒ', 'Qâ™£': 'ðŸƒ',
                    'Kâ™ ': 'ðŸ‚®', 'Kâ™¥': 'ðŸ‚¾', 'Kâ™¦': 'ðŸƒŽ', 'Kâ™£': 'ðŸƒž'
                };
                return cards[`${rank}${suit}`] || 'ðŸ‚ ';
            };
            
            return (
                <div 
                    className={className} 
                    onClick={onClick}
                    onDoubleClick={onDoubleClick}
                    draggable={draggable}
                    onDragStart={onDragStart}
                    onDragOver={onDragOver}
                    onDrop={onDrop}
                    onDragEnd={onDragEnd}
                    onTouchStart={onTouchStart}
                    onTouchMove={onTouchMove}
                    onTouchEnd={onTouchEnd}
                >
                    <div className="card-decorative-border"></div>
                    
                    {/* Show avatar badge if card was added by another player */}
                    {addedBy && (
                        <div style={{
                            position: 'absolute',
                            top: '5px',
                            right: '5px',
                            fontSize: '16px',
                            background: 'rgba(255,255,255,0.9)',
                            borderRadius: '50%',
                            width: '24px',
                            height: '24px',
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center',
                            border: '2px solid #28a745',
                            boxShadow: '0 2px 4px rgba(0,0,0,0.2)',
                            zIndex: 10
                        }}>
                            {addedBy}
                        </div>
                    )}
                    
                    {!isJoker && (
                        <>
                            {/* Card corners - only for number cards and aces */}
                            {!isFaceCard && (
                                <>
                                    <div className="card-corner top-left">
                                        <div className="card-rank-corner">{card.rank}</div>
                                        <div className="card-suit-corner">{card.suit}</div>
                                    </div>
                                    <div className="card-corner bottom-right">
                                        <div className="card-rank-corner">{card.rank}</div>
                                        <div className="card-suit-corner">{card.suit}</div>
                                    </div>
                                </>
                            )}
                            
                            {/* Card center - different rendering for face cards vs number cards */}
                            {isFaceCard ? (
                                <div style={{
                                    width: '100%',
                                    height: '100%',
                                    display: 'flex',
                                    alignItems: 'center',
                                    justifyContent: 'center'
                                }}>
                                    {/* Unicode playing card character - exact card size */}
                                    <div style={{
                                        fontSize: 'clamp(105px, 13.5vw, 165px)',
                                        lineHeight: '1'
                                    }}>
                                        {getFaceCardUnicode(card.rank, card.suit)}
                                    </div>
                                </div>
                            ) : (
                                <div style={{ position: 'absolute', top: '0', left: '0', width: '100%', height: '100%' }}>
                                    {getSuitPattern(card.rank, card.suit).map((pos, idx) => (
                                        <div 
                                            key={idx}
                                            style={{
                                                position: 'absolute',
                                                top: pos.top,
                                                left: pos.left,
                                                transform: `translate(-50%, -50%) ${pos.rotate ? `rotate(${pos.rotate}deg)` : ''}`,
                                                fontSize: 'clamp(16px, 3.2vw, 26px)',
                                                lineHeight: '1'
                                            }}
                                        >
                                            {card.suit}
                                        </div>
                                    ))}
                                </div>
                            )}
                            
                            {/* Show what wild cards represent */}
                            {representsCard && isWildCard && (
                                <div style={{
                                    position: 'absolute',
                                    bottom: '20px',
                                    left: '50%',
                                    transform: 'translateX(-50%)',
                                    fontSize: '11px',
                                    fontWeight: '600',
                                    background: 'rgba(255,255,255,0.9)',
                                    padding: '2px 6px',
                                    borderRadius: '3px',
                                    border: '1px solid #b8860b',
                                    color: ['â™¥', 'â™¦'].includes(representsCard.slice(-1)) ? '#e74c3c' : '#000',
                                    zIndex: 11
                                }}>
                                    = {representsCard}
                                </div>
                            )}
                        </>
                    )}
                    {isJoker && (
                        <>
                            <div style={{
                                position: 'absolute',
                                top: '4px',
                                left: '4px',
                                right: '4px',
                                bottom: '4px',
                                display: 'flex',
                                alignItems: 'center',
                                justifyContent: 'center',
                                fontSize: 'clamp(85px, 11vw, 145px)',
                                lineHeight: '1'
                            }}>
                                ðŸƒ
                            </div>
                            {representsCard && (
                                <div style={{
                                    position: 'absolute',
                                    bottom: 'clamp(18px, 2vw, 25px)',
                                    left: '50%',
                                    transform: 'translateX(-50%)',
                                    fontSize: 'clamp(10px, 1.2vw, 13px)',
                                    fontWeight: '600',
                                    background: 'rgba(255,255,255,0.95)',
                                    padding: '3px 6px',
                                    borderRadius: '4px',
                                    border: '1.5px solid #b8860b',
                                    color: ['â™¥', 'â™¦'].includes(representsCard.slice(-1)) ? '#e74c3c' : '#000',
                                    zIndex: 10,
                                    whiteSpace: 'nowrap'
                                }}>
                                    = {representsCard}
                                </div>
                            )}
                        </>
                    )}
                </div>
            );
        }

        function GameSetup({ onStart }) {
            const allPlayerNames = AI_CHARACTERS.map(c => c.name);
            const [playerName, setPlayerName] = useState(allPlayerNames[0]);
            const [aiCount, setAiCount] = useState(3);

            return (
                <div className="setup-screen">
                    <h2>ðŸ’° Pay Me - Game Setup</h2>
                    <div className="form-group">
                        <label>Your Name:</label>
                        <select value={playerName} onChange={(e) => setPlayerName(e.target.value)}>
                            {allPlayerNames.map(name => <option key={name} value={name}>{name}</option>)}
                        </select>
                    </div>
                    <div className="form-group">
                        <label>Number of AI Opponents (1-7):</label>
                        <select value={aiCount} onChange={(e) => setAiCount(parseInt(e.target.value))}>
                            {[1,2,3,4,5,6,7].map(n => <option key={n} value={n}>{n} AI player{n > 1 ? 's' : ''}</option>)}
                        </select>
                    </div>
                    <button onClick={() => onStart({ playerName, aiCount })}>Start Game</button>
                </div>
            );
        }

        function PayMeGame() {
            const [gameStarted, setGameStarted] = useState(false);
            const [players, setPlayers] = useState([]);
            const [currentPlayerIndex, setCurrentPlayerIndex] = useState(0);
            const [round, setRound] = useState(1);
            const [deck, setDeck] = useState([]);
            const [discardPile, setDiscardPile] = useState([]);
            const [selectedCard, setSelectedCard] = useState(null);
            const [selectedCardForWinner, setSelectedCardForWinner] = useState(null); // For adding to winner's melds
            const [message, setMessage] = useState('');
            const [aiDrawHighlight, setAiDrawHighlight] = useState(null);
const [gamePhase, setGamePhase] = useState('draw');
        const [isRoundTransitioning, setIsRoundTransitioning] = useState(false);

            const [roundWinner, setRoundWinner] = useState(null);
            const [winnerMelds, setWinnerMelds] = useState([]);
            const [gameOver, setGameOver] = useState(false);
            const [dealerIndex, setDealerIndex] = useState(0);
            const [buildingPayMe, setBuildingPayMe] = useState(false);
            const [playerMelds, setPlayerMelds] = useState([]);
            const [currentMeld, setCurrentMeld] = useState([]);
            const [meldError, setMeldError] = useState('');
            const [showCelebration, setShowCelebration] = useState(false);
            const [isPaused, setIsPaused] = useState(false);
            const isPausedRef = useRef(false);
            const [sidePanelCollapsed, setSidePanelCollapsed] = useState(true);
            const [celebrationName, setCelebrationName] = useState('');
            const [scoreDetailsPlayer, setScoreDetailsPlayer] = useState(null);
            const [showScoreDetails, setShowScoreDetails] = useState(false);
            const [flyingCard, setFlyingCard] = useState(null);
            const [draggedCardIndex, setDraggedCardIndex] = useState(null);
            const [dropTargetIndex, setDropTargetIndex] = useState(null);
            const [hoveredWinnerMeldIndex, setHoveredWinnerMeldIndex] = useState(null);
            const roundTransitionTimeoutRef = useRef(null);
            const hoveredWinnerMeldRef = React.useRef(null); // Use ref for synchronous updates
            const draggedCardRectRef = React.useRef(null); // Store position of card being dragged
            const nextFinalTurnActionRef = React.useRef(null); // Store callback for final turn continuation
            const timeoutRefs = React.useRef([]); // Store all timeout IDs for cleanup
            const intervalRefs = React.useRef([]); // Store all interval IDs for cleanup
            const isDiscardingRef = React.useRef(false); // Synchronous flag for discard guard
            const [flyingCardToWinner, setFlyingCardToWinner] = useState(null); // For animating card to winner meld
            const [showingAIMelds, setShowingAIMelds] = useState(false); // Pause to show AI player's final melds
            const [aiResultsToShow, setAiResultsToShow] = useState(null); // Store AI's results {player, melds, remaining, discard, points, playedOnCards}
            const [isDiscarding, setIsDiscarding] = useState(false);
            const [showingHumanFinalPlay, setShowingHumanFinalPlay] = useState(false); // Pause to show human player's final play
            const [humanFinalPlayResults, setHumanFinalPlayResults] = useState(null); // Store human's results {player, melds, remaining, discard, points, playedOnCards}
            const [allFinalPlaysComplete, setAllFinalPlaysComplete] = useState(false); // All players have finished their final plays
            const [draggedMeldCardIndex, setDraggedMeldCardIndex] = useState(null);
            const [dropTargetMeldIndex, setDropTargetMeldIndex] = useState(null);
            const [showDealingAnimation, setShowDealingAnimation] = useState(false);
            const [showDealerSelection, setShowDealerSelection] = useState(false);
            const [dealerSelectionStep, setDealerSelectionStep] = useState(0);
            const [dealerSelectionDeck, setDealerSelectionDeck] = useState([]);
            const [dealerSelectionDeckCount, setDealerSelectionDeckCount] = useState(1);
            const [pausedAfterPayMe, setPausedAfterPayMe] = useState(false);
            const [playersWhoHaveTakenFinalTurn, setPlayersWhoHaveTakenFinalTurn] = useState(new Set());
            const [showWildCardModal, setShowWildCardModal] = useState(false);
            const [wildCardToAssign, setWildCardToAssign] = useState(null);
            const [wildAssignmentCallback, setWildAssignmentCallback] = useState(null);
            const [winnerMeldWildPicker, setWinnerMeldWildPicker] = useState(null); // {card, meldIndex, cardIndex, options, suit}
            const [cardBeingDroppedOnWinner, setCardBeingDroppedOnWinner] = useState(null); // Index of card currently being dropped
            const [meldBuildingComplete, setMeldBuildingComplete] = useState(false);
            const [dealingInfo, setDealingInfo] = useState(null);
            
            // Meld picker state
            const [showMeldPicker, setShowMeldPicker] = useState(false);
            const [meldPickerOptions, setMeldPickerOptions] = useState([]);
            const [meldPickerStep, setMeldPickerStep] = useState(1); // For all-wilds multi-step
            const [meldPickerAllWilds, setMeldPickerAllWilds] = useState(false);
            const [meldPickerSelectedType, setMeldPickerSelectedType] = useState(null); // 'set' or 'run'
            const [meldPickerSelectedSuit, setMeldPickerSelectedSuit] = useState(null);
            const [pendingFinalizeAfterPick, setPendingFinalizeAfterPick] = useState(false);
            const [aiSpeed, setAiSpeed] = useState(3); // 0.5 = slow, 1 = normal, 2 = fast, 3 = max

            const startGame = ({ playerName, aiCount }) => {
                const totalPlayers = aiCount + 1;
                const deckCount = totalPlayers <= 2 ? 1 : totalPlayers <= 5 ? 2 : 3;
                
                let initialDeck = [];
                for (let i = 0; i < deckCount; i++) {
                    initialDeck = initialDeck.concat(createDeck());
                }
                // Remove jokers for dealer selection
                initialDeck = initialDeck.filter(card => card.rank !== 'JOKER');
                initialDeck = shuffle(initialDeck);
                
                const newPlayers = [
                    { id: 0, name: playerName, isAI: false, quarters: 13, hand: [], score: 0, melds: [], dealerCard: null, avatar: AI_CHARACTERS.find(c => c.name === playerName)?.avatar || "ðŸ‘¤", dialogue: "", roundHistory: [] }
                ];
                
                // Filter out the player's selected name from AI characters
                const availableCharacters = AI_CHARACTERS.filter(c => c.name !== playerName);
                const shuffledCharacters = shuffle([...availableCharacters]);
                for (let i = 0; i < aiCount; i++) {
                    const character = shuffledCharacters[i % availableCharacters.length];
                    newPlayers.push({
                        id: i + 1, name: character.name, avatar: character.avatar, character: character,
                        isAI: true, quarters: 13, hand: [], score: 0, melds: [], dealerCard: null,
                        dialogue: getDialogue(character, 'start'), roundHistory: []
                    });
                }

                // Start dealer selection animation
                setPlayers(newPlayers);
                setDealerSelectionDeck(initialDeck);
                setDealerSelectionDeckCount(deckCount);
                setShowDealerSelection(true);
                setDealerSelectionStep(0);
                setGameStarted(true);
                setMessage("Dealing cards to determine the dealer...");
                
                // Animate dealing dealer cards one by one
                const timeoutId = setTimeout(() => dealDealerCards(newPlayers, initialDeck), 500);
                timeoutRefs.current.push(timeoutId);
            };
            
            const dealDealerCards = (playersToUpdate, deckToUse) => {
                let currentStep = 0;
                const dealNextCard = () => {
                    if (currentStep < playersToUpdate.length) {
                        const card = deckToUse.pop();
                        setPlayers(prev => {
                            const updated = [...prev];
                            updated[currentStep] = { ...updated[currentStep], dealerCard: card };
                            return updated;
                        });
                        setDealerSelectionStep(currentStep + 1);
                        currentStep++;
                        const timeoutId = setTimeout(dealNextCard, 500);
                        timeoutRefs.current.push(timeoutId);
                    } else {
                        // All cards dealt, check in 1 second
                        const timeoutId = setTimeout(() => {
                            checkForDealerWinner(deckToUse);
                        }, 1000);
                        timeoutRefs.current.push(timeoutId);
                    }
                };
                dealNextCard();
            };
            
            const checkForDealerWinner = (currentDeck) => {
                setPlayers(currentPlayers => {
                    // Find which players have dealer cards (these are the tied players from previous round)
                    const playersWithCards = [];
                    currentPlayers.forEach((p, idx) => {
                        if (p.dealerCard) {
                            playersWithCards.push(idx);
                        }
                    });
                    
                    // Find highest card value(s) among ONLY the players with cards
                    let highestValue = -1;
                    const tiedPlayers = [];
                    
                    playersWithCards.forEach(idx => {
                        const p = currentPlayers[idx];
                        const cardValue = CARD_VALUES[p.dealerCard.rank] || 20;
                        if (cardValue > highestValue) {
                            highestValue = cardValue;
                            tiedPlayers.length = 0;
                            tiedPlayers.push(idx);
                        } else if (cardValue === highestValue) {
                            tiedPlayers.push(idx);
                        }
                    });
                    
                    if (tiedPlayers.length === 1) {
                        // We have a dealer!
                        const dealerIdx = tiedPlayers[0];
                        setDealerIndex(dealerIdx);
                        setMessage(`${currentPlayers[dealerIdx].name} draws ${currentPlayers[dealerIdx].dealerCard.rank}${currentPlayers[dealerIdx].dealerCard.suit} - highest card! They are the dealer!`);
                        
                        const timeoutId = setTimeout(() => {
                            setShowDealerSelection(false);
                            startRound(1, currentPlayers, dealerSelectionDeckCount, dealerIdx);
                        }, 1000);
                        timeoutRefs.current.push(timeoutId);
                    } else {
                        // Tie! Deal new cards to tied players only
                        setMessage(`Tie between ${tiedPlayers.map(idx => currentPlayers[idx].name).join(' and ')}! Dealing new cards...`);
                        
                        // First, clear ALL players' cards (not just tied ones) so only redealt cards are considered
                        const timeoutId1 = setTimeout(() => {
                            setPlayers(prev => {
                                const updated = prev.map(p => ({ ...p, dealerCard: null }));
                                return updated;
                            });
                            
                            // Then deal new cards to only tied players
                            const timeoutId2 = setTimeout(() => {
                                tiedPlayers.forEach((idx, i) => {
                                    const timeoutId3 = setTimeout(() => {
                                        const card = currentDeck.pop();
                                        setPlayers(prev => {
                                            const updated = [...prev];
                                            updated[idx] = { ...updated[idx], dealerCard: card };
                                            return updated;
                                        });
                                        
                                        // After last tied player gets card, check again
                                        if (i === tiedPlayers.length - 1) {
                                            const timeoutId4 = setTimeout(() => checkForDealerWinner(currentDeck), 1000);
                                            timeoutRefs.current.push(timeoutId4);
                                        }
                                    }, i * 500);
                                    timeoutRefs.current.push(timeoutId3);
                                });
                            }, 500); // Brief pause after clearing
                            timeoutRefs.current.push(timeoutId2);
                        }, 1500);
                        timeoutRefs.current.push(timeoutId1);
                    }
                    
                    return currentPlayers;
                });
            };

            const startRound = (roundNum, currentPlayers, deckCount, dealerIdx) => {
                setIsRoundTransitioning(false);

                const cardsPerPlayer = roundNum + 2;
                
                // Show dealing animation
                setShowDealingAnimation(true);
                setDealingInfo({
                    dealerName: currentPlayers[dealerIdx].name,
                    dealerAvatar: currentPlayers[dealerIdx].avatar,
                    cardsPerPlayer: cardsPerPlayer,
                    roundNum: roundNum
                });
                
                // Wait for animation, then deal cards
                const timeoutId = setTimeout(() => {
                    // Clear final play displays and state to prevent card flashing
                    setShowingAIMelds(false);
                    setAiResultsToShow(null);
                    setShowingHumanFinalPlay(false);
                    setHumanFinalPlayResults(null);
                    setAllFinalPlaysComplete(false);
                    setRoundWinner(null);
                    setPlayersWhoHaveTakenFinalTurn(new Set());
                    
                    let fullDeck = [];
                    for (let i = 0; i < deckCount; i++) {
                        fullDeck = fullDeck.concat(createDeck());
                    }
                    fullDeck = shuffle(fullDeck);
                    
                    const updatedPlayers = currentPlayers.map(player => {
                        const hand = fullDeck.splice(0, cardsPerPlayer);
                        return { 
                            ...player, 
                            hand, 
                            melds: [], 
                            dealerCard: null, 
                            playedOnCards: [],
                            dialogue: player.isAI ? getDialogue(player.character, 'start') : ""
                        };
                    });
                    
                    const firstDiscard = fullDeck.pop();
                    const startingPlayerIndex = (dealerIdx + 1) % updatedPlayers.length;
                    
                    
                    // Update ALL states that could show cards BEFORE dealing
                    setPlayers(updatedPlayers);
                    setDeck(fullDeck);
                    setDiscardPile([firstDiscard]);
                    setCurrentPlayerIndex(startingPlayerIndex);
                    setGamePhase('draw');
                    setWinnerMelds([]);
                    setBuildingPayMe(false);
                    setMeldBuildingComplete(false);
                    setPlayerMelds([]);
                    setCurrentMeld([]);
                    setMeldError('');
                    setShowDealingAnimation(false);
                    setMessage(`Round ${roundNum} - ${cardsPerPlayer} cards. ${updatedPlayers[dealerIdx].name} is dealer. Wild cards: ${getWildCardName(roundNum)} and Jokers`);
                }, 2000);
                timeoutRefs.current.push(timeoutId);
            };

            const getWildCardName = (roundNum) => {
                const cardNum = roundNum + 2;
                if (cardNum <= 10) return cardNum.toString();
                if (cardNum === 11) return 'Jacks';
                if (cardNum === 12) return 'Queens';
                return 'Kings';
            };

            const drawCard = (fromDiscard) => {
                if (gamePhase !== 'draw' && gamePhase !== 'finaldraw') return;
                
                let drawnCard;
                let newDeck = [...deck];
                let newDiscardPile = [...discardPile];
                
                if (fromDiscard && discardPile.length > 0) {
                    drawnCard = newDiscardPile.pop();
                } else {
                    if (newDeck.length === 0) {
                        // Reshuffle discard pile (except top card) into deck
                        if (newDiscardPile.length > 1) {
                            const topCard = newDiscardPile.pop();
                            newDeck = shuffle(newDiscardPile);
                            newDiscardPile = [topCard];
                            setMessage('Deck reshuffled from discard pile!');
                        } else if (newDiscardPile.length === 1) {
                            // Only one card in discard - must take it
                            drawnCard = newDiscardPile.pop();
                            const updatedPlayers = [...players];
                            updatedPlayers[currentPlayerIndex].hand.push(drawnCard);
                            if (updatedPlayers[currentPlayerIndex].isAI) {
                                updatedPlayers[currentPlayerIndex].dialogue = getDialogue(updatedPlayers[currentPlayerIndex].character, 'draw');
                            }
                            setDeck(newDeck);
                            setDiscardPile(newDiscardPile);
                            setPlayers(updatedPlayers);
                            if (gamePhase === 'finaldraw') {
                                setGamePhase('finallaydown');
                                setMessage('Lay down your melds and add cards to visible melds. Click "Done with Melds" when ready to discard.');
                            } else {
                                setGamePhase('discard');
                                setMessage('Click a card to discard, or declare "Pay Me" if you have all valid melds');
                            }
                            return;
                        } else {
                            // No cards available anywhere - shouldn't happen but handle gracefully
                            setMessage('No cards available to draw!');
                            return;
                        }
                    }
                    drawnCard = newDeck.pop();
                }
                
                const updatedPlayers = [...players];
                updatedPlayers[currentPlayerIndex].hand.push(drawnCard);
                
                if (updatedPlayers[currentPlayerIndex].isAI) {
                    updatedPlayers[currentPlayerIndex].dialogue = getDialogue(updatedPlayers[currentPlayerIndex].character, 'draw');
                }
                
                setDeck(newDeck);
                setDiscardPile(newDiscardPile);
                setPlayers(updatedPlayers);
                
                if (gamePhase === 'finaldraw') {
                    setGamePhase('finallaydown');
                    if (!updatedPlayers[currentPlayerIndex].isAI) {
                        setMessage('Lay down your melds and play cards on the winner\'s hand.');
                    }
                } else {
                    setGamePhase('discard');
                    if (!updatedPlayers[currentPlayerIndex].isAI) {
                        setMessage('Click a card to discard, or declare "Pay Me"');
                    }
                }
            };

            const animateCardDiscard = (cardElement, card, onComplete) => {
                if (!cardElement) {
                    onComplete();
                    return;
                }

                const cardRect = cardElement.getBoundingClientRect();
                const discardPile = document.querySelector('.discard-pile .card-stack');
                if (!discardPile) {
                    onComplete();
                    return;
                }
                const discardRect = discardPile.getBoundingClientRect();

                // Create flying card with flip animation
                setFlyingCard({
                    card: card,
                    startX: cardRect.left,
                    startY: cardRect.top,
                    endX: discardRect.left,
                    endY: discardRect.top,
                    width: cardRect.width,
                    height: cardRect.height
                });

                // Complete after animation
                const timeoutId = setTimeout(() => {
                    setFlyingCard(null);
                    onComplete();
                }, 600);
                timeoutRefs.current.push(timeoutId);
            };

            const handleDragStart = (e, index) => {
                setDraggedCardIndex(index);
                setDropTargetIndex(null);
                e.dataTransfer.effectAllowed = 'move';
                
                // Store the card element's position for potential animation
                const rect = e.currentTarget.getBoundingClientRect();
                draggedCardRectRef.current = {
                    x: rect.left,
                    y: rect.top,
                    width: rect.width,
                    height: rect.height
                };
            };

            // Touch event handlers for mobile drag and drop
            const handleTouchStart = (e, index) => {
                const touch = e.touches[0];
                setDraggedCardIndex(index);
                setDropTargetIndex(null);
                
                // Store the card element's position
                const rect = e.currentTarget.getBoundingClientRect();
                draggedCardRectRef.current = {
                    x: rect.left,
                    y: rect.top,
                    width: rect.width,
                    height: rect.height,
                    touchStartX: touch.clientX,
                    touchStartY: touch.clientY
                };
                
                // Add visual feedback
                e.currentTarget.style.opacity = '0.5';
            };

            const handleTouchMove = (e, index) => {
                if (draggedCardIndex === null) return;
                
                e.preventDefault(); // Prevent scrolling while dragging
                const touch = e.touches[0];
                
                // Check if we're over a winner's meld
                const elements = document.elementsFromPoint(touch.clientX, touch.clientY);
                const meldGroup = elements.find(el => el.classList && el.classList.contains('meld-group'));
                
                if (meldGroup && gamePhase === 'finallaydown' && !meldBuildingComplete) {
                    // Find which meld index this is
                    const allMeldGroups = document.querySelectorAll('.meld-group');
                    const meldIndex = Array.from(allMeldGroups).indexOf(meldGroup);
                    if (meldIndex !== -1) {
                        hoveredWinnerMeldRef.current = meldIndex;
                        setHoveredWinnerMeldIndex(meldIndex);
                        return; // Don't check for card reordering if over a meld
                    }
                }
                
                // Otherwise, check for card reordering
                const cardElement = elements.find(el => el.classList && el.classList.contains('card'));
                
                if (cardElement && cardElement !== e.currentTarget) {
                    // Find the index of the card we're over
                    const allCards = document.querySelectorAll('.hand-area .card');
                    const targetIndex = Array.from(allCards).indexOf(cardElement);
                    
                    if (targetIndex !== -1 && targetIndex !== draggedCardIndex) {
                        const rect = cardElement.getBoundingClientRect();
                        const midPoint = rect.left + rect.width / 2;
                        
                        if (touch.clientX < midPoint) {
                            setDropTargetIndex(targetIndex);
                        } else {
                            setDropTargetIndex(targetIndex + 1);
                        }
                    }
                }
            };

            const handleTouchEnd = (e, index) => {
                
                // Restore opacity
                e.currentTarget.style.opacity = '1';
                
                if (draggedCardIndex === null) {
                    setDropTargetIndex(null);
                    return;
                }
                
                const touch = e.changedTouches[0];
                
                // Check if we're dropping on a winner's meld
                const elements = document.elementsFromPoint(touch.clientX, touch.clientY);
                const winnerMeldCard = elements.find(el => el.classList && el.classList.contains('winner-hand-card'));
                
                if (winnerMeldCard && hoveredWinnerMeldRef.current !== null) {
                    // Dropping on winner's meld
                    const meldIndex = hoveredWinnerMeldRef.current;
                    handleDropOnWinnerMeld({preventDefault: () => {}, stopPropagation: () => {}}, meldIndex);
                    setDraggedCardIndex(null);
                    setDropTargetIndex(null);
                    hoveredWinnerMeldRef.current = null;
                    return;
                }
                
                // Otherwise, handle reordering
                let targetIndex = dropTargetIndex !== null ? dropTargetIndex : index;
                
                // If dropping in the same position, do nothing
                if (draggedCardIndex === targetIndex || draggedCardIndex === targetIndex - 1) {
                    setDraggedCardIndex(null);
                    setDropTargetIndex(null);
                    return;
                }
                
                // Reorder the hand
                const updatedPlayers = [...players];
                const newHand = [...updatedPlayers[0].hand];
                const draggedCard = newHand[draggedCardIndex];
                
                
                // Remove the dragged card
                newHand.splice(draggedCardIndex, 1);
                
                // Adjust target index if we removed a card before it
                if (draggedCardIndex < targetIndex) {
                    targetIndex--;
                }
                
                // Insert at the new position
                newHand.splice(targetIndex, 0, draggedCard);
                
                
                updatedPlayers[0].hand = newHand;
                setPlayers(updatedPlayers);
                
                // Clear drag state
                setDraggedCardIndex(null);
                setDropTargetIndex(null);
            };

            const handleDragOver = (e, index) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
                
                if (draggedCardIndex !== null && draggedCardIndex !== index) {
                    // Determine if we should insert before or after this card
                    const cardElement = e.currentTarget;
                    const rect = cardElement.getBoundingClientRect();
                    const midPoint = rect.left + rect.width / 2;
                    const mouseX = e.clientX;
                    
                    // If dragging to the left, insert before; if to the right, insert after
                    if (mouseX < midPoint) {
                        // Insert before this card
                        setDropTargetIndex(index);
                    } else {
                        // Insert after this card (before the next card)
                        setDropTargetIndex(index + 1);
                    }
                }
            };

            const handleDragLeave = () => {
                // Don't clear immediately - wait to see if entering another card
            };

            const handleDrop = (e, cardIndex) => {
                e.preventDefault();
                e.stopPropagation();
                
                if (draggedCardIndex === null) {
                    setDropTargetIndex(null);
                    return;
                }

                // Use dropTargetIndex (where the indicator is showing)
                let targetIndex = dropTargetIndex !== null ? dropTargetIndex : cardIndex;
                
                
                // If dropping in the same position, do nothing
                if (draggedCardIndex === targetIndex || draggedCardIndex === targetIndex - 1) {
                    setDraggedCardIndex(null);
                    setDropTargetIndex(null);
                    return;
                }
                
                // Reorder the hand
                const updatedPlayers = [...players];
                const newHand = [...updatedPlayers[0].hand];
                const draggedCard = newHand[draggedCardIndex];
                
                
                // Remove the dragged card
                newHand.splice(draggedCardIndex, 1);
                
                // Adjust target index if we removed a card before it
                if (draggedCardIndex < targetIndex) {
                    targetIndex--;
                }
                
                // Insert at the new position
                newHand.splice(targetIndex, 0, draggedCard);
                
                
                updatedPlayers[0].hand = newHand;
                setPlayers(updatedPlayers);
                
                // Clear drag state
                setDraggedCardIndex(null);
                setDropTargetIndex(null);
            };

            const handleDragEnd = (e) => {
                
                // If dragging over a winner's meld, try to add the card
                if (hoveredWinnerMeldRef.current !== null && draggedCardIndex !== null) {
                    const meldIndex = hoveredWinnerMeldRef.current;
                    
                    // Immediately hide the card from hand to prevent visual glitch
                    setCardBeingDroppedOnWinner(draggedCardIndex);
                    
                    // Immediately process the drop
                    handleDropOnWinnerMeld({preventDefault: () => {}, stopPropagation: () => {}}, meldIndex);
                    
                    // Clear the cardBeingDropped state after a short delay
                    setTimeout(() => {
                        setCardBeingDroppedOnWinner(null);
                    }, 100);
                    
                    hoveredWinnerMeldRef.current = null;
                    setHoveredWinnerMeldIndex(null);
                    setDraggedCardIndex(null);
                    draggedCardRectRef.current = null;
                    return;
                }
                
                // Clean up drag state
                setDraggedCardIndex(null);
                setDropTargetIndex(null);
                draggedCardRectRef.current = null;
            };

            // Handlers for dragging within current meld
            const handleMeldDragStart = (e, index) => {
                setDraggedMeldCardIndex(index);
                e.dataTransfer.effectAllowed = 'move';
            };

            const handleMeldTouchStart = (e, index) => {
                setDraggedMeldCardIndex(index);
                e.currentTarget.style.opacity = '0.5';
            };

            const handleMeldTouchMove = (e, index) => {
                if (draggedMeldCardIndex === null) return;
                e.preventDefault();
                
                const touch = e.touches[0];
                const elements = document.elementsFromPoint(touch.clientX, touch.clientY);
                const cardElement = elements.find(el => el.classList && el.classList.contains('card'));
                
                if (cardElement && cardElement !== e.currentTarget) {
                    const allMeldCards = document.querySelectorAll('.current-meld-preview .card');
                    const targetIndex = Array.from(allMeldCards).indexOf(cardElement);
                    
                    if (targetIndex !== -1 && targetIndex !== draggedMeldCardIndex) {
                        const rect = cardElement.getBoundingClientRect();
                        const midPoint = rect.left + rect.width / 2;
                        
                        if (touch.clientX < midPoint) {
                            setDropTargetMeldIndex(targetIndex);
                        } else {
                            setDropTargetMeldIndex(targetIndex + 1);
                        }
                    }
                }
            };

            const handleMeldTouchEnd = (e, cardIndex) => {
                e.currentTarget.style.opacity = '1';
                
                if (draggedMeldCardIndex === null) {
                    setDropTargetMeldIndex(null);
                    return;
                }

                let insertIndex = dropTargetMeldIndex !== null ? dropTargetMeldIndex : cardIndex;
                
                if (draggedMeldCardIndex < insertIndex) {
                    insertIndex--;
                }
                
                if (draggedMeldCardIndex === insertIndex) {
                    setDraggedMeldCardIndex(null);
                    setDropTargetMeldIndex(null);
                    return;
                }

                // Reorder the current meld
                const newMeld = [...currentMeld];
                const [draggedCard] = newMeld.splice(draggedMeldCardIndex, 1);
                newMeld.splice(insertIndex, 0, draggedCard);
                
                setCurrentMeld(newMeld);
                setDraggedMeldCardIndex(null);
                setDropTargetMeldIndex(null);
                setMessage(`Moved ${draggedCard.rank}${draggedCard.suit} from position ${draggedMeldCardIndex + 1} to ${insertIndex + 1}`);
            };

            const handleMeldDragOver = (e, index) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
                
                if (draggedMeldCardIndex === null || draggedMeldCardIndex === index) {
                    return;
                }
                
                const cardElement = e.currentTarget;
                const rect = cardElement.getBoundingClientRect();
                const mouseX = e.clientX;
                const midPoint = rect.left + rect.width / 2;
                
                if (mouseX < midPoint) {
                    setDropTargetMeldIndex(index);
                } else {
                    setDropTargetMeldIndex(index + 1);
                }
            };

            const handleMeldDrop = (e, cardIndex) => {
                e.preventDefault();
                
                if (draggedMeldCardIndex === null) {
                    setDropTargetMeldIndex(null);
                    return;
                }

                let insertIndex = dropTargetMeldIndex !== null ? dropTargetMeldIndex : cardIndex;
                
                if (draggedMeldCardIndex < insertIndex) {
                    insertIndex--;
                }
                
                if (draggedMeldCardIndex === insertIndex) {
                    setDraggedMeldCardIndex(null);
                    setDropTargetMeldIndex(null);
                    return;
                }

                // Reorder the current meld
                const newMeld = [...currentMeld];
                const [draggedCard] = newMeld.splice(draggedMeldCardIndex, 1);
                newMeld.splice(insertIndex, 0, draggedCard);
                
                setCurrentMeld(newMeld);
                setDraggedMeldCardIndex(null);
                setDropTargetMeldIndex(null);
                setMessage(`Moved ${draggedCard.rank}${draggedCard.suit} from position ${draggedMeldCardIndex + 1} to ${insertIndex + 1}`);
            };

            const handleMeldDragEnd = () => {
                setDraggedMeldCardIndex(null);
                setDropTargetMeldIndex(null);
            };

            // Handle dragging card to winner's meld (to add to run or set)
            const handleDropOnWinnerMeld = (e, meldIndex, playerIndexOverride = 0, cardIndexOverride = null, removeFromHand = false) => {
                // Don't use e.preventDefault/stopPropagation when called from handleDragEnd with mock event
                if (e.preventDefault) e.preventDefault();
                if (e.stopPropagation) e.stopPropagation();
                
                // Get card index but DON'T clear drag state yet
                const cardIndex = (cardIndexOverride !== null && cardIndexOverride !== undefined) ? cardIndexOverride : draggedCardIndex;
                const playerIndex = playerIndexOverride;
                
                
                if (cardIndex === null) {
                    return;
                }
                
                if (roundWinner === null) {
                    return;
                }
                if (gamePhase !== 'finallaydown' || meldBuildingComplete) {
                    return;
                }
                
                const card = players[playerIndex].hand[cardIndex];
                const meld = players[roundWinner].melds[meldIndex];
                
                
                // Check if a wild already represents this card (only matters for runs, not sets)
                // For sets, you can have the real card and a wild representing it
                // For runs, duplicate ranks aren't allowed
                if (!isWild(card, round)) {
                    const cardRankSuit = `${card.rank}${card.suit}`;
                    const wildRepresentsThisCard = meld.some(c => 
                        c.representsCard === cardRankSuit
                    );
                    
                    // Only block if this is a run (check by looking at meld structure)
                    if (wildRepresentsThisCard) {
                        // Determine if this is likely a run (same suit) or set (same rank)
                        const nonWilds = meld.filter(c => !isWild(c, round));
                        const isLikelyRun = nonWilds.length > 0 && nonWilds.every(c => c.suit === card.suit);
                        
                        if (isLikelyRun) {
                            setMessage(`Can't add ${card.rank}${card.suit} - a wild card already represents it!`);
                            setDraggedCardIndex(null);
                            setDropTargetIndex(null);
                            return;
                        }
                    }
                }
                
                // Check if this meld is a set or run
                // IMPORTANT: Check SET first because with wilds, isValidRun might also return true
                // CRITICAL: Always recalculate isWildForRound to ensure accurate detection
                // CRITICAL: Preserve representsCard for existing wild cards so we detect the correct meld type
                const meldWithWilds = meld.map(c => ({ 
                    ...c, 
                    isWildForRound: isWild(c, round),
                    ...(c.representsCard && { representsCard: c.representsCard })
                }));
                const hasLockedRepresentations = meldWithWilds.some(c => c && c.representsCard);
                let meldIsSet = false;
                let meldIsRun = false;
                if (hasLockedRepresentations) {
                    // If wilds are already assigned (representsCard), prefer validating as a RUN using those assignments.
                    meldIsRun = isValidRun(meldWithWilds, round);
                    meldIsSet = !meldIsRun && isValidSet(meldWithWilds, round);
                } else {
                    // Otherwise keep legacy behavior (sets take precedence when ambiguous).
                    meldIsSet = isValidSet(meldWithWilds, round);
                    meldIsRun = !meldIsSet && isValidRun(meldWithWilds, round);
                }
                
                
                if (!meldIsSet && !meldIsRun) {
                    setMessage(`Can't add to this meld - it's invalid`);
                    setDraggedCardIndex(null);
                    setDropTargetIndex(null);
                    return;
                }
                
                
                // Test if adding this card makes a valid meld
                // IMPORTANT: Only validate against the meld's actual type
                // CRITICAL FIX: Always recalculate isWildForRound for accurate validation
                // CRITICAL FIX 2: Preserve representsCard for existing wild cards
                const testMeld = [
                    ...meld.map(c => ({ 
                        ...c, 
                        isWildForRound: isWild(c, round),
                        // Preserve representsCard if it exists (for wilds already in the meld)
                        ...(c.representsCard && { representsCard: c.representsCard })
                    })),
                    { ...card, isWildForRound: isWild(card, round) }
                ];
                
                let validAfterAdd = false;
                if (meldIsSet) {
                    validAfterAdd = isValidSet(testMeld, round);
                } else if (meldIsRun) {
                                    // Extra strict rule: can only extend runs on an end (and must match suit if non-wild)
                                    if (!canExtendRunOnEnd(meldWithWilds, card, round)) {
                                        setMessage(`Can only extend runs on the ends`);
                                        setDraggedCardIndex(null);
                                        setDropTargetIndex(null);
                                        return;
                                    }
                                    validAfterAdd = isValidRun(testMeld, round);
                }
                
                if (!validAfterAdd) {
                    const meldType = meldIsSet ? 'set' : 'run';
                    setMessage(`Can't add ${card.rank}${card.suit} to this ${meldType} - it would be invalid`);
                    setDraggedCardIndex(null);
                    setDropTargetIndex(null);
                    return;
                }
                
                // Add the card!
                const updatedPlayers = [...players];
                const updatedMeld = [
                    ...meld,
                    { ...card, isWildForRound: isWild(card, round), addedBy: updatedPlayers[playerIndex].avatar }
                ];
                
                // Handle wild assignment
                let finalMeld;
                if (meldIsRun && isWild(card, round)) {
                    // For runs with wilds, determine possible placements
                    const rankOrder = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
                    
                    // Get the suit of the run
                    const nonWildCards = meld.filter(c => !isWild(c, round) && !c.representsCard);
                    const suit = nonWildCards.length > 0 ? nonWildCards[0].suit : 
                                 (meld.find(c => c.representsCard) ? meld.find(c => c.representsCard).representsCard.slice(-1) : 'â™ ');
                    
                    // Get all ranks currently in the meld
                    const currentRanks = meld.map(c => {
                        if (c.representsCard) {
                            return c.representsCard.slice(0, -1); // Remove suit
                        }
                        return c.rank;
                    });
                    const currentIndices = currentRanks.map(r => rankOrder.indexOf(r)).sort((a, b) => a - b);
                    
                    // Check for Ace-high run
                    const hasAce = currentIndices.includes(0);
                    const hasHighCards = currentIndices.some(idx => idx >= 10);
                    let adjustedIndices = [...currentIndices];
                    if (hasAce && hasHighCards) {
                        const minNonAce = Math.min(...currentIndices.filter(i => i !== 0));
                        if (minNonAce >= 9) {
                            adjustedIndices = currentIndices.map(i => i === 0 ? 13 : i);
                        }
                    }
                    
                    const min = Math.min(...adjustedIndices);
                    const max = Math.max(...adjustedIndices);
                    
                    // Possible placements: one below min or one above max
                    const options = [];
                    if (min > 0) {
                        const belowRank = min === 13 ? 'K' : rankOrder[min - 1];
                        options.push({ rank: belowRank, display: `${belowRank}${suit}` });
                    }
                    if (max < 12) {
                        const aboveRank = rankOrder[max + 1];
                        options.push({ rank: aboveRank, display: `${aboveRank}${suit}` });
                    } else if (max === 12 && !adjustedIndices.includes(13) && !adjustedIndices.includes(0)) {
                        // Can add Ace-high after King
                        options.push({ rank: 'A', display: `A${suit}` });
                    }
                    
                    if (options.length === 1) {
                        // Only one option - assign automatically
                        const chosenRank = options[0].rank;
                        finalMeld = [...updatedMeld];
                        finalMeld[finalMeld.length - 1] = { 
                            ...finalMeld[finalMeld.length - 1], 
                            representsCard: `${chosenRank}${suit}` 
                        };
                    } else if (options.length > 1) {
                        // Multiple options - show picker UI
                        setWinnerMeldWildPicker({
                            card: card,
                            meldIndex: meldIndex,
                            cardIndex: cardIndex,
                            playerIndex: playerIndex,
                            options: options.map(o => ({ rank: o.rank, suit: suit, display: o.display })),
                            updatedMeld: updatedMeld,
                            updatedPlayers: updatedPlayers
                        });
                        // Clear drag state when picker is shown
                        setDraggedCardIndex(null);
                        setDropTargetIndex(null);
                        return; // Wait for user selection
                    } else {
                        // No valid options (shouldn't happen if isValidRun passed)
                        setDraggedCardIndex(null);
                        setDropTargetIndex(null);
                        setMessage('Cannot place wild card in this run.');
                        return;
                    }
                } else if (meldIsSet) {
                    // For sets, assign what wilds represent (the set's rank)
                    const nonWilds = updatedMeld.filter(c => !isWild(c, round));
                    const setRank = nonWilds.length > 0 ? nonWilds[0].rank : null;
                    
                    finalMeld = updatedMeld.map(c => {
                        if (isWild(c, round) && setRank) {
                            // Assign the wild to represent the set's rank with the card's original suit
                            // PRESERVE all properties including addedBy
                            return { ...c, representsCard: `${setRank}${c.suit}` };
                        }
                        return {...c}; // Preserve all properties
                    });
                } else {
                    // Non-wild addition to existing meld
                    finalMeld = updatedMeld;
                }
                
                // Sort the meld so it's in order
                const sortedMeld = sortMeld(finalMeld, round);
                updatedPlayers[roundWinner].melds[meldIndex] = sortedMeld;
                
                
                // Track that this card was played off
                if (!updatedPlayers[playerIndex].playedOnCards) {
                    updatedPlayers[playerIndex].playedOnCards = [];
                }
                updatedPlayers[playerIndex].playedOnCards.push({
                    ...card, 
                    playedOn: `${players[roundWinner].name}'s meld ${meldIndex + 1}`,
                    addedBy: updatedPlayers[playerIndex].avatar
                });
                
                // DON'T remove from hand yet during meld building - just track it
                
                // If this was an AI (or programmatic) layoff, remove the card immediately
                if (removeFromHand) {
                    updatedPlayers[playerIndex].hand = updatedPlayers[playerIndex].hand.filter((_, i) => i !== cardIndex);
                }
                // The card will be removed when user clicks "Finalize"
                
                setPlayers(updatedPlayers);
                setMessage(`Added ${card.rank}${card.suit} to ${players[roundWinner].name}'s meld!`);
                
                // Clear drag state AFTER successful addition
                setDraggedCardIndex(null);
                setDropTargetIndex(null);
            };

            // Handle dragging card from saved meld back to hand
            const handleDragFromSavedMeld = (e, meldIndex, cardIndex) => {
                e.dataTransfer.setData('meldIndex', meldIndex);
                e.dataTransfer.setData('cardIndex', cardIndex);
                e.dataTransfer.effectAllowed = 'move';
            };

            const handleDropBackToHand = (e) => {
                e.preventDefault();
                
                // Check if dropping from winner's meld (card you added)
                const winnerMeldIndex = e.dataTransfer.getData('winnerMeldIndex');
                const winnerMeldCardIndex = e.dataTransfer.getData('winnerMeldCardIndex');
                
                if (winnerMeldIndex !== '' && winnerMeldCardIndex !== '') {
                    const meldIdx = parseInt(winnerMeldIndex);
                    const cardIdx = parseInt(winnerMeldCardIndex);
                    
                    
                    const updatedPlayers = [...players];
                    const winnerMeld = updatedPlayers[roundWinner].melds[meldIdx];
                    const card = winnerMeld[cardIdx];
                    
                    // Only allow removal if this card was added by the human player
                    if (!card.addedBy) {
                        setMessage("You can only remove cards that you added!");
                        return;
                    }
                    
                    // Remove from winner's meld
                    const updatedMeld = winnerMeld.filter((_, idx) => idx !== cardIdx);
                    updatedPlayers[roundWinner].melds[meldIdx] = updatedMeld;
                    
                    // Clean the card before adding back to hand (remove addedBy, playedOn, etc)
                    const cleanCard = {
                        rank: card.rank,
                        suit: card.suit,
                        id: card.id,
                        isRed: card.isRed,
                        isWildForRound: card.isWildForRound
                    };
                    // Add representsCard if it exists and card is wild
                    if (card.representsCard && card.isWildForRound) {
                        cleanCard.representsCard = card.representsCard;
                    }
                    
                    // Add back to hand
                    if (!updatedPlayers[0].hand.some(c => c.id === cleanCard.id)) {
                        updatedPlayers[0].hand.push(cleanCard);
                    }
                    
                    // Remove from playedOnCards tracking
                    if (updatedPlayers[0].playedOnCards) {
                        updatedPlayers[0].playedOnCards = updatedPlayers[0].playedOnCards.filter(c => c.id !== card.id);
                    }
                    
                    setPlayers(updatedPlayers);
                    setMessage(`Removed ${card.rank}${card.suit} from ${players[roundWinner].name}'s meld`);
                    return;
                }
                
                // Check if dropping from current meld
                if (draggedMeldCardIndex !== null) {
                    // Remove card from current meld (it's being dropped back to hand, so just remove it)
                    const newMeld = currentMeld.filter((_, idx) => idx !== draggedMeldCardIndex);
                    setCurrentMeld(newMeld);
                    setDraggedMeldCardIndex(null);
                    setDropTargetMeldIndex(null);
                    setMessage('Card removed from current meld');
                    return;
                }
                
                // Otherwise, check if dropping from saved meld
                const meldIndex = e.dataTransfer.getData('meldIndex');
                const cardIndex = e.dataTransfer.getData('cardIndex');
                
                if (meldIndex === '' || cardIndex === '') return;
                
                const meldIdx = parseInt(meldIndex);
                const cardIdx = parseInt(cardIndex);
                
                // Get the card from the meld
                const meld = playerMelds[meldIdx];
                const card = meld[cardIdx];
                
                // Add back to hand
                const updatedPlayers = [...players];
                if (!updatedPlayers[0].hand.some(c => c.id === card.id)) {
                    updatedPlayers[0].hand.push(card);
                }
                
                // Remove from meld
                const updatedMelds = [...playerMelds];
                updatedMelds[meldIdx] = meld.filter((_, idx) => idx !== cardIdx);
                
                // If meld is now empty or too small, remove it
                if (updatedMelds[meldIdx].length < 3) {
                    // Add all cards back to hand
                    updatedMelds[meldIdx].forEach(c => {
                        if (!updatedPlayers[0].hand.some(h => h.id === c.id)) {
                            updatedPlayers[0].hand.push(c);
                        }
                    });
                    updatedMelds.splice(meldIdx, 1);
                }
                
                setPlayers(updatedPlayers);
                setPlayerMelds(updatedMelds);
                setMessage('Card returned to hand');
                
                // Clear drag state
                setDraggedCardIndex(null);
            };

            // Central scoreboard helper functions to ensure consistent behavior
            const openScoreboard = () => {
                // Open the scoreboard modal: clear final play displays and show the complete round results
                setShowingHumanFinalPlay(false);
                setHumanFinalPlayResults(null);
                setShowingAIMelds(false);
                setAiResultsToShow(null);
                setAllFinalPlaysComplete(true);
                nextFinalTurnActionRef.current = null;
            };

            const closeScoreboard = () => {
                // Close scoreboard and prepare for next round
                setAllFinalPlaysComplete(false);
                setPlayersWhoHaveTakenFinalTurn(new Set());
                setRoundWinner(null);
            };

            // Validation function to enforce discard requirement at end-of-turn
            // This prevents players from skipping their discard (defensive validation)
            const validatePlayerCanEndTurn = (player, currentHand) => {
                // A player must have discarded exactly once per turn
                // At finalization time, they should have at least 1 card to discard
                if (!currentHand || currentHand.length === 0) {
                    alert('Error: You must have at least one card to discard before ending your turn.');
                    return false;
                }
                return true;
            };

            const discardCard = (cardIndex) => {
                // Synchronous check with ref to prevent race conditions
                if (isDiscardingRef.current) {
                    return;
                }
                if (gamePhase !== 'discard' && gamePhase !== 'finaldiscard') {
                    return;
                }
                
                // Set both flag and ref to prevent double discard
                isDiscardingRef.current = true;
                setIsDiscarding(true);
                
                // Immediately set phase to prevent double discard
                const wasFinaldiscard = gamePhase === 'finaldiscard';
                setGamePhase(wasFinaldiscard ? 'finaldiscard_processing' : 'discard_processing');
                
                const updatedPlayers = [...players];
                const currentPlayer = updatedPlayers[currentPlayerIndex];
                const discardedCard = currentPlayer.hand.splice(cardIndex, 1)[0];
                
                const newDiscardPile = [...discardPile, discardedCard];
                
                // Set discard message for both AI and human
                const discardMessage = currentPlayer.isAI 
                    ? `${currentPlayer.name} discarded ${discardedCard.rank}${discardedCard.suit}` 
                    : `You discarded ${discardedCard.rank}${discardedCard.suit}`;
                setMessage(discardMessage);
                
                if (currentPlayer.isAI) {
                    currentPlayer.dialogue = getDialogue(currentPlayer.character, 'discard');
                }
                
                setPlayers(updatedPlayers);
                setDiscardPile(newDiscardPile);
                setSelectedCard(null);
                
                if (wasFinaldiscard) {
                    // Mark this player as having completed their final turn
                    setPlayersWhoHaveTakenFinalTurn(prev => new Set([...prev, currentPlayerIndex]));
                    
                    // If this is an AI player, show their results before continuing
                    if (currentPlayer.isAI) {
                        const points = calculateScore(currentPlayer.hand);
                        setAiResultsToShow({
                            player: currentPlayer,
                            melds: currentPlayer.melds,
                            remaining: [...currentPlayer.hand], // Cards left after discard
                            discard: discardedCard,
                            points: points,
                            playedOnCards: currentPlayer.playedOnCards || []
                        });
                        setShowingAIMelds(true);
                        setMeldError(''); // Clear any previous meld errors
                        setIsDiscarding(false);
                        isDiscardingRef.current = false;
                        
                        // Check if this is the last player
                        const nextIndex = (currentPlayerIndex + 1) % players.length;
                        if (nextIndex === roundWinner) {
                            // Last player - set up action to show final review screen AFTER continue
                            nextFinalTurnActionRef.current = () => {
                                setShowingAIMelds(false);
                                setAiResultsToShow(null);
                                setHumanFinalPlayResults(null);
                                setAllFinalPlaysComplete(true);
                                // allFinalPlaysComplete set to true to show review screen
                            };
                        } else {
                            const isNextHuman = !players[nextIndex].isAI;
                            nextFinalTurnActionRef.current = () => {
                                setCurrentPlayerIndex(nextIndex);
                                setGamePhase('finaldraw');
                                if (isNextHuman) {
                                    setMessage('Your final turn - draw a card');
                                } else {
                                    setMessage(`${players[nextIndex].name}'s final turn...`);
                                }
                            };
                        }
                        return;
                    }
                    
                    // Human player - continue as normal
                    const nextIndex = (currentPlayerIndex + 1) % players.length;
                    
                    // Check if this is the last player
                    if (nextIndex === roundWinner) {
                        // Last player - show their results, then allow continue to final tally
                        const points = calculateScore(currentPlayer.hand);
                        setHumanFinalPlayResults({
                            player: currentPlayer,
                            melds: currentPlayer.melds,
                            remaining: [...currentPlayer.hand], // Cards left after discard
                            discard: discardedCard,
                            points: points,
                            playedOnCards: currentPlayer.playedOnCards || []
                        });
                        setShowingHumanFinalPlay(true);
                        setIsDiscarding(false);
                        isDiscardingRef.current = false;
                        
                        // Set up the continue action to go to final tally
                        nextFinalTurnActionRef.current = () => {
                            setShowingHumanFinalPlay(false);
                            setHumanFinalPlayResults(null);
                            setAllFinalPlaysComplete(true);
                        };
                    } else {
                        // Human is not the last player - show their final play panel and keep it sticky
                        const points = calculateScore(currentPlayer.hand);
                        setHumanFinalPlayResults({
                            player: currentPlayer,
                            melds: currentPlayer.melds,
                            remaining: [...currentPlayer.hand], // Cards left after discard
                            discard: discardedCard,
                            points: points,
                            playedOnCards: currentPlayer.playedOnCards || []
                        });
                        // Keep showingHumanFinalPlay false so the sticky panel is shown
                        setShowingHumanFinalPlay(false);
                        
                        // Move to next player immediately
                        const isNextHuman = !players[nextIndex].isAI;
                        const timeoutId = setTimeout(() => {
                            // Don't hide humanFinalPlayResults - keep it visible through AI plays as sticky panel
                            setCurrentPlayerIndex(nextIndex);
                            setGamePhase('finaldraw');
                            setIsDiscarding(false);
                            isDiscardingRef.current = false;
                            if (isNextHuman) {
                                setMessage('Your final turn - draw a card');
                            } else {
                                setMessage(`${players[nextIndex].name}'s final turn...`);
                            }
                        }, 1000);
                        timeoutRefs.current.push(timeoutId);
                    }
                    return;
                }
                
                // For AI players, delay nextTurn so discard message is visible
                if (currentPlayer.isAI) {
                    const timeoutId = setTimeout(() => {
                        nextTurn();
                        setIsDiscarding(false);
                        isDiscardingRef.current = false;
                    }, 1200 / aiSpeed);
                    timeoutRefs.current.push(timeoutId);
                } else {
                    nextTurn();
                    setIsDiscarding(false);
                    isDiscardingRef.current = false;
                }
            };
            
            const startPayMeDeclaration = () => {
                setBuildingPayMe(true);
                setPlayerMelds([]);
                setCurrentMeld([]);
                setMeldError('');
                setGamePhase('paymebuilding'); // Change phase to prevent accidental discards
                const requiredCards = round + 2;
                setMessage(`Build your melds. You must use exactly ${requiredCards} cards in valid melds. The remaining card will be automatically discarded.`);
            };

            const cancelPayMeDeclaration = () => {
                setBuildingPayMe(false);
                setPlayerMelds([]);
                setCurrentMeld([]);
                setMeldError('');
                setGamePhase('discard');
                setMessage('Click a card to discard');
            };

            const assignWildCard = (meldCardIndex) => {
                const card = currentMeld[meldCardIndex];
                if (!isWild(card, round)) return;
                
                // Set which wild card we're assigning - this will show the picker UI
                setWildCardToAssign(meldCardIndex);
            };
            
            const getPossibleWildValues = () => {
                // Calculate what values the wild card could represent based on current meld
                if (wildCardToAssign === null || currentMeld.length < 2) return [];
                
                const nonWilds = currentMeld.filter(c => !isWild(c, round));
                if (nonWilds.length === 0) return [];
                
                const rankOrder = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
                const possibleValues = [];
                
                // Check if this could be a set (same rank, different suits)
                const firstNonWildRank = nonWilds[0].rank;
                const isLikelySet = nonWilds.every(c => c.rank === firstNonWildRank);
                
                // Check if this could be a run (consecutive ranks, same suit)
                const firstNonWildSuit = nonWilds[0].suit;
                const isLikelySameSuit = nonWilds.every(c => c.suit === firstNonWildSuit);
                
                if (isLikelySet && nonWilds.length >= 1) {
                    // For a set, wild can be any suit of the same rank that's not already used
                    const usedSuits = new Set(nonWilds.map(c => c.suit));
                    // Also check already-assigned wilds
                    currentMeld.forEach(c => {
                        if (isWild(c, round) && c.representsCard) {
                            const match = c.representsCard.match(/([â™¥â™¦â™£â™ ])$/);
                            if (match) usedSuits.add(match[1]);
                        }
                    });
                    
                    SUITS.forEach(suit => {
                        if (!usedSuits.has(suit)) {
                            possibleValues.push({ rank: firstNonWildRank, suit, display: `${firstNonWildRank}${suit}` });
                        }
                    });
                }
                
                if (isLikelySameSuit && nonWilds.length >= 1) {
                    // For a run, wild can be adjacent ranks in the same suit
                    const suit = firstNonWildSuit;
                    const nonWildRanks = nonWilds.map(c => rankOrder.indexOf(c.rank)).sort((a, b) => a - b);
                    
                    // Get already assigned wild positions
                    const assignedRanks = new Set(nonWildRanks);
                    currentMeld.forEach(c => {
                        if (isWild(c, round) && c.representsCard) {
                            const match = c.representsCard.match(/^(A|[2-9]|10|J|Q|K)/);
                            if (match) {
                                assignedRanks.add(rankOrder.indexOf(match[1]));
                            }
                        }
                    });
                    
                    const minRank = Math.min(...assignedRanks);
                    const maxRank = Math.max(...assignedRanks);
                    
                    // Add gaps between existing cards
                    for (let r = minRank; r <= maxRank; r++) {
                        if (!assignedRanks.has(r)) {
                            possibleValues.push({ rank: rankOrder[r], suit, display: `${rankOrder[r]}${suit}` });
                        }
                    }
                    
                    // Add positions before and after the run
                    if (minRank > 0) {
                        possibleValues.push({ rank: rankOrder[minRank - 1], suit, display: `${rankOrder[minRank - 1]}${suit}` });
                    }
                    if (maxRank < 12) {
                        possibleValues.push({ rank: rankOrder[maxRank + 1], suit, display: `${rankOrder[maxRank + 1]}${suit}` });
                    }
                    // Handle Ace high (after King)
                    if (maxRank === 12 && !assignedRanks.has(0)) {
                        possibleValues.push({ rank: 'A', suit, display: `A${suit}`, isAceHigh: true });
                    }
                }
                
                // Remove duplicates
                const seen = new Set();
                return possibleValues.filter(v => {
                    const key = v.display;
                    if (seen.has(key)) return false;
                    seen.add(key);
                    return true;
                });
            };
            
            const selectWildValue = (rank, suit) => {
                if (wildCardToAssign === null) return;
                
                const card = currentMeld[wildCardToAssign];
                const representsCard = `${rank}${suit}`;
                
                // Update the card in current meld
                const updated = [...currentMeld];
                updated[wildCardToAssign] = { ...card, representsCard };
                setCurrentMeld(updated);
                setWildCardToAssign(null);
                setMessage(`${card.rank}${card.suit} now represents ${representsCard}`);
                
                // Store callback to use after checking for more wilds
                const callback = wildAssignmentCallback;
                
                // Check if there are more unassigned wilds that now have only one valid position
                const timeoutId = setTimeout(() => {
                    const markedCards = updated.map(c => ({...c, isWildForRound: isWild(c, round)}));
                    
                    // First check: are there any wilds left without assignments?
                    const unassignedWilds = markedCards.filter(c => c.isWildForRound && !c.representsCard);
                    
                    // If no unassigned wilds remain, we're done - call completion callback
                    if (unassignedWilds.length === 0) {
                        setWildAssignmentCallback(null);
                        if (callback) {
                            callback();
                        }
                        return;
                    }
                    
                    // There are still unassigned wilds - check if they need manual assignment
                    if (isValidRun(updated, round)) {
                        const nonWilds = markedCards.filter(c => !c.isWildForRound || c.representsCard);
                        if (nonWilds.length > 0) {
                            const rankOrder = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
                            let nonWildRanks = nonWilds.map(c => {
                                if (c.representsCard) {
                                    // Extract rank from representsCard
                                    const repRank = c.representsCard.slice(0, -1);
                                    return rankOrder.indexOf(repRank);
                                }
                                return rankOrder.indexOf(c.rank);
                            }).sort((a, b) => a - b);
                            
                            const hasAce = nonWildRanks.includes(0);
                            const hasHighCards = nonWildRanks.some(r => r >= 10);
                            const canExtendLow = nonWildRanks[0] > 0;
                            const canExtendHigh = nonWildRanks[nonWildRanks.length - 1] < 12;
                            const canExtendHighWithAce = hasHighCards && nonWildRanks[nonWildRanks.length - 1] === 12;
                            
                            let validPositions = 0;
                            if (canExtendLow) validPositions++;
                            if (canExtendHigh) validPositions++;
                            if (canExtendHighWithAce) validPositions++;
                            
                            // If multiple valid positions OR ambiguous ace situation, require manual assignment
                            if (validPositions > 1 || (hasAce && hasHighCards && unassignedWilds.length > 0)) {
                                const firstUnassignedIdx = updated.findIndex(c => isWild(c, round) && !c.representsCard);
                                if (firstUnassignedIdx >= 0) {
                                    setWildCardToAssign(firstUnassignedIdx);
                                }
                                return; // Still need more assignments
                            }
                        }
                    }
                    
                    // All remaining wilds can be auto-assigned or no more wilds - call the completion callback
                    setWildAssignmentCallback(null);
                    if (callback) {
                        callback();
                    }
                }, 100);
                timeoutRefs.current.push(timeoutId);
            };
            
            const cancelWildAssignment = () => {
                setWildCardToAssign(null);
            };
            
            const selectWinnerMeldWildValue = (rank, suit) => {
                if (!winnerMeldWildPicker) return;
                
                const { card, meldIndex, updatedMeld, updatedPlayers, playerIndex } = winnerMeldWildPicker;
                
                // Apply the selection
                const finalMeld = [...updatedMeld];
                finalMeld[finalMeld.length - 1] = { 
                    ...finalMeld[finalMeld.length - 1], 
                    representsCard: `${rank}${suit}` 
                };
                
                // Sort the meld so it's in order
                const sortedMeld = sortMeld(finalMeld, round);
                updatedPlayers[roundWinner].melds[meldIndex] = sortedMeld;
                
                // Track that this card was played off
                if (!updatedPlayers[playerIndex].playedOnCards) {
                    updatedPlayers[playerIndex].playedOnCards = [];
                }
                updatedPlayers[playerIndex].playedOnCards.push({
                    ...card, 
                    playedOn: `${players[roundWinner].name}'s meld ${meldIndex + 1}`,
                    addedBy: updatedPlayers[playerIndex].avatar
                });
                
                setPlayers(updatedPlayers);
                setMessage(`Added ${card.rank}${card.suit} (as ${rank}${suit}) to ${players[roundWinner].name}'s meld!`);
                setWinnerMeldWildPicker(null);
            };
            
            const cancelWinnerMeldWildPicker = () => {
                setWinnerMeldWildPicker(null);
            };

            const toggleCardInMeld = (cardIndex) => {
                if (!players || !players[0] || !players[0].hand) {
                    console.error('Players not initialized');
                    return;
                }
                
                const card = players[0].hand[cardIndex];
                if (!card) {
                    console.error('Card not found at index', cardIndex);
                    return;
                }
                
                const cardInCurrentMeld = currentMeld.some(c => c.index === cardIndex);
                const cardInAnyMeld = playerMelds.some(meld => meld.some(c => c.index === cardIndex));
                
                if (cardInCurrentMeld) {
                    // Removing from meld
                    setCurrentMeld(currentMeld.filter(c => c.index !== cardIndex));
                } else if (!cardInAnyMeld) {
                    // Adding to meld - just add it without auto-assignment
                    setCurrentMeld([...currentMeld, { ...card, index: cardIndex, isWildForRound: isWild(card, round) }]);
                }
                setMeldError('');
            };

            const saveCurrentMeld = () => {
                if (currentMeld.length < 3) {
                    setMeldError('A meld must have at least 3 cards');
                    return;
                }
                
                // Use unified getMeldType function
                const { canBeSet, canBeRun } = getMeldType(currentMeld, round);
                
                if (!canBeSet && !canBeRun) {
                    setMeldError('Invalid meld! Must be a valid set (same rank) or run (consecutive cards of same suit)');
                    return;
                }
                
                // Check if meld has any unassigned wilds
                const markedCards = currentMeld.map(c => ({...c, isWildForRound: isWild(c, round)}));
                const unassignedWilds = markedCards.filter(c => c.isWildForRound && !c.representsCard);
                
                // If there are unassigned wilds or ambiguous meld type, get possible interpretations
                if (unassignedWilds.length > 0 || (canBeSet && canBeRun)) {
                    const interpretations = getPossibleMeldInterpretations(currentMeld, round);
                    
                    if (interpretations.allWilds) {
                        // All-wilds meld - use multi-step picker
                        setMeldPickerAllWilds(true);
                        setMeldPickerStep(1);
                        setShowMeldPicker(true);
                        setMeldError('');
                        return;
                    }
                    
                    if (interpretations.options.length === 0) {
                        setMeldError('Cannot determine valid meld interpretation');
                        return;
                    }
                    
                    // FIXED: Always show picker when there are wilds AND both set and run are possible
                    // Don't auto-assign just because there's technically only one interpretation listed
                    const hasWilds = unassignedWilds.length > 0;
                    const isBothSetAndRun = canBeSet && canBeRun;
                    
                    if (interpretations.options.length === 1 && !hasWilds) {
                        // Only one interpretation and no wilds - safe to auto-assign
                        const option = interpretations.options[0];
                        let meldToSave = [...currentMeld];
                        
                        // Apply assignments
                        meldToSave = meldToSave.map(card => {
                            if (isWild(card, round) && option.assignments[card.id]) {
                                return { ...card, representsCard: option.assignments[card.id] };
                            }
                            return card;
                        });
                        
                        const sortedMeld = sortMeld(meldToSave, round);
                        setPlayerMelds([...playerMelds, sortedMeld]);
                        setCurrentMeld([]);
                        setMeldError('');
                    } else if (interpretations.options.length === 1 && hasWilds && !isBothSetAndRun) {
                        // One interpretation with wilds, but clearly only one type (set OR run, not both)
                        const option = interpretations.options[0];
                        let meldToSave = [...currentMeld];
                        
                        // Apply assignments
                        meldToSave = meldToSave.map(card => {
                            if (isWild(card, round) && option.assignments[card.id]) {
                                return { ...card, representsCard: option.assignments[card.id] };
                            }
                            return card;
                        });
                        
                        const sortedMeld = sortMeld(meldToSave, round);
                        setPlayerMelds([...playerMelds, sortedMeld]);
                        setCurrentMeld([]);
                        setMeldError('');
                    } else {
                        // Multiple interpretations OR ambiguous type with wilds - always show picker
                        setMeldPickerOptions(interpretations.options);
                        setMeldPickerAllWilds(false);
                        setShowMeldPicker(true);
                        setMeldError('');
                    }
                    return;
                }
                
                // No unassigned wilds and only one valid type - auto-assign and save
                let meldToSave = [...currentMeld];
                
                if (canBeSet) {
                    meldToSave = assignWildsInSet(meldToSave, round);
                } else if (canBeRun) {
                    meldToSave = assignJokersInRun(meldToSave, round);
                }
                
                const sortedMeld = sortMeld(meldToSave, round);
                setPlayerMelds([...playerMelds, sortedMeld]);
                setCurrentMeld([]);
                setMeldError('');
            };

            // Meld picker handlers
            const handleMeldPickerSelection = (option) => {
                console.log('Meld picker selection:', option);
                
                // Apply the selected interpretation
                let meldToSave = [...currentMeld];
                
                // For all sets, use auto-assignment (whether they have wilds or not)
                // This ensures consistent behavior and uses the existing assignWildsInSet logic
                if (option.type === 'set') {
                    // Auto-assign suits using the assignWildsInSet function
                    // For sets without wilds, this just returns the meld as-is
                    // For sets with wilds, this assigns available suits automatically
                    meldToSave = assignWildsInSet(meldToSave, round);
                } else {
                    // For runs, apply the specific assignments from the option
                    meldToSave = meldToSave.map(card => {
                        if (isWild(card, round) && option.assignments[card.id]) {
                            return { ...card, representsCard: option.assignments[card.id] };
                        }
                        return card;
                    });
                    
                    // Check for remaining unassigned wilds and auto-assign if only one option
                    const stillUnassigned = meldToSave.filter(c => isWild(c, round) && !c.representsCard);
                    if (stillUnassigned.length > 0) {
                        // Try to auto-assign remaining wilds
                        const newInterpretations = getPossibleMeldInterpretations(meldToSave, round);
                        if (newInterpretations.options.length === 1) {
                            const autoOption = newInterpretations.options[0];
                            meldToSave = meldToSave.map(card => {
                                if (isWild(card, round) && autoOption.assignments[card.id]) {
                                    return { ...card, representsCard: autoOption.assignments[card.id] };
                                }
                                return card;
                            });
                        }
                    }
                }
                
                const sortedMeld = sortMeld(meldToSave, round);
                
                // Close modal and reset all picker state
                setShowMeldPicker(false);
                setMeldPickerOptions([]);
                setMeldPickerAllWilds(false);
                setMeldPickerStep(1);
                setMeldPickerSelectedType(null);
                setMeldPickerSelectedSuit(null);
                
                // Use setTimeout to ensure modal closes before state updates
                setTimeout(() => {
                    setPlayerMelds([...playerMelds, sortedMeld]);
                    setCurrentMeld([]);
                    setMeldError('');
                    
                    // If this was triggered by finalize button, continue with finalize
                    if (pendingFinalizeAfterPick) {
                        setPendingFinalizeAfterPick(false);
                        // Continue with finalize flow
                        setTimeout(() => {
                            finalizeFinalMelds();
                        }, 0);
                    }
                }, 0);
            };

            const handleMeldPickerCancel = () => {
                setShowMeldPicker(false);
                setMeldPickerOptions([]);
                setMeldPickerAllWilds(false);
                setMeldPickerStep(1);
                setMeldPickerSelectedType(null);
                setMeldPickerSelectedSuit(null);
                setPendingFinalizeAfterPick(false);
            };

            const handleAllWildsMeldTypeSelection = (type) => {
                setMeldPickerSelectedType(type);
                setMeldPickerStep(2);
            };

            const handleAllWildsSuitOrRankSelection = (value) => {
                if (meldPickerSelectedType === 'set') {
                    // Value is a rank - create the set
                    const assignments = {};
                    const usedSuits = new Set();
                    
                    currentMeld.forEach((card, idx) => {
                        let suit;
                        if (idx < SUITS.length) {
                            suit = SUITS[idx];
                        } else {
                            suit = SUITS[Math.floor(Math.random() * SUITS.length)];
                        }
                        assignments[card.id] = `${value}${suit}`;
                        usedSuits.add(suit);
                    });
                    
                    let meldToSave = currentMeld.map(card => ({
                        ...card,
                        representsCard: assignments[card.id]
                    }));
                    
                    const sortedMeld = sortMeld(meldToSave, round);
                    setPlayerMelds([...playerMelds, sortedMeld]);
                    setCurrentMeld([]);
                    setMeldError('');
                    
                    // Check if we need to continue finalize
                    const shouldContinueFinalize = pendingFinalizeAfterPick;
                    handleMeldPickerCancel();
                    
                    if (shouldContinueFinalize) {
                        setTimeout(() => finalizeFinalMelds(), 0);
                    }
                } else {
                    // Value is a suit - move to step 3 to show run options
                    setMeldPickerSelectedSuit(value);
                    setMeldPickerStep(3);
                }
            };

            const handleAllWildsRunSelection = (startRank) => {
                // Create a run starting at startRank with the selected suit
                const rankOrder = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
                const startIdx = rankOrder.indexOf(startRank);
                const assignments = {};
                
                // Validate startIdx to prevent -1 from indexOf
                if (startIdx === -1) return;
                
                currentMeld.forEach((card, idx) => {
                    const rankIdx = startIdx + idx;
                    // Validate index is within bounds
                    if (rankIdx >= 0 && rankIdx < rankOrder.length) {
                        const rank = rankOrder[rankIdx];
                        assignments[card.id] = `${rank}${meldPickerSelectedSuit}`;
                    }
                });
                
                let meldToSave = currentMeld.map(card => ({
                    ...card,
                    representsCard: assignments[card.id]
                }));
                
                const sortedMeld = sortMeld(meldToSave, round);
                setPlayerMelds([...playerMelds, sortedMeld]);
                setCurrentMeld([]);
                setMeldError('');
                
                // Check if we need to continue finalize
                const shouldContinueFinalize = pendingFinalizeAfterPick;
                handleMeldPickerCancel();
                
                if (shouldContinueFinalize) {
                    setTimeout(() => finalizeFinalMelds(), 0);
                }
            };

            const removeMeld = (meldIndex) => {
                setPlayerMelds(playerMelds.filter((_, idx) => idx !== meldIndex));
            };

            const finalizePayMe = () => {
                // If there's a current meld, check for ambiguous wilds before auto-saving
                if (currentMeld.length >= 3) {
                    const interpretations = getPossibleMeldInterpretations(currentMeld, round);
                    
                    if (interpretations.allWilds) {
                        // All-wilds meld - use multi-step picker
                        setMeldPickerAllWilds(true);
                        setMeldPickerStep(1);
                        setShowMeldPicker(true);
                        setPendingFinalizeAfterPick(true);
                        return;
                    }
                    
                    if (interpretations.options && interpretations.options.length > 1) {
                        // Multiple interpretations - show picker
                        setMeldPickerOptions(interpretations.options);
                        setShowMeldPicker(true);
                        setPendingFinalizeAfterPick(true);
                        return;
                    }
                    
                    // Only 1 interpretation or invalid - proceed with validation and auto-save
                    if (currentMeld.length < 3) {
                        setMeldError('Current meld must have at least 3 cards. Please finish it or remove cards to continue.');
                        return;
                    }
                    
                    const isSet = isValidSet(currentMeld, round);
                    const isRun = isValidRun(currentMeld, round);
                    
                    if (!isSet && !isRun) {
                        setMeldError('Current meld is not a valid set or run. Please fix it or remove cards to continue.');
                        return;
                    }
                    
                    // Auto-save the valid current meld
                    playerMelds.push([...currentMeld]);
                    setCurrentMeld([]);
                }
                
                const requiredCards = round + 2;
                const cardsInMelds = new Set();
                playerMelds.forEach(meld => {
                    meld.forEach(card => cardsInMelds.add(card.index));
                });
                
                if (cardsInMelds.size !== requiredCards) {
                    setMeldError(`You must use exactly ${requiredCards} cards in valid melds. Currently ${cardsInMelds.size} cards are in melds.`);
                    return;
                }
                
                // Find the remaining card (not in melds)
                const remainingCardIndex = players[0].hand.findIndex((card, idx) => !cardsInMelds.has(idx));
                
                if (remainingCardIndex === -1) {
                    setMeldError('Error: No card to discard. You should have exactly one card left.');
                    return;
                }
                
                // Automatically discard the remaining card
                const updatedPlayers = [...players];
                const currentPlayer = updatedPlayers[0];
                const discardedCard = currentPlayer.hand.splice(remainingCardIndex, 1)[0];
                const newDiscardPile = [...discardPile, discardedCard];
                
                // Remove the discarded card from melds and clean up
                const updatedMelds = playerMelds.map(meld => 
                    meld.filter(c => c.index !== remainingCardIndex).map(c => {
                        const {index, ...cardWithoutIndex} = c;
                        return cardWithoutIndex;
                    })
                ).filter(meld => meld.length >= 3);
                
                // Assign wild representations for both runs and sets, then SORT all melds
                const meldsWithJokers = updatedMelds.map(meld => {
                    const hasWilds = meld.some(card => isWild(card, round));
                    if (hasWilds) {
                        if (isValidRun(meld, round)) {
                            const meldWithAssignedWilds = assignJokersInRun(meld, round);
                            return sortMeld(meldWithAssignedWilds, round);
                        } else if (isValidSet(meld, round)) {
                            const meldWithAssignedWilds = assignWildsInSet(meld, round);
                            return sortMeld(meldWithAssignedWilds, round);
                        }
                    }
                    return sortMeld(meld, round);
                });
                
                updatedPlayers[0].melds = meldsWithJokers;
                updatedPlayers[0].hand = []; // Winner has no remaining cards!
                
                // Everyone pays
                const finalPlayers = updatedPlayers.map((p, idx) => {
                    if (idx === 0) {
                        return { ...p, quarters: p.quarters + players.length - 1 };
                    } else {
                        return { ...p, quarters: p.quarters - 1 };
                    }
                });
                
                setPlayers(finalPlayers);
                setDiscardPile(newDiscardPile);
                setRoundWinner(0);
                // Sort each meld so runs are in order
                const sortedMelds = meldsWithJokers.map(meld => sortMeld(meld, round));
                setWinnerMelds(sortedMelds);
                setPlayerMelds([]);
                setBuildingPayMe(false);
                setSelectedCard(null);
                
                // Show celebration!
                setCelebrationName(players[0].name);
                setShowCelebration(true);
                
                setMessage(`${players[0].name} declared "Pay Me"! Play continues in turn order.`);
                
                const nextIndex = 1 % players.length;
                
                // Auto-continue to next player after brief delay
                const timeoutId = setTimeout(() => {
                    setCurrentPlayerIndex(nextIndex);
                    setGamePhase('finaldraw');
                }, 1500);
                timeoutRefs.current.push(timeoutId);
            };

            const discardForPayMe = (cardIndex) => {
                const updatedPlayers = [...players];
                const currentPlayer = updatedPlayers[0];
                const discardedCard = currentPlayer.hand.splice(cardIndex, 1)[0];
                const newDiscardPile = [...discardPile, discardedCard];
                
                // Remove the discarded card from melds and clean up
                const updatedMelds = playerMelds.map(meld => 
                    meld.filter(c => c.index !== cardIndex).map(c => {
                        const {index, ...cardWithoutIndex} = c;
                        return cardWithoutIndex;
                    })
                ).filter(meld => meld.length >= 3);
                
                // Assign wild representations for both runs and sets, then SORT all melds
                const meldsWithJokers = updatedMelds.map(meld => {
                    const hasWilds = meld.some(card => isWild(card, round));
                    if (hasWilds) {
                        if (isValidRun(meld, round)) {
                            const meldWithAssignedWilds = assignJokersInRun(meld, round);
                            return sortMeld(meldWithAssignedWilds, round);
                        } else if (isValidSet(meld, round)) {
                            const meldWithAssignedWilds = assignWildsInSet(meld, round);
                            return sortMeld(meldWithAssignedWilds, round);
                        }
                    }
                    return sortMeld(meld, round);
                });
                
                updatedPlayers[0].melds = meldsWithJokers;
                updatedPlayers[0].hand = []; // Winner has no remaining cards!
                
                // Everyone pays
                const finalPlayers = updatedPlayers.map((p, idx) => {
                    if (idx === 0) {
                        return { ...p, quarters: p.quarters + players.length - 1 };
                    } else {
                        return { ...p, quarters: p.quarters - 1 };
                    }
                });
                
                setPlayers(finalPlayers);
                setDiscardPile(newDiscardPile);
                setRoundWinner(0);
                setWinnerMelds(updatedMelds);
                setPlayerMelds([]);
                setSelectedCard(null);
                
                // Show celebration!
                setCelebrationName(players[0].name);
                setShowCelebration(true);
                
                setMessage(`${players[0].name} declared "Pay Me"! Play continues in turn order.`);
                
                const nextIndex = 1 % players.length;
                
                // Auto-continue to next player after brief delay
                const timeoutId = setTimeout(() => {
                    setCurrentPlayerIndex(nextIndex);
                    setGamePhase('finaldraw');
                }, 1500);
                timeoutRefs.current.push(timeoutId);
            };

            const nextTurn = () => {
                const nextIndex = (currentPlayerIndex + 1) % players.length;
                setCurrentPlayerIndex(nextIndex);
                setGamePhase('draw');
                if (!players[nextIndex].isAI) {
                    setMessage('Your turn - draw a card');
                } else {
                    setMessage(`${players[nextIndex].name}'s turn...`);
                }
            };

            const layDownMelds = () => {
                const updatedPlayers = [...players];
                const currentPlayer = updatedPlayers[currentPlayerIndex];
                
                // First, form own melds
                const { melds, remaining } = findBestMelds(currentPlayer.hand, round);
                
                // Defensive: Remove any duplicate card IDs within melds
                const duplicateCards = []; // Track cards removed due to duplicates
                const cleanedMelds = melds.map(meld => {
                    const seenIds = new Set();
                    return meld.filter(card => {
                        if (seenIds.has(card.id)) {
                            console.warn(`Duplicate card ID detected in meld: ${card.rank}${card.suit} (${card.id})`);
                            duplicateCards.push(card); // Save the duplicate to add back to remaining
                            return false;
                        }
                        seenIds.add(card.id);
                        return true;
                    });
                });
                
                // Sort each meld so runs are in order
                const sortedMelds = cleanedMelds.map(meld => sortMeld(meld, round));
                currentPlayer.melds = sortedMelds;
                // Add any duplicate cards back to remaining
                let leftoverCards = [...remaining, ...duplicateCards];
                
                // Initialize playedOnCards tracking if it doesn't exist
                if (!currentPlayer.playedOnCards) {
                    currentPlayer.playedOnCards = [];
                }
                
                // Try to play leftover cards ONLY on the WINNER's melds
                // Keep trying until no more cards can be played (since adding one card might enable another)
                if (roundWinner !== null && updatedPlayers[roundWinner].melds && updatedPlayers[roundWinner].melds.length > 0) {
                    let cardWasPlayed;
                    let loopCount = 0;
                    const MAX_LOOPS = 50; // Safety limit
                    do {
                        cardWasPlayed = false;
                        loopCount++;
                        if (loopCount > MAX_LOOPS) {
                            console.error('AI play-off loop exceeded MAX_LOOPS - breaking to prevent infinite loop');
                            break;
                        }
                        const winnerPlayer = updatedPlayers[roundWinner];
                        
                        winnerPlayer.melds.forEach((meld, meldIdx) => {
                            // Check if this meld is a set or run
                            // IMPORTANT: Check SET first because with wilds, isValidRun might also return true
                            // CRITICAL: Preserve representsCard so we detect the correct meld type
                            const meldWithWilds = meld.map(c => ({
                                ...c,
                                isWildForRound: isWild(c, round),
                                ...(c.representsCard && { representsCard: c.representsCard })
                            }));
                            const meldIsSet = isValidSet(meldWithWilds, round);
                            const meldIsRun = !meldIsSet && isValidRun(meldWithWilds, round);
                            
                            // Try to add each leftover card to this meld
                            leftoverCards = leftoverCards.filter(card => {
                                // For SETS: Allow duplicate cards even if a wild represents it
                                // For RUNS: Don't allow duplicate ranks
                                
                                // First check if this is a set or run
                                const meldIsSet = isValidSet(meld.map(c => ({ ...c, isWildForRound: isWild(c, round) })), round);
                                const meldIsRun = !meldIsSet && isValidRun(meld.map(c => ({ ...c, isWildForRound: isWild(c, round) })), round);
                                
                                // For RUNS: Check if wild already represents this card or if rank is duplicate
                                if (meldIsRun && !isWild(card, round)) {
                                    const cardRankSuit = `${card.rank}${card.suit}`;
                                    const wildRepresentsThisCard = meld.some(c => 
                                        c.representsCard === cardRankSuit
                                    );
                                    if (wildRepresentsThisCard) {
                                        // A wild already represents this card in a run, can't add it
                                        return true; // Keep in leftover
                                    }
                                
                                    // Check if this rank already exists (including wilds that represent it)
                                    const cardRank = card.rank;
                                    const rankAlreadyExists = meld.some(c => {
                                        if (isWild(c, round) && c.representsCard) {
                                            // Check what rank the wild represents
                                            const match = c.representsCard.match(/^(A|[2-9]|10|J|Q|K)/);
                                            return match && match[1] === cardRank;
                                        }
                                        return c.rank === cardRank;
                                    });
                                    
                                    if (rankAlreadyExists) {
                                        return true; // Keep in leftover
                                    }
                                }
                                
                                const testMeld = [
                                    ...meld.map(c => ({
                                        ...c,
                                        isWildForRound: isWild(c, round),
                                        ...(c.representsCard && { representsCard: c.representsCard })
                                    })),
                                    { ...card, isWildForRound: isWild(card, round) }
                                ];
                                
                                // Check if card can be added to this meld
                                
                                let validAfterAdd = false;
                                if (meldIsSet) {
                                    validAfterAdd = isValidSet(testMeld, round);
                                } else if (meldIsRun) {
                    // Extra strict rule: can only extend runs on an end (and must match suit if non-wild)
                    if (!canExtendRunOnEnd(meldWithWilds, card, round)) {
                        const meldType = 'run';
                        setMessage(`Can't add ${card.rank}${card.suit} to this run - must extend the run ends (same suit)`);
                        setDraggedCardIndex(null);
                        setDropTargetIndex(null);
                        return;
                    }
                    validAfterAdd = isValidRun(testMeld, round);
                                }
                                
                                if (validAfterAdd) {
                                    // Card can be played off this meld!
                                    
                                    // Add the card to the meld with a marker showing who played it
                                    // CRITICAL: Can only add to ENDS of runs, not middle
                                    // This preserves existing wild card assignments
                                    
                                    const updatedMeld = [
                                        ...meld,
                                        { 
                                            ...card, 
                                            isWildForRound: isWild(card, round),
                                            addedBy: currentPlayer.avatar
                                        }
                                    ];
                                    
                                    let finalMeld = updatedMeld;
                                    
                                    // Assign wild representation
                                    if (meldIsRun && isWild(card, round)) {
                                        // For RUNS with wilds: assign wild representation
                                        // Determine what rank the wild represents in this run
                                        // It must extend the run at one end
                                        const nonWilds = meld.filter(c => !isWild(c, round) && !c.representsCard);
                                        const wildCards = meld.filter(c => isWild(c, round) || c.representsCard);
                                        
                                        // Get all ranks in the run (including what wilds represent)
                                        const rankOrder = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
                                        const ranks = meld.map(c => {
                                            if (c.representsCard) {
                                                return c.representsCard.slice(0, -1); // Remove suit
                                            }
                                            return c.rank;
                                        });
                                        const rankIndices = ranks.map(r => rankOrder.indexOf(r)).sort((a, b) => a - b);
                                        
                                        // Check if this is an Ace-high run (like J-Q-K-A)
                                        const hasAce = rankIndices.includes(0);
                                        const hasHighCards = rankIndices.some(idx => idx >= 10); // J, Q, or K
                                        let adjustedIndices = [...rankIndices];
                                        
                                        if (hasAce && hasHighCards) {
                                            // Check if Ace should be treated as high
                                            const nonAceIndices = rankIndices.filter(idx => idx !== 0);
                                            const minNonAce = Math.min(...nonAceIndices);
                                            if (minNonAce >= 9) { // 10 or higher
                                                // Treat Ace as 13 (after King)
                                                adjustedIndices = nonAceIndices.concat([13]).sort((a, b) => a - b);
                                            }
                                        }
                                        
                                        // Get suit from first non-wild card
                                        const suit = nonWilds.length > 0 ? nonWilds[0].suit : 
                                                     (wildCards.length > 0 && wildCards[0].representsCard) ? 
                                                     wildCards[0].representsCard.slice(-1) : 'â™ ';
                                        
                                        // Determine if it extends beginning or end
                                        const minRank = adjustedIndices[0];
                                        const maxRank = adjustedIndices[adjustedIndices.length - 1];
                                        
                                        let representsRank;
                                        let representsIndex;
                                        if (minRank > 0 && minRank - 1 < rankOrder.length) {
                                            // Can extend at beginning
                                            representsIndex = minRank - 1;
                                            representsRank = rankOrder[representsIndex];
                                        } else if (maxRank < 13) {
                                            // Can extend at end (maxRank could be 13 for Ace-high)
                                            representsIndex = maxRank + 1;
                                            if (representsIndex === 13) {
                                                representsRank = 'A'; // Extending past King with Ace
                                            } else {
                                                representsRank = rankOrder[representsIndex];
                                            }
                                        } else {
                                            // Can't extend - this shouldn't happen if isValidRun passed
                                            console.error('Wild card cannot extend run at either end!');
                                            return true; // Keep in leftover
                                        }
                                        
                                        // Set what this wild represents
                                        finalMeld = updatedMeld.map((c, idx) => {
                                            if (idx === updatedMeld.length - 1) {
                                                // This is the new wild we just added - preserve all properties including addedBy
                                                return { ...c, representsCard: `${representsRank}${suit}` };
                                            }
                                            return {...c}; // Preserve all properties
                                        });
                                    } else if (meldIsSet && isWild(card, round)) {
                                        // For SETS with wilds: assign what the wild represents
                                        const nonWilds = updatedMeld.filter(c => !isWild(c, round));
                                        const setRank = nonWilds.length > 0 ? nonWilds[0].rank : null;
                                        
                                        if (setRank) {
                                            finalMeld = updatedMeld.map(c => {
                                                if (isWild(c, round)) {
                                                    // Preserve all properties including addedBy
                                                    return { ...c, representsCard: `${setRank}${c.suit}` };
                                                }
                                                return {...c}; // Preserve all properties
                                            });
                                        }
                                    }
                                    
                                    // Sort the meld so it's in order
                                    const sortedMeld = sortMeld(finalMeld, round);
                                    
                                    // CRITICAL: Create a new melds array to trigger React re-render
                                    const winnerNewMelds = [...updatedPlayers[roundWinner].melds];
                                    winnerNewMelds[meldIdx] = sortedMeld;
                                    updatedPlayers[roundWinner] = {
                                        ...updatedPlayers[roundWinner],
                                        melds: winnerNewMelds
                                    };
                                    
                                    // Track that this card was played off (for scoring - it shouldn't count against current player)
                                    const cardToTrack = {
                                        ...card, 
                                        playedOn: `${winnerPlayer.name}'s meld ${meldIdx + 1}`,
                                        addedBy: currentPlayer.avatar
                                    };
                                    currentPlayer.playedOnCards.push(cardToTrack);
                                    cardWasPlayed = true; // Mark that we played a card, so we should loop again
                                    return false; // Remove from leftover (card is now played off)
                                }
                                return true; // Keep in leftover
                            });
                        });
                    } while (cardWasPlayed); // Keep looping while we're able to play cards
                }
                
                // CRITICAL: During final turn, player MUST have at least 1 card to discard
                // If all cards are in melds/played off, remove one from a meld
                if (leftoverCards.length === 0 && sortedMelds.length > 0) {
                    // Find the largest meld and remove one card from it
                    let largestMeldIdx = 0;
                    for (let i = 1; i < sortedMelds.length; i++) {
                        if (sortedMelds[i].length > sortedMelds[largestMeldIdx].length) {
                            largestMeldIdx = i;
                        }
                    }
                    // Remove the last card from the largest meld
                    const removedCard = sortedMelds[largestMeldIdx].pop();
                    leftoverCards.push(removedCard);
                    
                    // If this makes the meld invalid (< 3 cards), remove the entire meld
                    if (sortedMelds[largestMeldIdx].length < 3) {
                        leftoverCards.push(...sortedMelds[largestMeldIdx]);
                        sortedMelds.splice(largestMeldIdx, 1);
                    }
                    currentPlayer.melds = sortedMelds;
                }
                
                currentPlayer.hand = leftoverCards;
                
                if (currentPlayer.isAI && leftoverCards.length > 0) {
                    currentPlayer.dialogue = getDialogue(currentPlayer.character, 'lose');
                }
                
                setPlayers(updatedPlayers);
                setGamePhase('finaldiscard');
                setMessage('Click a card to discard');
            };

            const finalizeFinalMelds = () => {
                // If there's a current meld, check for ambiguous wilds before auto-saving
                let meldsToValidate = [...playerMelds];
                
                if (currentMeld.length >= 3) {
                    const interpretations = getPossibleMeldInterpretations(currentMeld, round);
                    
                    if (interpretations.allWilds) {
                        // All-wilds meld - use multi-step picker
                        setMeldPickerAllWilds(true);
                        setMeldPickerStep(1);
                        setShowMeldPicker(true);
                        setPendingFinalizeAfterPick(true);
                        return;
                    }
                    
                    if (interpretations.options && interpretations.options.length > 1) {
                        // Multiple interpretations - show picker
                        setMeldPickerOptions(interpretations.options);
                        setShowMeldPicker(true);
                        setPendingFinalizeAfterPick(true);
                        return;
                    }
                    
                    // Only 1 interpretation or invalid - validate before proceeding
                    if (currentMeld.length < 3) {
                        setMeldError('Current meld must have at least 3 cards. Please finish it or remove cards to continue.');
                        return;
                    }
                    
                    const isSet = isValidSet(currentMeld, round);
                    const isRun = isValidRun(currentMeld, round);
                    
                    if (!isSet && !isRun) {
                        setMeldError('Current meld is not a valid set or run. Please fix it or remove cards to continue.');
                        return;
                    }
                    
                    // Add valid current meld to the list to validate
                    meldsToValidate = [...playerMelds, [...currentMeld]];
                }
                
                // Validate all melds are valid (if any exist)
                for (let i = 0; i < meldsToValidate.length; i++) {
                    const meld = meldsToValidate[i];
                    if (!isValidSet(meld, round) && !isValidRun(meld, round)) {
                        setMeldError(`Meld ${i + 1} is invalid. All melds must be valid sets or runs.`);
                        return;
                    }
                }
                
                const updatedPlayers = [...players];
                const currentPlayer = updatedPlayers[0]; // Human is always index 0
                
                // Calculate how many cards are in melds
                const cardsInMelds = new Set();
                meldsToValidate.forEach(meld => meld.forEach(card => cardsInMelds.add(card.index)));
                
                const totalCards = currentPlayer.hand.length;
                const meldsCardCount = cardsInMelds.size;
                
                // Process saved melds (if any)
                const cleanedMelds = meldsToValidate.map(meld => 
                    meld.map(c => {
                        const {index, ...cardWithoutIndex} = c;
                        return cardWithoutIndex;
                    })
                );
                
                // Sort each meld so runs are in order
                const sortedMelds = cleanedMelds.map(meld => sortMeld(meld, round));
                currentPlayer.melds = sortedMelds;
                
                // Remove cards in melds AND cards played on winner from hand
                const cardsPlayedOnWinner = new Set();
                if (currentPlayer.playedOnCards) {
                    currentPlayer.playedOnCards.forEach(playedCard => {
                        const handIndex = currentPlayer.hand.findIndex(handCard => 
                            handCard.rank === playedCard.rank && 
                            handCard.suit === playedCard.suit &&
                            handCard.id === playedCard.id
                        );
                        if (handIndex !== -1) {
                            cardsPlayedOnWinner.add(handIndex);
                        }
                    });
                }
                
                const remainingHand = currentPlayer.hand.filter((card, idx) => 
                    !cardsInMelds.has(idx) && !cardsPlayedOnWinner.has(idx)
                );
                
                // Validate player has at least one card to discard
                if (!validatePlayerCanEndTurn(currentPlayer, remainingHand)) {
                    setMeldError('Error: Must have at least 1 card left to discard');
                    return;
                }
                
                currentPlayer.hand = remainingHand;
                
                // Initialize playedOnCards tracking
                if (!currentPlayer.playedOnCards) {
                    currentPlayer.playedOnCards = [];
                }
                
                // Only update state if all validation passed
                setPlayers(updatedPlayers);
                setPlayerMelds([]);
                setCurrentMeld([]);
                setMeldError('');
                setMeldBuildingComplete(true);
                
                // If exactly 1 card left, auto-discard it
                if (remainingHand.length === 1) {
                    const lastCard = remainingHand[0];
                    updatedPlayers[0].hand = [];
                    
                    // Add to discard pile
                    const updatedDiscardPile = [...discardPile, lastCard];
                    setDiscardPile(updatedDiscardPile);
                    
                    // Mark this player as having completed their final turn
                    setPlayersWhoHaveTakenFinalTurn(prev => new Set([...prev, 0]));
                    
                    // Check if this is the last player
                    const nextIndex = 1 % players.length;
                    if (nextIndex === roundWinner) {
                        // Last player - show round complete screen immediately
                        setAllFinalPlaysComplete(true);
                        // Don't set showingHumanFinalPlay - go straight to final review
                    } else {
                        // Not last player - show human player's final play results
                        const points = 0; // No cards left, so 0 points
                        setHumanFinalPlayResults({
                            player: currentPlayer,
                            melds: currentPlayer.melds,
                            remaining: [], // No cards left after auto-discard
                            discard: lastCard,
                            points: points,
                            playedOnCards: currentPlayer.playedOnCards || []
                        });
                        setShowingHumanFinalPlay(true);
                        
                        // Move to next player immediately
                        const isNextHuman = !players[nextIndex].isAI;
                        const timeoutId = setTimeout(() => {
                            setCurrentPlayerIndex(nextIndex);
                            setGamePhase('finaldraw');
                            if (isNextHuman) {
                                setMessage('Your final turn - draw a card');
                            } else {
                                setMessage(`${players[nextIndex].name}'s final turn...`);
                            }
                        }, 500);
                        timeoutRefs.current.push(timeoutId);
                    }
                } else {
                    // More than 1 card left - user needs to pick which to discard
                    setGamePhase('finaldiscard');
                    setMessage(`Click a card to discard (${remainingHand.length} cards left)`);
                }
            };

            const endRound = (currentPlayers, currentDealerIdx) => {
                // Round transition: keep showing the winning hand / last play, and avoid flashing the table/meld UI
                setIsRoundTransitioning(true);
                setBuildingPayMe(false);
                setMeldBuildingComplete(true);


                nextFinalTurnActionRef.current = null;

                const updatedPlayers = currentPlayers.map((player, idx) => {
                    const roundScore = idx === roundWinner ? 0 : calculateScore(player.hand);
                    const newScore = player.score + roundScore;
                    
                    // Save round history - clean deep copy without extra properties
                    const cleanMelds = player.melds.map(meld => 
                        meld.map(card => ({
                            rank: card.rank,
                            suit: card.suit,
                            isRed: card.isRed,
                            id: card.id,
                            representsCard: card.representsCard
                        }))
                    );
                    
                    const cleanRemainingCards = player.hand.map(card => ({
                        rank: card.rank,
                        suit: card.suit,
                        isRed: card.isRed,
                        id: card.id
                    }));
                    
                    const cleanPlayedOnCards = (player.playedOnCards || []).map(card => ({
                        rank: card.rank,
                        suit: card.suit,
                        isRed: card.isRed,
                        id: card.id,
                        playedOn: card.playedOn
                    }));
                    
                    const roundData = {
                        round: round,
                        melds: cleanMelds,
                        remainingCards: cleanRemainingCards,
                        playedOnCards: cleanPlayedOnCards,
                        roundScore: roundScore,
                        runningScore: newScore,
                        wasWinner: idx === roundWinner
                    };
                    
                    return { 
                        ...player, 
                        score: newScore,
                        roundHistory: [...(player.roundHistory || []), roundData]
                    };
                });
                setPlayers(updatedPlayers);
                
                if (round < 11) {
                    const nextDealerIdx = (currentDealerIdx + 1) % updatedPlayers.length;
                    setMessage(`Round ${round} complete! Starting round ${round + 1}...`);
                    
                    const transitionToNextRound = () => {
                        const deckCount = updatedPlayers.length <= 2 ? 1 : updatedPlayers.length <= 5 ? 2 : 3;
                        setDealerIndex(nextDealerIdx);
                        setIsRoundTransitioning(false);
                        startRound(round + 1, updatedPlayers, deckCount, nextDealerIdx);
                        setRound(round + 1);
                    };
                    
                    // Wait 3 seconds, then transition (or wait for unpause)
                    const timeoutId = setTimeout(() => {
                        // Check if paused - if so, wait for unpause
                        if (isPausedRef.current) {
                            // Set up interval to check when unpaused
                            const checkInterval = setInterval(() => {
                                if (!isPausedRef.current) {
                                    clearInterval(checkInterval);
                                    transitionToNextRound();
                                }
                            }, 100);
                            intervalRefs.current.push(checkInterval);
                        } else {
                            transitionToNextRound();
                        }
                    }, 3000);
                    timeoutRefs.current.push(timeoutId);
                } else {
                    const winner = updatedPlayers.reduce((min, p) => p.score < min.score ? p : min);
                    setMessage(`Game Over! ${winner.name} wins with ${winner.score} points!`);
                    setGameOver(true);
                }
            };

            
            const autoLayoffForAI = (aiPlayerIndex) => {
                if (roundWinner === null || roundWinner === undefined) return;
                if (aiPlayerIndex === roundWinner) return;

                setPlayers(prevPlayers => {
                    // Deep-ish copy players so we don't mutate state
                    const updatedPlayers = prevPlayers.map(p => ({
                        ...p,
                        hand: [...(p.hand || [])],
                        melds: (p.melds || []).map(m => [...m]),
                        playedOnCards: p.playedOnCards ? [...p.playedOnCards] : []
                    }));

                    const ai = updatedPlayers[aiPlayerIndex];
                    const winner = updatedPlayers[roundWinner];
                    if (!ai || !winner || !winner.melds || winner.melds.length === 0) return prevPlayers;

                    const rankOrder = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
                    const rankToIndex = r => rankOrder.indexOf(r);

                    const tryAddCardToMeld = (card, meldIndex, currentWinnerMelds) => {
                        const meld = currentWinnerMelds[meldIndex];
                        if (!meld || meld.length === 0) return { ok: false };

                        const meldWithWilds = meld.map(c => ({
                            ...c,
                            isWildForRound: isWild(c, round),
                            ...(c.representsCard && { representsCard: c.representsCard })
                        }));

                        const hasLockedRepresentations = meldWithWilds.some(c => c && c.representsCard);
                let meldIsSet = false;
                let meldIsRun = false;
                if (hasLockedRepresentations) {
                    // If wilds are already assigned (representsCard), prefer validating as a RUN using those assignments.
                    meldIsRun = isValidRun(meldWithWilds, round);
                    meldIsSet = !meldIsRun && isValidSet(meldWithWilds, round);
                } else {
                    // Otherwise keep legacy behavior (sets take precedence when ambiguous).
                    meldIsSet = isValidSet(meldWithWilds, round);
                    meldIsRun = !meldIsSet && isValidRun(meldWithWilds, round);
                }
                        if (!meldIsSet && !meldIsRun) return { ok: false };

                        // Build candidate meld(s)
                        const baseAdded = [...meld, { ...card, isWildForRound: isWild(card, round), addedBy: ai.avatar }];

                        // For RUNS only: check if adding non-wild would create duplicate rank or wrong suit
                        // For SETS: allow duplicate cards even if a wild represents one
                        if (meldIsRun && !isWild(card, round)) {
                            // Avoid adding a non-wild card if a wild already represents that exact rank+suit in a run
                            const cardRankSuit = `${card.rank}${card.suit}`;
                            const wildRepresentsThisCard = meld.some(c => c.representsCard === cardRankSuit);
                            if (wildRepresentsThisCard) return { ok: false };
                            
                            // Check for duplicate rank (including ranks represented by wilds)
                            const cardRank = card.rank;
                            const rankAlreadyExists = meld.some(c => {
                                if (isWild(c, round) && c.representsCard) {
                                    const match = c.representsCard.match(/^(A|[2-9]|10|J|Q|K)/);
                                    return match && match[1] === cardRank;
                                }
                                return c.rank === cardRank;
                            });
                            if (rankAlreadyExists) return { ok: false };
                            
                            // Check suit matching - get the run's suit
                            const runSuit = (() => {
                                // Try to get suit from a non-wild card first
                                const nonWild = meld.find(c => !isWild(c, round));
                                if (nonWild) return nonWild.suit;
                                // Otherwise get from a wild's representsCard
                                const wildWithRep = meld.find(c => c.representsCard);
                                if (wildWithRep) {
                                    const match = wildWithRep.representsCard.match(/([â™ â™¥â™¦â™£])$/);
                                    return match ? match[1] : null;
                                }
                                return null;
                            })();
                            
                            // If we know the run's suit and card doesn't match, reject
                            if (runSuit && card.suit !== runSuit) {
                                return { ok: false };
                            }
                        }

                        // If adding a wild to a run, assign representsCard automatically
                        if (meldIsRun && isWild(card, round)) {
                            // Determine suit of the run from any non-wild card or represented suit
                            const suit = (() => {
                                const nonWild = meld.find(c => !isWild(c, round));
                                if (nonWild) return nonWild.suit;
                                const rep = meld.find(c => c.representsCard);
                                const match = rep && rep.representsCard && rep.representsCard.match(/(â™ |â™¥|â™¦|â™£)$/);
                                return match ? match[1] : card.suit;
                            })();

                            // Get current rank indices in the run (respect representsCard)
                            const currentIndices = meld.map(c => {
                                if (isWild(c, round) && c.representsCard) {
                                    const match = c.representsCard.match(/^(A|[2-9]|10|J|Q|K)/);
                                    return match ? rankToIndex(match[1]) : rankToIndex(c.rank);
                                }
                                return rankToIndex(c.rank);
                            }).filter(i => i >= 0);
                            if (currentIndices.length === 0) return { ok: false };

                            // Handle Ace-high adjustment similar to existing code
                            const hasAce = currentIndices.includes(0);
                            const hasHighCards = currentIndices.some(idx => idx >= 10);
                            let adjusted = [...currentIndices];
                            if (hasAce && hasHighCards) {
                                const minNonAce = Math.min(...currentIndices.filter(i => i !== 0));
                                if (minNonAce >= 9) adjusted = currentIndices.map(i => i === 0 ? 13 : i);
                            }

                            const min = Math.min(...adjusted);
                            const max = Math.max(...adjusted);
                            const options = [];
                            if (min > 0) options.push(rankOrder[min - 1]);
                            if (max < 12) options.push(rankOrder[max + 1]);
                            if (max === 12 && !adjusted.includes(13) && !adjusted.includes(0)) options.push('A');

                            // Try each option until run is valid
                            for (const chosenRank of options) {
                                const candidate = [...baseAdded];
                                candidate[candidate.length - 1] = { ...candidate[candidate.length - 1], representsCard: `${chosenRank}${suit}` };
                                const sorted = sortMeld(candidate, round);
                                if (isValidRun(sorted.map(c => ({
                                    ...c,
                                    isWildForRound: isWild(c, round),
                                    ...(c.representsCard && { representsCard: c.representsCard })
                                })), round)) {
                                    return { ok: true, meld: sorted, playedCard: { ...card, representsCard: `${chosenRank}${suit}` } };
                                }
                            }
                            return { ok: false };
                        }

                        // For non-wild or set, validate by re-checking the appropriate type
                        const sorted = sortMeld(baseAdded, round);
                        
                        // If adding a wild to a set, assign what it represents
                        if (meldIsSet && isWild(card, round)) {
                            const nonWilds = sorted.filter(c => !isWild(c, round));
                            if (nonWilds.length > 0) {
                                const setRank = nonWilds[0].rank;
                                // Assign the wild to represent the set's rank with its original suit
                                const wildIdx = sorted.findIndex(c => c.id === card.id);
                                if (wildIdx >= 0) {
                                    sorted[wildIdx] = { ...sorted[wildIdx], representsCard: `${setRank}${card.suit}` };
                                }
                            }
                        }
                        
                        const sortedWithWilds = sorted.map(c => ({
                            ...c,
                            isWildForRound: isWild(c, round),
                            ...(c.representsCard && { representsCard: c.representsCard })
                        }));
                        const ok = meldIsSet ? isValidSet(sortedWithWilds, round) : isValidRun(sortedWithWilds, round);
                        if (!ok) return { ok: false };
                        return { ok: true, meld: sorted, playedCard: card };
                    };

                    // NEW OPTIMIZED APPROACH: Try all possible combinations to find minimum points
                    // Generate all possible play sequences
                    const findOptimalLayoff = (hand, winnerMelds) => {
                        // Must keep at least 1 card for discard
                        if (hand.length <= 1) return { plays: [], remainingHand: hand, winnerMelds: winnerMelds };
                        
                        let bestSolution = {
                            plays: [],
                            remainingHand: hand,
                            winnerMelds: winnerMelds,
                            points: calculateScore(hand)
                        };
                        
                        // Try playing each card on each meld using recursive backtracking
                        const tryAllCombinations = (currentHand, currentWinnerMelds, currentPlays, depth) => {
                            // Must keep at least 1 card
                            if (currentHand.length <= 1) {
                                const points = calculateScore(currentHand);
                                if (points < bestSolution.points) {
                                    bestSolution = {
                                        plays: [...currentPlays],
                                        remainingHand: [...currentHand],
                                        winnerMelds: currentWinnerMelds.map(m => [...m]),
                                        points: points
                                    };
                                }
                                return;
                            }
                            
                            // Limit depth to avoid exponential explosion (max 10 cards laid off)
                            if (depth >= 10) {
                                const points = calculateScore(currentHand);
                                if (points < bestSolution.points) {
                                    bestSolution = {
                                        plays: [...currentPlays],
                                        remainingHand: [...currentHand],
                                        winnerMelds: currentWinnerMelds.map(m => [...m]),
                                        points: points
                                    };
                                }
                                return;
                            }
                            
                            // Try playing each card
                            let foundAnyPlay = false;
                            for (let cardIdx = 0; cardIdx < currentHand.length; cardIdx++) {
                                const card = currentHand[cardIdx];
                                
                                // Try each meld
                                for (let meldIdx = 0; meldIdx < currentWinnerMelds.length; meldIdx++) {
                                    const result = tryAddCardToMeld(card, meldIdx, currentWinnerMelds);
                                    if (result.ok) {
                                        foundAnyPlay = true;
                                        
                                        // Create new state with this play
                                        const newHand = currentHand.filter((_, idx) => idx !== cardIdx);
                                        const newWinnerMelds = currentWinnerMelds.map((m, idx) => 
                                            idx === meldIdx ? result.meld : [...m]
                                        );
                                        const newPlays = [...currentPlays, { 
                                            card: result.playedCard || card, 
                                            meldIdx: meldIdx 
                                        }];
                                        
                                        // Recurse
                                        tryAllCombinations(newHand, newWinnerMelds, newPlays, depth + 1);
                                    }
                                }
                            }
                            
                            // If no plays were found, this is a leaf node
                            if (!foundAnyPlay) {
                                const points = calculateScore(currentHand);
                                if (points < bestSolution.points) {
                                    bestSolution = {
                                        plays: [...currentPlays],
                                        remainingHand: [...currentHand],
                                        winnerMelds: currentWinnerMelds.map(m => [...m]),
                                        points: points
                                    };
                                }
                            }
                        };
                        
                        tryAllCombinations(hand, winnerMelds, [], 0);
                        return bestSolution;
                    };
                    
                    // Find and apply optimal layoff
                    const optimalSolution = findOptimalLayoff(ai.hand, winner.melds);
                    
                    // Apply the optimal solution
                    ai.hand = optimalSolution.remainingHand;
                    winner.melds = optimalSolution.winnerMelds;
                    optimalSolution.plays.forEach(play => {
                        ai.playedOnCards.push({ 
                            ...play.card, 
                            playedOn: `${winner.name}'s meld ${play.meldIdx + 1}`, 
                            addedBy: ai.avatar 
                        });
                    });

                    return updatedPlayers;
                });
            };
const processAITurn = () => {
                const player = players[currentPlayerIndex];
                if (!player || !player.isAI) return;
                
                if (gamePhase === 'draw' || gamePhase === 'finaldraw') {
                    // Get the top discard BEFORE making decision (this is what AI sees)
                    const topDiscard = discardPile.length > 0 ? discardPile[discardPile.length - 1] : null;
                    const decision = makeAIDecision(player.hand, discardPile, round, deck.length);
                    
                    // Track which card the AI will draw
                    let drawnCard;
                    if (decision.drawFromDiscard && topDiscard) {
                        drawnCard = topDiscard;
                        setMessage(`${player.name} took the ${topDiscard.rank}${topDiscard.suit} from the discard pile`);
                    } else {
                        // Card from deck - will be the last card after draw
                        drawnCard = null; // Will be set after drawCard
                        setMessage(`${player.name} drew from the deck`);
                    }
                    
                    // Store the drawn card info for use in discard phase
                    const playerWithDrawnCard = { ...player, justDrawnCard: drawnCard };
                    const updatedPlayers = [...players];
                    updatedPlayers[currentPlayerIndex] = playerWithDrawnCard;
                    setPlayers(updatedPlayers);
                    
                    setAiDrawHighlight(decision.drawFromDiscard ? 'discard' : 'deck');
                    const timeoutId = setTimeout(() => setAiDrawHighlight(null), 900 / aiSpeed);
                    timeoutRefs.current.push(timeoutId);
                    drawCard(decision.drawFromDiscard);
                } else if (gamePhase === 'discard' || gamePhase === 'finaldiscard') {
                    if (gamePhase === 'finaldiscard') {
                        autoLayoffForAI(currentPlayerIndex);
                    }
                    const requiredCards = round + 2;
                    // Reserve a card for discard when checking for Pay Me
                    const { melds, remaining } = findBestMelds(player.hand, round, true);
                    
                    // Count cards in melds
                    const cardsInMelds = melds.reduce((sum, meld) => sum + meld.length, 0);
                    
                    // Smart Pay Me strategy - consider multiple factors
                    const canDeclarePayMe = cardsInMelds === requiredCards && player.hand.length === requiredCards + 1;
                    const shouldDeclarePayMe = canDeclarePayMe && (() => {
                        // Factor 1: Always declare if we can (it's almost always good)
                        let shouldDeclare = true;
                        
                        // Factor 2: Check if remaining card is very low value (might want to hold it)
                        if (remaining.length === 1) {
                            const remainingValue = CARD_VALUES[remaining[0].rank] || 0;
                            // If it's 2-5 points, very safe to declare
                            if (remainingValue <= 5) shouldDeclare = true;
                        }
                        
                        // Factor 3: Late in game (deck running low), be more aggressive
                        if (deck.length < 20) shouldDeclare = true;
                        
                        // Factor 4: If other players have few cards, declare quickly
                        const minOtherPlayerCards = Math.min(...players.filter((p, idx) => idx !== currentPlayerIndex).map(p => p.hand.length));
                        if (minOtherPlayerCards <= 4) shouldDeclare = true;
                        
                        return shouldDeclare;
                    })();
                    
                    if (shouldDeclarePayMe) {
                        // AI declares Pay Me!
                        // The card to discard must be one of the remaining cards (not in melds)
                        const updatedPlayers = [...players];
                        
                        // Discard should come from remaining cards only
                        let discardedCard;
                        if (remaining.length > 0) {
                            // Pick worst card from remaining
                            let worstIdx = 0;
                            let worstValue = -1;
                            remaining.forEach((card, idx) => {
                                const value = CARD_VALUES[card.rank] || 20;
                                if (value > worstValue) {
                                    worstValue = value;
                                    worstIdx = idx;
                                }
                            });
                            discardedCard = remaining[worstIdx];
                            
                            // Remove from hand
                            const cardIndexInHand = updatedPlayers[currentPlayerIndex].hand.findIndex(
                                c => c.id === discardedCard.id
                            );
                            updatedPlayers[currentPlayerIndex].hand.splice(cardIndexInHand, 1);
                        } else {
                            // Shouldn't happen, but fallback
                            discardedCard = updatedPlayers[currentPlayerIndex].hand.pop();
                        }
                        
                        const newDiscardPile = [...discardPile, discardedCard];
                        
                        // Use the melds we already validated and assign joker representations
                        const meldsWithJokers = melds.map(meld => {
                            // Check if this is a run with wilds
                            const hasWilds = meld.some(card => isWild(card, round));
                            if (hasWilds && isValidRun(meld, round)) {
                                return assignJokersInRun(meld, round);
                            }
                            return meld;
                        });
                        
                        updatedPlayers[currentPlayerIndex].melds = meldsWithJokers;
                        updatedPlayers[currentPlayerIndex].hand = []; // Winner has no remaining cards!
                        updatedPlayers[currentPlayerIndex].dialogue = getDialogue(updatedPlayers[currentPlayerIndex].character, 'payme');
                        
                        // Update quarters for everyone
                        const finalPlayers = updatedPlayers.map((p, idx) => {
                            if (idx === currentPlayerIndex) {
                                return { ...p, quarters: p.quarters + players.length - 1 };
                            } else {
                                return { ...p, quarters: p.quarters - 1 };
                            }
                        });
                        
                        setPlayers(finalPlayers);
                        setDiscardPile(newDiscardPile);
                        setRoundWinner(currentPlayerIndex);
                        setWinnerMelds(melds);
                        
                        // Show celebration!
                        setCelebrationName(player.name);
                        setShowCelebration(true);
                        
                        setMessage(`${player.name} declared "Pay Me"! Play continues in turn order.`);
                        
                        const nextIndex = (currentPlayerIndex + 1) % players.length;
                        
                        // Auto-continue to next player after brief delay
                        const timeoutId = setTimeout(() => {
                            setCurrentPlayerIndex(nextIndex);
                            setGamePhase('finaldraw');
                        }, 1500);
                        timeoutRefs.current.push(timeoutId);
                    } else {
                        // Not declaring Pay Me - make smart discard decision
                        // But consider: are we close to Pay Me? If so, be strategic
                        const closeToPayMe = cardsInMelds >= requiredCards - 2;
                        
                        if (closeToPayMe) {
                            // We're close! Don't discard cards that could help us get Pay Me
                            // Avoid discarding:
                            // 1. Cards that complete sets (if we have 2 of same rank)
                            // 2. Cards that fill run gaps
                            // 3. Wild cards (never discard these anyway)
                            
                            let bestDiscardIndex = -1;
                            let worstScore = Infinity;
                            
                            
                            player.hand.forEach((card, idx) => {
                                const cardIsWild = isWild(card, round);
                                if (cardIsWild) {
                                    return; // Never discard wilds
                                }
                                
                                let score = 0;
                                
                                // How many of this rank do we have?
                                const sameRank = player.hand.filter(c => c.rank === card.rank).length;
                                if (sameRank >= 3) {
                                    score += 100; // Part of set - keep!
                                } else if (sameRank === 2) {
                                    score += 50; // Potential set
                                }
                                
                                // Is it part of potential run?
                                const rankOrder = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
                                const cardRankIdx = rankOrder.indexOf(card.rank);
                                const sameSuitNearby = player.hand.filter(c => {
                                    if (c.suit !== card.suit || c.id === card.id) return false;
                                    if (isWild(c, round)) return true;
                                    const otherRankIdx = rankOrder.indexOf(c.rank);
                                    return Math.abs(otherRankIdx - cardRankIdx) <= 2;
                                }).length;
                                
                                if (sameSuitNearby >= 2) {
                                    score += 80; // Part of run
                                } else if (sameSuitNearby === 1) {
                                    score += 30;
                                }
                                
                                // Penalty for high value (want to discard high cards)
                                score -= (CARD_VALUES[card.rank] || 0);
                                
                                if (score < worstScore) {
                                    worstScore = score;
                                    bestDiscardIndex = idx;
                                }
                            });
                            
                            if (bestDiscardIndex >= 0) {
                                discardCard(bestDiscardIndex);
                            } else {
                                // Fallback to simple logic
                                const justDrawnCard = player.justDrawnCard || (player.hand.length > 0 ? player.hand[player.hand.length - 1] : null);
                                const decision = makeAIDecision(player.hand, discardPile, round, deck.length, justDrawnCard);
                                discardCard(decision.discardIndex);
                            }
                        } else {
                            // Not close to Pay Me, use normal logic
                            const justDrawnCard = player.justDrawnCard || (player.hand.length > 0 ? player.hand[player.hand.length - 1] : null);
                            const decision = makeAIDecision(player.hand, discardPile, round, deck.length, justDrawnCard);
                            discardCard(decision.discardIndex);
                        }
                    }
                } else if (gamePhase === 'finaldiscard') {
                    const justDrawnCard = player.justDrawnCard || (player.hand.length > 0 ? player.hand[player.hand.length - 1] : null);
                    const decision = makeAIDecision(player.hand, discardPile, round, deck.length, justDrawnCard);
                    discardCard(decision.discardIndex);
                } else if (gamePhase === 'finallaydown') {
                    // AI builds melds and discards in one go, then shows results
                    // First do the laydown
                    const updatedPlayers = [...players];
                    const currentPlayer = updatedPlayers[currentPlayerIndex];
                    
                    // Form melds (reserveForDiscard=true ensures we keep at least 1 card for required discard)
                    const { melds, remaining } = findBestMelds(currentPlayer.hand, round, true);
                    
                    // Clean duplicates
                    const duplicateCards = [];
                    const cleanedMelds = melds.map(meld => {
                        const seenIds = new Set();
                        return meld.filter(card => {
                            if (seenIds.has(card.id)) {
                                duplicateCards.push(card);
                                return false;
                            }
                            seenIds.add(card.id);
                            return true;
                        });
                    });
                    
                    const sortedMelds = cleanedMelds.map(meld => sortMeld(meld, round));
                    currentPlayer.melds = sortedMelds;
                    let leftoverCards = [...remaining, ...duplicateCards];
                    
                    // CRITICAL: Must have at least 1 card to discard - if we have 0, remove from smallest meld
                    if (leftoverCards.length === 0 && sortedMelds.length > 0) {
                        console.warn(`WARNING: ${currentPlayer.name} has no leftover cards after forming melds. This should have been prevented by findBestMelds with reserveForDiscard=true. Attempting recovery...`);
                        // Find smallest meld
                        let smallestMeldIdx = 0;
                        let smallestSize = sortedMelds[0].length;
                        for (let i = 1; i < sortedMelds.length; i++) {
                            if (sortedMelds[i].length < smallestSize) {
                                smallestSize = sortedMelds[i].length;
                                smallestMeldIdx = i;
                            }
                        }
                        
                        // Find lowest-value non-wild card in the smallest meld
                        const smallestMeld = sortedMelds[smallestMeldIdx];
                        let lowestValueIdx = -1;
                        let lowestValue = Infinity;
                        for (let i = 0; i < smallestMeld.length; i++) {
                            const card = smallestMeld[i];
                            if (!isWild(card, round)) {
                                const value = CARD_VALUES[card.rank] || 0;
                                if (value < lowestValue) {
                                    lowestValue = value;
                                    lowestValueIdx = i;
                                }
                            }
                        }
                        
                        // If no non-wild found (all wilds), just take the last card
                        if (lowestValueIdx === -1) {
                            lowestValueIdx = smallestMeld.length - 1;
                        }
                        
                        // Remove card from meld
                        const removedCard = smallestMeld.splice(lowestValueIdx, 1)[0];
                        leftoverCards.push(removedCard);
                        
                        // If meld is now invalid (< 3 cards), dissolve it completely
                        if (smallestMeld.length < 3) {
                            leftoverCards.push(...smallestMeld);
                            sortedMelds.splice(smallestMeldIdx, 1);
                        }
                        
                        currentPlayer.melds = sortedMelds;
                    }
                    
                    if (!currentPlayer.playedOnCards) {
                        currentPlayer.playedOnCards = [];
                    }
                    
                    // Play on winner's melds (strict: runs must extend on an end; respects locked wild assignments)
                    if (roundWinner !== null && updatedPlayers[roundWinner] && updatedPlayers[roundWinner].melds && updatedPlayers[roundWinner].melds.length > 0) {
                        const rankToValue = (rank, aceHigh=true) => {
                            if (rank === 'A') return aceHigh ? 14 : 1;
                            if (rank === 'K') return 13;
                            if (rank === 'Q') return 12;
                            if (rank === 'J') return 11;
                            return parseInt(rank, 10);
                        };
                        const valueToRank = (v) => {
                            if (v === 14 || v === 1) return 'A';
                            if (v === 13) return 'K';
                            if (v === 12) return 'Q';
                            if (v === 11) return 'J';
                            return String(v);
                        };
                        const parseRepresents = (rep) => {
                            if (!rep || typeof rep !== 'string') return null;
                            const suit = rep.slice(-1);
                            const rank = rep.slice(0, -1);
                            return { rank, suit };
                        };
                        const effectiveRankSuit = (c) => {
                            if (c.representsCard) {
                                const p = parseRepresents(c.representsCard);
                                if (p) return p;
                            }
                            return { rank: c.rank, suit: c.suit };
                        };
                        const getRunInfo = (meld) => {
                            const eff = meld.map(effectiveRankSuit);
                            // Determine suit from first non-wild effective card
                            const suit = eff.find(x => x.suit)?.suit || null;
                            // Compute values, default Ace high; if run looks like A-2-3, treat Ace low
                            let valuesHigh = eff.map(x => rankToValue(x.rank, true));
                            const hasAce = eff.some(x => x.rank === 'A');
                            if (hasAce) {
                                const nonAce = valuesHigh.filter(v => v !== 14);
                                if (nonAce.length && Math.min(...nonAce) <= 5) {
                                    // likely Ace low run
                                    valuesHigh = eff.map(x => rankToValue(x.rank, false));
                                }
                            }
                            const minV = Math.min(...valuesHigh);
                            const maxV = Math.max(...valuesHigh);
                            return { suit, minV, maxV, aceLow: valuesHigh.some(v => v === 1) };
                        };
                        const canPlayOnRun = (card, meld) => {
                            const info = getRunInfo(meld);
                            if (!info.suit) return null;
                            const neededLow = info.minV - 1;
                            const neededHigh = info.maxV + 1;
                            // Non-wild must match suit and be exactly one of the end ranks
                            if (!isWild(card, round)) {
                                if (card.suit !== info.suit) return null;
                                // For Ace we treat as 14 in high runs, 1 in low runs
                                const vHigh = rankToValue(card.rank, true);
                                const vLow = rankToValue(card.rank, false);
                                const v = info.aceLow ? vLow : vHigh;
                                if (v === neededLow || v === neededHigh) return { representsCard: null };
                                return null;
                            }
                            // Wild: can represent neededLow or neededHigh in the run suit
                            // Avoid representing values outside 1..14
                            const candidates = [];
                            if (neededLow >= 1 && neededLow <= 14) candidates.push(neededLow);
                            if (neededHigh >= 1 && neededHigh <= 14) candidates.push(neededHigh);
                            if (!candidates.length) return null;
                            const v = candidates[0];
                            const repRank = valueToRank(v);
                            return { representsCard: `${repRank}${info.suit}` };
                        };
                        const canPlayOnSet = (card, meld) => {
                            // Determine set rank from first non-wild effective card; wilds can always be assigned to that rank.
                            const eff = meld.map(effectiveRankSuit);
                            const base = eff.find((x, idx) => !isWild(meld[idx], round));
                            const targetRank = base ? base.rank : null;
                            if (!targetRank) return isWild(card, round) ? { representsCard: null } : null;
                            if (!isWild(card, round)) {
                                return card.rank === targetRank ? { representsCard: null } : null;
                            }
                            // Wild can represent targetRank (suit irrelevant for set representation)
                            return { representsCard: null }; // suit doesn't matter for sets; keep display as wild
                        };

                        // Loop until no more cards can be played (but keep at least 1 for the required discard)
                        const winnerPlayer = updatedPlayers[roundWinner];
                        let progressed = true;
                        let guard = 0;
                        while (progressed && guard++ < 100 && leftoverCards.length > 1) { // MUST keep at least 1 card for discard
                            progressed = false;
                            for (let meldIdx = 0; meldIdx < winnerPlayer.melds.length; meldIdx++) {
                                const meld = winnerPlayer.melds[meldIdx];
                                const meldWithFlags = meld.map(c => ({ ...c, isWildForRound: isWild(c, round) }));
                                // Prefer RUN if the meld is (or contains) locked wild assignments; otherwise fall back to legacy check
                                const hasLocked = meldWithFlags.some(c => !!c.representsCard);
                                const isRun = hasLocked ? isValidRun(meldWithFlags, round) : (!isValidSet(meldWithFlags, round) && isValidRun(meldWithFlags, round));
                                const isSet = hasLocked ? (!isRun && isValidSet(meldWithFlags, round)) : isValidSet(meldWithFlags, round);

                                for (let ci = 0; ci < leftoverCards.length; ci++) {
                                    // CRITICAL: Must keep at least 1 card for required discard
                                    if (leftoverCards.length <= 1) break;
                                    
                                    const card = leftoverCards[ci];
                                    let play = null;
                                    if (isRun) play = canPlayOnRun(card, meldWithFlags);
                                    else if (isSet) play = canPlayOnSet(card, meldWithFlags);

                                    if (play) {
                                        const playedCard = { ...card, addedBy: currentPlayer.avatar, playedOn: `${winnerPlayer.name}'s meld ${meldIdx + 1}` };
                                        if (isWild(card, round) && play.representsCard) {
                                            playedCard.representsCard = play.representsCard;
                                        }
                                        winnerPlayer.melds[meldIdx] = sortMeld([...winnerPlayer.melds[meldIdx], playedCard], round);
                                        leftoverCards.splice(ci, 1);
                                        currentPlayer.playedOnCards.push(playedCard);
                                        progressed = true;
                                        break;
                                    }
                                }
                            }
                        }
                    }
// Now discard (REQUIRED - every player must discard)
                    let discardedCard;
                    if (leftoverCards.length === 0) {
                        console.error(`CRITICAL ERROR: ${currentPlayer.name} (AI) has no cards left to discard! This should be impossible.`);
                        console.error('Attempting recovery by removing a card from a meld...');
                        
                        // Try to recover by removing a card from a meld
                        if (currentPlayer.melds.length > 0) {
                            // Find smallest meld
                            let smallestMeldIdx = 0;
                            let smallestSize = currentPlayer.melds[0].length;
                            for (let i = 1; i < currentPlayer.melds.length; i++) {
                                if (currentPlayer.melds[i].length < smallestSize) {
                                    smallestSize = currentPlayer.melds[i].length;
                                    smallestMeldIdx = i;
                                }
                            }
                            
                            // Remove lowest-value non-wild card
                            const meld = currentPlayer.melds[smallestMeldIdx];
                            let lowestValueIdx = -1;
                            let lowestValue = Infinity;
                            for (let i = 0; i < meld.length; i++) {
                                const card = meld[i];
                                if (!isWild(card, round)) {
                                    const value = CARD_VALUES[card.rank] || 0;
                                    if (value < lowestValue) {
                                        lowestValue = value;
                                        lowestValueIdx = i;
                                    }
                                }
                            }
                            
                            if (lowestValueIdx === -1) lowestValueIdx = meld.length - 1;
                            
                            const removedCard = meld.splice(lowestValueIdx, 1)[0];
                            leftoverCards.push(removedCard);
                            
                            // If meld is now invalid, dissolve it
                            if (meld.length < 3) {
                                leftoverCards.push(...meld);
                                currentPlayer.melds.splice(smallestMeldIdx, 1);
                            }
                            
                            console.log(`Recovered: Removed ${removedCard.rank}${removedCard.suit} for discard`);
                        }
                        
                        // Now try to discard again
                        if (leftoverCards.length === 0) {
                            console.error('Recovery failed - still no cards to discard!');
                            discardedCard = null;
                        } else {
                            discardedCard = leftoverCards.shift();
                        }
                    } else {
                        let bestDiscardIndex = 0;
                        let worstScore = Infinity;
                        leftoverCards.forEach((card, idx) => {
                            let score = 0;
                            if (isWild(card, round)) score += 1000;
                            score -= (CARD_VALUES[card.rank] || 0);
                            if (score < worstScore) {
                                worstScore = score;
                                bestDiscardIndex = idx;
                            }
                        });
                        
                        discardedCard = leftoverCards.splice(bestDiscardIndex, 1)[0];
                    }
                    
                    currentPlayer.hand = leftoverCards;
                    const newDiscardPile = discardedCard ? [...discardPile, discardedCard] : discardPile;
                    
                    // DEFENSIVE VALIDATION: Ensure we actually have a discarded card
                    if (!discardedCard) {
                        console.error(`CRITICAL ERROR: ${currentPlayer.name} completed finallaydown without discarding a card! This violates game rules.`);
                        // Force a discard if somehow we got here without one
                        if (currentPlayer.hand.length > 0) {
                            discardedCard = currentPlayer.hand.pop();
                            newDiscardPile.push(discardedCard);
                            console.warn(`Emergency recovery: Forced discard of ${discardedCard.rank}${discardedCard.suit}`);
                        }
                    }
                    
                    currentPlayer.dialogue = getDialogue(currentPlayer.character, 'discard');
                    
                    setPlayers(updatedPlayers);
                    setDiscardPile(newDiscardPile);
                    setPlayersWhoHaveTakenFinalTurn(prev => new Set([...prev, currentPlayerIndex]));
                    
                    // Show AI results
                    const points = calculateScore(currentPlayer.hand);
                    setAiResultsToShow({
                        player: currentPlayer,
                        melds: currentPlayer.melds,
                        remaining: [...currentPlayer.hand],
                        discard: discardedCard,
                        points: points,
                        playedOnCards: currentPlayer.playedOnCards || []
                    });
                    setShowingAIMelds(true);
                    setMeldError(''); // Clear any previous meld errors
                    
                    // Store next action
                    const nextIndex = (currentPlayerIndex + 1) % players.length;
                    if (nextIndex === roundWinner) {
                        // Last player - set up action to show final review screen AFTER they click continue
                        nextFinalTurnActionRef.current = () => {
                            setShowingAIMelds(false);
                            setAiResultsToShow(null);
                            setHumanFinalPlayResults(null);
                            setAllFinalPlaysComplete(true);
                            // allFinalPlaysComplete set to true to show review screen
                        };
                    } else {
                        const isNextHuman = !players[nextIndex].isAI;
                        nextFinalTurnActionRef.current = () => {
                            setCurrentPlayerIndex(nextIndex);
                            setGamePhase('finaldraw');
                            if (isNextHuman) {
                                setMessage('Your final turn - draw a card');
                            } else {
                                setMessage(`${players[nextIndex].name}'s final turn...`);
                            }
                        };
                    }
                }
            };

            useEffect(() => {
                if (!gameStarted || players.length === 0 || !players[currentPlayerIndex]) return;
                if (pausedAfterPayMe) return; // Don't auto-advance when paused
                if (buildingPayMe) return; // Don't auto-advance while player is building Pay Me melds
                if (showingAIMelds) return; // Don't auto-advance while showing AI melds
                if (allFinalPlaysComplete) return; // Don't auto-advance when all final plays are complete
                
                const currentPlayer = players[currentPlayerIndex];
                
                if (currentPlayer.isAI && !isPaused) {
                    const baseDelay = gamePhase === 'draw' || gamePhase === 'finaldraw' ? 1000 : 800;
                    const timer = setTimeout(() => processAITurn(), baseDelay / aiSpeed);
                    return () => clearTimeout(timer);
                }
            }, [currentPlayerIndex, gamePhase, gameStarted, isPaused, showingAIMelds, allFinalPlaysComplete, pausedAfterPayMe, buildingPayMe]);

            // Keep isPausedRef in sync with isPaused state
            useEffect(() => {
                isPausedRef.current = isPaused;
            }, [isPaused]);

            // Cleanup all timeouts and intervals on unmount
            useEffect(() => {
                return () => {
                    // Clear all timeouts
                    timeoutRefs.current.forEach(id => clearTimeout(id));
                    timeoutRefs.current = [];
                    
                    // Clear all intervals
                    intervalRefs.current.forEach(id => clearInterval(id));
                    intervalRefs.current = [];
                };
            }, []);

            if (!gameStarted) {
                return <GameSetup onStart={startGame} />;
            }

            const humanPlayer = players[0];
            const isHumanTurn = currentPlayerIndex === 0;
            const cardsInMelds = new Set();
            playerMelds.forEach(meld => meld.forEach(card => cardsInMelds.add(card.index)));
            const cardsInCurrentMeld = new Set(currentMeld.map(c => c.index));
            
            // Also track cards that have been played on winner's melds (during final turn)
            const cardsPlayedOnWinner = new Set();
            if (players[0] && players[0].playedOnCards) {
                // playedOnCards contains full card objects - match by rank and suit
                players[0].playedOnCards.forEach(playedCard => {
                    // Find this card's index in the hand
                    const handIndex = players[0].hand.findIndex(handCard => 
                        handCard.rank === playedCard.rank && 
                        handCard.suit === playedCard.suit &&
                        handCard.id === playedCard.id
                    );
                    if (handIndex !== -1) {
                        cardsPlayedOnWinner.add(handIndex);
                    }
                });
            }

            return (
                <div className="game-container">
                    {showCelebration && (
                        <Celebration 
                            playerName={celebrationName} 
                            onClose={() => setShowCelebration(false)} 
                        />
                    )}

                    {showDealerSelection && (
                        <div className="dealing-overlay">
                            <div className="dealing-content" style={{width: '100%', maxWidth: '800px', padding: '0 15px', boxSizing: 'border-box'}}>
                                <div className="dealer-announcement" style={{fontSize: 'clamp(24px, 6vw, 48px)'}}>ðŸŽ´ SELECTING DEALER ðŸŽ´</div>
                                <div className="dealing-info" style={{marginBottom: '20px', fontSize: 'clamp(14px, 4vw, 24px)'}}>Dealing cards to determine the dealer...</div>
                                <div style={{display: 'flex', flexWrap: 'wrap', justifyContent: 'center', gap: 'clamp(12px, 3vw, 24px)', maxWidth: '100%', margin: '0 auto', padding: '0 20px', boxSizing: 'border-box'}}>
                                    {players.map((player, idx) => (
                                        <div key={player.id} style={{
                                            textAlign: 'center',
                                            padding: 'clamp(8px, 2vw, 12px)',
                                            background: idx < dealerSelectionStep ? 'rgba(255,255,255,0.1)' : 'transparent',
                                            borderRadius: '8px',
                                            transition: 'all 0.3s',
                                            flexShrink: 0
                                        }}>
                                            <div style={{fontSize: 'clamp(18px, 5vw, 28px)', marginBottom: '8px'}}>{player.avatar}</div>
                                            <div style={{fontSize: 'clamp(11px, 2vw, 14px)', marginBottom: '12px', fontWeight: 'bold', wordBreak: 'break-word'}}>{player.name}</div>
                                            {player.dealerCard ? (
                                                <div style={{
                                                    display: 'flex',
                                                    justifyContent: 'center',
                                                    animation: 'cardFlip 0.5s ease-in-out'
                                                }}>
                                                    <Card card={{...player.dealerCard, isWildForRound: false}} disabled={true} />
                                                </div>
                                            ) : (
                                                <div style={{
                                                    width: 'clamp(70px, 9vw, 110px)',
                                                    height: 'clamp(105px, 13.5vw, 165px)',
                                                    margin: '0 auto',
                                                    border: '2px dashed rgba(255,255,255,0.3)',
                                                    borderRadius: '6px',
                                                    display: 'flex',
                                                    alignItems: 'center',
                                                    justifyContent: 'center',
                                                    color: 'rgba(255,255,255,0.3)',
                                                    fontSize: '28px',
                                                    flexShrink: 0
                                                }}>
                                                    ?
                                                </div>
                                            )}
                                        </div>
                                    ))}
                                </div>
                            </div>
                        </div>
                    )}

                    {showDealingAnimation && dealingInfo && (
                        <div className="dealing-overlay">
                            <div className="dealing-content">
                                <div className="dealer-announcement">ðŸŽ´ DEALING ðŸŽ´</div>
                                <div className="dealer-avatar">{dealingInfo.dealerAvatar}</div>
                                <div className="dealing-info">{dealingInfo.dealerName} is the dealer</div>
                                <div className="dealing-info">Round {dealingInfo.roundNum}</div>
                                <div className="dealing-info">Dealing {dealingInfo.cardsPerPlayer} cards to each player...</div>
                            </div>
                        </div>
                    )}

                    {showScoreDetails && scoreDetailsPlayer && (
                        <ScoreDetailsModal 
                            player={scoreDetailsPlayer}
                            round={round}
                            onClose={() => { setShowScoreDetails(false); setScoreDetailsPlayer(null); }}
                        />
                    )}

                    {flyingCard && (
                        <div 
                            className="flying-card"
                            style={{
                                left: flyingCard.endX,
                                top: flyingCard.endY,
                                width: flyingCard.width,
                                height: flyingCard.height,
                                transform: `translate(${flyingCard.startX - flyingCard.endX}px, ${flyingCard.startY - flyingCard.endY}px)`,
                                animation: 'cardFlip 0.6s ease-in-out'
                            }}
                        >
                            <Card card={{ ...flyingCard.card, isWildForRound: isWild(flyingCard.card, round) }} disabled={true} />
                        </div>
                    )}
                    
                    {/* Flying card animation when dropping on winner meld */}
                    {flyingCardToWinner && (
                        <div 
                            className="flying-card"
                            style={{
                                left: flyingCardToWinner.startX,
                                top: flyingCardToWinner.startY,
                                width: flyingCardToWinner.width,
                                height: flyingCardToWinner.height,
                                transition: 'left 0.3s ease-out, top 0.3s ease-out',
                                animation: 'none'
                            }}
                            ref={(el) => {
                                // Trigger the animation after mount
                                if (el) {
                                    requestAnimationFrame(() => {
                                        el.style.left = flyingCardToWinner.endX + 'px';
                                        el.style.top = flyingCardToWinner.endY + 'px';
                                    });
                                }
                            }}
                        >
                            <Card card={{ ...flyingCardToWinner.card, isWildForRound: isWild(flyingCardToWinner.card, round) }} disabled={true} />
                        </div>
                    )}

                    <div className="header">
                        <div className="header-top-row">
                            <h1><span>ðŸ’°</span><span>Pay Me</span></h1>
                            
                            <div className="game-info">
                                <div className="info-item">
                                    <span className="info-label">Round</span>
                                    <span className="info-value">{round} of 11</span>
                                </div>
                                <div className="info-item">
                                    <span className="info-label">Cards</span>
                                    <span className="info-value">{round + 2}</span>
                                </div>
                                <div className="info-item">
                                    <span className="info-label">Wild Cards</span>
                                    <span className="info-value">{getWildCardName(round)} & Jokers</span>
                                </div>
                                <div className="info-item" style={{background: 'rgba(255, 215, 0, 0.1)', border: '2px solid #ffd700', borderRadius: '8px', padding: '8px 12px'}}>
                                    <span className="info-label">Dealer</span>
                                    <span className="info-value">{players[dealerIndex]?.avatar} {players[dealerIndex]?.name}</span>
                                </div>
                            </div>
                            
                            <div className="header-message">
                                {message && (
                                    <div className={`message-pill ${roundWinner !== null ? 'success' : ''}`}>{message}</div>
                                )}
                                {isPaused && (
                                    <div className="message-pill warning">â¸ï¸ PAUSED</div>
                                )}
                            </div>

                            <div className="header-actions">
                                <button 
                                    className="pause-button"
                                    onClick={() => setSidePanelCollapsed(!sidePanelCollapsed)}
                                    title={sidePanelCollapsed ? "Show Scoreboard" : "Hide Scoreboard"}
                                >
                                    ðŸ“Š
                                </button>
                                <button 
                                    className="pause-button"
                                    onClick={() => setIsPaused(!isPaused)}
                                    title={isPaused ? "Resume" : "Pause"}
                                >
                                    {isPaused ? 'â–¶ï¸' : 'â¸ï¸'}
                                </button>
                            </div>
                        </div>
                    </div>
{isPaused && (
                        <div className="message-box" style={{background: '#ffc107', color: '#000', fontWeight: 'bold'}}>
                            â¸ï¸ GAME PAUSED - Click resume button to continue
                        </div>
                    )}
                    
                    {meldError && !showingAIMelds && <div className="message-box error">{meldError}</div>}

                    <div className="game-content-wrapper">
                        {/* Scoreboard Side Panel (formerly Side Panel with Players) */}
                        <div className={`side-panel ${sidePanelCollapsed ? 'collapsed' : ''}`}>
                            {/* Scoreboard Header */}
                            <div style={{padding: '15px', background: 'linear-gradient(135deg, #1e3c72 0%, #2a5298 100%)', borderBottom: '2px solid #dee2e6', color: 'white'}}>
                                <h3 style={{margin: 0, fontSize: '18px', fontWeight: 'bold', textAlign: 'center'}}>
                                    ðŸ“Š Scoreboard
                                </h3>
                            </div>
                            
                            {/* AI Speed Control */}
                            <div style={{padding: '12px', background: '#f8f9fa', borderBottom: '2px solid #dee2e6', marginBottom: '8px'}}>
                                <div style={{display: 'flex', alignItems: 'center', gap: '10px', marginBottom: '4px'}}>
                                    <label style={{fontSize: '12px', fontWeight: '600', color: '#495057', minWidth: '80px'}}>AI Speed:</label>
                                    <input 
                                        type="range" 
                                        min="0.5" 
                                        max="3" 
                                        step="0.5" 
                                        value={aiSpeed} 
                                        onChange={(e) => setAiSpeed(parseFloat(e.target.value))}
                                        style={{flex: 1, width: '100%'}}
                                    />
                                    <span style={{fontSize: '11px', fontWeight: 'bold', color: '#495057', minWidth: '55px'}}>
                                        {aiSpeed === 0.5 ? 'Slow' : aiSpeed === 1 ? 'Normal' : aiSpeed === 1.5 ? 'Fast' : aiSpeed === 2 ? 'Faster' : aiSpeed === 2.5 ? 'Very Fast' : 'Max'}
                                    </span>
                                </div>
                            </div>
                            <div className="players-grid">
                                {players.map((player, idx) => (
                                <div key={player.id} className={`player-card ${idx === currentPlayerIndex ? 'active' : ''} ${idx === roundWinner ? 'winner' : ''}`}>
                                    {/* Coin badge in top right */}
                                    <div style={{
                                        position: 'absolute',
                                        top: '8px',
                                        right: '8px',
                                        background: 'linear-gradient(135deg, #ffd700 0%, #ffed4e 50%, #ffd700 100%)',
                                        border: '2px solid #b8860b',
                                        borderRadius: '50%',
                                        width: '32px',
                                        height: '32px',
                                        display: 'flex',
                                        alignItems: 'center',
                                        justifyContent: 'center',
                                        fontWeight: 'bold',
                                        fontSize: '13px',
                                        color: '#1a1a1a',
                                        boxShadow: '0 2px 4px rgba(0,0,0,0.2)'
                                    }} title="Quarters">
                                        {player.quarters}
                                    </div>
                                    
                                    <div className="player-name">
                                        <span className="player-avatar">{player.avatar}</span>
                                        <span>
                                            {player.name} 
                                            {idx === currentPlayerIndex && ' ðŸ‘ˆ'}
                                            {idx === dealerIndex && ' ðŸŽ´'}
                                        </span>
                                    </div>
                                    <div className="player-stats">
                                        <div onClick={() => { setScoreDetailsPlayer(player); setShowScoreDetails(true); }} style={{cursor: 'pointer'}}>
                                            Score: {player.score} ðŸ“Š
                                        </div>
                                    </div>
                                    {player.dialogue && <div className="player-dialogue">"{player.dialogue}"</div>}
                                    
                                    {/* Show final hand for human player (idx === 0) */}
                                    {!showDealingAnimation && roundWinner !== null && idx === 0 && playersWhoHaveTakenFinalTurn.has(idx) && (player.melds.length > 0 || player.hand.length > 0 || (player.playedOnCards && player.playedOnCards.length > 0)) && (
                                        <div className="player-final-hand">
                                            <div style={{display: 'flex', gap: '10px', flexWrap: 'wrap'}}>
                                                {player.melds.length > 0 && (
                                                    <div style={{flex: '1 1 auto'}}>
                                                        <h5>Melds:</h5>
                                                        {player.melds.map((meld, meldIdx) => (
                                                            <div key={meldIdx} className="mini-cards">
                                                                {meld.map((card, cardIdx) => (
                                                                    <MiniCard key={cardIdx} card={{...card, isWildForRound: isWild(card, round)}} />
                                                                ))}
                                                            </div>
                                                        ))}
                                                    </div>
                                                )}
                                                {player.hand.length > 0 && (
                                                    <div style={{flex: '1 1 auto'}}>
                                                        <h5>Remaining ({calculateScore(player.hand)} pts):</h5>
                                                        <div className="mini-cards">
                                                            {player.hand.map((card, cardIdx) => (
                                                                <MiniCard key={cardIdx} card={{...card, isWildForRound: isWild(card, round)}} />
                                                            ))}
                                                        </div>
                                                    </div>
                                                )}
                                            </div>
                                            {player.playedOnCards && player.playedOnCards.length > 0 && (
                                                <>
                                                    <h5>Played on runs:</h5>
                                                    <div className="mini-cards">
                                                        {player.playedOnCards.map((card, cardIdx) => (
                                                            <MiniCard key={cardIdx} card={{...card, isWildForRound: isWild(card, round)}} />
                                                        ))}
                                                    </div>
                                                </>
                                            )}
                                        </div>
                                    )}
                                    
                                    {/* Show final hand for AI players (idx !== 0) */}
                                    {!showDealingAnimation && roundWinner !== null && idx !== 0 && playersWhoHaveTakenFinalTurn.has(idx) && (player.melds.length > 0 || player.hand.length > 0) && (
                                        <div className="player-final-hand">
                                            <div style={{display: 'flex', gap: '10px', flexWrap: 'wrap'}}>
                                                {player.melds.length > 0 && (
                                                    <div style={{flex: '1 1 auto'}}>
                                                        <h5>Melds:</h5>
                                                        {player.melds.map((meld, meldIdx) => (
                                                            <div key={meldIdx} className="mini-cards">
                                                                {meld.map((card, cardIdx) => (
                                                                    <MiniCard key={cardIdx} card={{...card, isWildForRound: isWild(card, round)}} />
                                                                ))}
                                                            </div>
                                                        ))}
                                                    </div>
                                                )}
                                                {player.hand.length > 0 && (
                                                    <div style={{flex: '1 1 auto'}}>
                                                        <h5>Remaining ({calculateScore(player.hand)} pts):</h5>
                                                        <div className="mini-cards">
                                                            {player.hand.map((card, cardIdx) => (
                                                                <MiniCard key={cardIdx} card={{...card, isWildForRound: isWild(card, round)}} />
                                                            ))}
                                                        </div>
                                                    </div>
                                                )}
                                            </div>
                                            {player.playedOnCards && player.playedOnCards.length > 0 && (
                                                <>
                                                    <h5 style={{fontSize: '11px', color: '#666'}}>Played off (0 pts):</h5>
                                                    <div className="mini-cards" style={{opacity: 0.7}}>
                                                        {player.playedOnCards.map((card, cardIdx) => (
                                                            <MiniCard key={cardIdx} card={{...card, isWildForRound: isWild(card, round)}} />
                                                        ))}
                                                    </div>
                                                </>
                                            )}
                                        </div>
                                    )}
                                </div>
                            ))}
                        </div>
                        </div>
                        
                        {/* Main game area */}
                        <div className="main-game-area">
                        
                            {/* Table Players - Positioned around the game area */}
                            <div className="table-players-container">
                                {players.map((player, idx) => (
                                    <div 
                                        key={player.id} 
                                        className={`table-player-position position-${idx} ${idx === currentPlayerIndex ? 'active' : ''} ${idx === roundWinner ? 'winner' : ''}`}
                                    >
                                        <div className="table-player-quarters" title="Quarters" aria-label={`${player.quarters} quarters`}>
                                            {player.quarters}
                                        </div>
                                        
                                        <div className="table-player-name">
                                            <span className="table-player-avatar">{player.avatar}</span>
                                            <span>
                                                {player.name}
                                                {idx === currentPlayerIndex && ' ðŸ‘ˆ'}
                                                {idx === dealerIndex && ' ðŸŽ´'}
                                            </span>
                                        </div>
                                        <div className="table-player-stats">
                                            <div 
                                                onClick={() => { setScoreDetailsPlayer(player); setShowScoreDetails(true); }} 
                                                style={{cursor: 'pointer'}}
                                            >
                                                Score: {player.score} ðŸ“Š
                                            </div>
                                            {player.hand && player.hand.length > 0 && (
                                                <div>Cards: {player.hand.length}</div>
                                            )}
                                        </div>
                                    </div>
                                ))}
                            </div>
                        
                            {/* Winner's Hand - Fixed at top, outside scrollable area */}
                            {roundWinner !== null && players[roundWinner].melds.length > 0 && !allFinalPlaysComplete && (
                                <div className="winner-hand-fixed">
                                    <div className="winner-hand-header-row"><h3 style={{marginBottom: '8px', fontSize: '16px'}}>{players[roundWinner].name}'s Winning Hand:</h3>{gamePhase === 'finallaydown' && !meldBuildingComplete && isHumanTurn && (
                                        <div className="winner-tip-pill">
                                            ðŸ’¡ Tip: Drag your cards from below and drop them on the green-bordered melds above to play them off!
                                        </div>
                                    )}</div>
                                    <div style={{display: 'flex', flexWrap: 'wrap', gap: '10px', alignItems: 'flex-start'}}>
                                    {players[roundWinner].melds.map((meld, idx) => {
                                        const isRun = isValidRun(meld, round);
                                        
                                        // Use sortMeld function which properly handles Ace-high runs
                                        const displayMeld = isRun ? sortMeld(meld, round) : [...meld];
                                        
                                        return (
                                            <div 
                                                key={idx} 
                                                className="meld-group"
                                                onDragOver={(e) => {
                                                    const isSet = isValidSet(meld, round);
                                                    // Allow dropping while building melds (before finalize) - NOT after
                                                    if (gamePhase === 'finallaydown' && !meldBuildingComplete && (isRun || isSet)) {
                                                        e.preventDefault();
                                                        e.dataTransfer.dropEffect = 'copy';
                                                        hoveredWinnerMeldRef.current = idx;
                                                        setHoveredWinnerMeldIndex(idx);
                                                    }
                                                }}
                                                onDragLeave={(e) => {}}
                                                onDrop={(e) => {
                                                    e.preventDefault();
                                                    e.stopPropagation();
                                                }}
                                                style={{
                                                    border: gamePhase === 'finallaydown' && !meldBuildingComplete && (isRun || isValidSet(meld, round)) ? '2px dashed #28a745' : '1px solid #dee2e6',
                                                    padding: '8px',
                                                    borderRadius: '6px',
                                                    background: '#f8f9fa',
                                                    display: 'inline-flex',
                                                    flexDirection: 'column',
                                                    gap: '4px'
                                                }}
                                            >
                                                <div style={{fontSize: '11px', fontWeight: '600', color: '#666', whiteSpace: 'nowrap'}}>
                                                    Meld {idx + 1}
                                                    {gamePhase === 'finallaydown' && !meldBuildingComplete && (isRun || isValidSet(meld, round)) && (
                                                        <span style={{color: '#28a745', marginLeft: '6px', fontSize: '10px'}}>
                                                            â† drop to add
                                                        </span>
                                                    )}
                                                </div>
                                                <div 
                                                    style={{display: 'flex', gap: '3px'}}
                                                    onDragEnter={(e) => {
                                                        const isSet = isValidSet(meld, round);
                                                        if (gamePhase === 'finallaydown' && !meldBuildingComplete && (isRun || isSet)) {
                                                            e.preventDefault();
                                                            hoveredWinnerMeldRef.current = idx;
                                                            setHoveredWinnerMeldIndex(idx);
                                                        }
                                                    }}
                                                    onDragOver={(e) => {
                                                        const isSet = isValidSet(meld, round);
                                                        if (gamePhase === 'finallaydown' && !meldBuildingComplete && (isRun || isSet)) {
                                                            e.preventDefault();
                                                            e.dataTransfer.dropEffect = 'copy';
                                                            hoveredWinnerMeldRef.current = idx;
                                                            setHoveredWinnerMeldIndex(idx);
                                                        }
                                                    }}
                                                    onDrop={(e) => {
                                                        e.preventDefault();
                                                        e.stopPropagation();
                                                        // Set hovered meld so handleDragEnd can handle the animation
                                                        hoveredWinnerMeldRef.current = idx;
                                                        setHoveredWinnerMeldIndex(idx);
                                                    }}
                                                >
                                                    {displayMeld.map((card, cardIdx) => (
                                                        <div
                                                            key={`${card.id}-${cardIdx}`}
                                                            draggable={gamePhase === 'finallaydown' && !meldBuildingComplete && card.addedBy}
                                                            onDragStart={(e) => {
                                                                if (card.addedBy) {
                                                                    e.dataTransfer.effectAllowed = 'move';
                                                                    e.dataTransfer.setData('winnerMeldIndex', idx);
                                                                    e.dataTransfer.setData('winnerMeldCardIndex', cardIdx);
                                                                }
                                                            }}
                                                            style={{cursor: card.addedBy ? 'grab' : 'default'}}
                                                        >
                                                            <MiniCard card={{ ...card, isWildForRound: isWild(card, round) }} isWinnerHand={true} />
                                                        </div>
                                                    ))}
                                                </div>
                                            </div>
                                        );
                                    })}
                                    </div>
                                </div>
                            )}
                        
                        <div className="game-screen">

                        {isRoundTransitioning && (
                            <div style={{padding: '20px', textAlign: 'center', color: 'white', fontWeight: 'bold'}}>
                                Starting next round...
                            </div>
                        )}


                        {!buildingPayMe && gamePhase !== 'finallaydown' && !showingAIMelds && !showDealingAnimation && !allFinalPlaysComplete && (
                            <div className="deck-area">
                                <div className={`deck-pile ${aiDrawHighlight === 'deck' ? 'ai-highlight' : ''}`}>
                                    <div className="pile-label">Deck ({deck.length})</div>
                                    <div className={`card-stack ${!isHumanTurn || (gamePhase !== 'draw' && gamePhase !== 'finaldraw') ? 'disabled' : ''}`}
                                         onClick={() => isHumanTurn && (gamePhase === 'draw' || gamePhase === 'finaldraw') && drawCard(false)}>
                                        ðŸ‚ 
                                    </div>
                                </div>
                                <div className={`discard-pile ${aiDrawHighlight === 'discard' ? 'ai-highlight' : ''}`}>
                                    <div className="pile-label">Discard</div>
                                    {discardPile.length > 0 ? (
                                        <Card 
                                            card={discardPile[discardPile.length - 1]}
                                            onClick={() => isHumanTurn && (gamePhase === 'draw' || gamePhase === 'finaldraw') && discardPile.length > 0 && drawCard(true)}
                                            disabled={!isHumanTurn || (gamePhase !== 'draw' && gamePhase !== 'finaldraw')}
                                        />
                                    ) : (
                                        <div className={`card-stack disabled`}>
                                            Empty
                                        </div>
                                    )}
                                </div>
                            </div>
                        )}

                        {(buildingPayMe || (gamePhase === 'finallaydown' && !meldBuildingComplete && isHumanTurn) || (showingAIMelds && roundWinner !== null && !allFinalPlaysComplete)) && (
                            <div className="meld-building-area">
                                {/* Show AI results after they've played */}
                                {showingAIMelds && aiResultsToShow && roundWinner !== null && !allFinalPlaysComplete ? (
                                    <>
                                        <h3>{aiResultsToShow.player.avatar} {aiResultsToShow.player.name}'s Final Play</h3>
                                        
                                        <div style={{flex: '1', minHeight: '0', overflowX: 'auto', overflowY: 'auto', marginBottom: '15px', WebkitOverflowScrolling: 'touch'}}>
                                            <div style={{display: 'flex', gap: '8px', alignItems: 'flex-start', whiteSpace: 'nowrap'}}>
                                                
                                                {/* Melds section */}
                                                {aiResultsToShow.melds.length > 0 && (
                                                    <>
                                                    <div style={{display: 'inline-flex', flexDirection: 'column', gap: '2px'}}>
                                                        <h5 style={{margin: 0, fontSize: '11px', color: '#28a745', whiteSpace: 'nowrap'}}>Melds:</h5>
                                                        <div style={{display: 'flex', gap: '6px'}}>
                                                            {aiResultsToShow.melds.map((meld, meldIdx) => (
                                                                <div key={meldIdx} style={{
                                                                    display: 'flex', 
                                                                    gap: '3px',
                                                                    padding: '4px',
                                                                    border: '2px solid #28a745',
                                                                    borderRadius: '4px',
                                                                    background: 'rgba(40, 167, 69, 0.05)'
                                                                }}>
                                                                    {meld.map((card, cardIdx) => (
                                                                        <div key={`${meldIdx}-${cardIdx}`} style={{display: 'inline-block', flexShrink: 0}}>
                                                                            <WinnerHandCard 
                                                                                card={{ ...card, isWildForRound: isWild(card, round) }} 
                                                                                showOriginalTag={false} 
                                                                            />
                                                                        </div>
                                                                    ))}
                                                                </div>
                                                            ))}
                                                        </div>
                                                    </div>
                                                    {(aiResultsToShow.playedOnCards?.length > 0 || aiResultsToShow.remaining.length > 0) && (
                                                        <div style={{borderLeft: '2px solid #dee2e6', height: '60px', alignSelf: 'center'}}></div>
                                                    )}
                                                    </>
                                                )}
                                                
                                                {/* Played on Winner section */}
                                                {aiResultsToShow.playedOnCards && aiResultsToShow.playedOnCards.length > 0 && (
                                                    <>
                                                    <div style={{display: 'inline-flex', flexDirection: 'column', gap: '2px'}}>
                                                        <h5 style={{margin: 0, fontSize: '11px', color: '#17a2b8', whiteSpace: 'nowrap'}}>Played on Winner:</h5>
                                                        <div style={{
                                                            display: 'flex', 
                                                            gap: '3px',
                                                            padding: '4px',
                                                            border: '2px solid #17a2b8',
                                                            borderRadius: '4px',
                                                            background: 'rgba(23, 162, 184, 0.05)'
                                                        }}>
                                                            {aiResultsToShow.playedOnCards.map((card, idx) => (
                                                                <div key={idx} style={{display: 'inline-block', flexShrink: 0}}>
                                                                    <WinnerHandCard card={{ ...card, isWildForRound: isWild(card, round), addedBy: card.addedBy }} showOriginalTag={false} />
                                                                </div>
                                                            ))}
                                                        </div>
                                                    </div>
                                                    {(aiResultsToShow.remaining.length > 0 || aiResultsToShow.discard) && (
                                                        <div style={{borderLeft: '2px solid #dee2e6', height: '60px', alignSelf: 'center'}}></div>
                                                    )}
                                                    </>
                                                )}
                                                
                                                {/* Remaining Cards section */}
                                                {aiResultsToShow.remaining.length > 0 && (
                                                    <>
                                                    <div style={{display: 'inline-flex', flexDirection: 'column', gap: '2px'}}>
                                                        <h5 style={{margin: 0, fontSize: '11px', color: '#dc3545', whiteSpace: 'nowrap'}}>
                                                            Remaining ({aiResultsToShow.points} pts):
                                                        </h5>
                                                        <div style={{
                                                            display: 'flex', 
                                                            gap: '4px',
                                                            padding: '4px',
                                                            border: '2px solid #dc3545',
                                                            borderRadius: '4px',
                                                            background: 'rgba(220, 53, 69, 0.05)'
                                                        }}>
                                                            {aiResultsToShow.remaining.map((card, idx) => (
                                                                <div key={idx} style={{display: 'inline-block', flexShrink: 0}}>
                                                                    <WinnerHandCard card={{ ...card, isWildForRound: isWild(card, round) }} showOriginalTag={false} />
                                                                </div>
                                                            ))}
                                                        </div>
                                                    </div>
                                                    {aiResultsToShow.discard && (
                                                        <div style={{borderLeft: '2px solid #dee2e6', height: '60px', alignSelf: 'center'}}></div>
                                                    )}
                                                    </>
                                                )}
                                                
                                                {/* Discarded Card section */}
                                                {aiResultsToShow.discard && (
                                                    <div style={{display: 'inline-flex', flexDirection: 'column', gap: '2px'}}>
                                                        <h5 style={{margin: 0, fontSize: '11px', color: '#6c757d', whiteSpace: 'nowrap'}}>Discarded:</h5>
                                                        <div style={{
                                                            display: 'flex', 
                                                            gap: '3px',
                                                            padding: '4px',
                                                            border: '2px solid #6c757d',
                                                            borderRadius: '4px',
                                                            background: 'rgba(108, 117, 125, 0.05)'
                                                        }}>
                                                            <div style={{display: 'inline-block', flexShrink: 0}}>
                                                                <WinnerHandCard card={{ ...aiResultsToShow.discard, isWildForRound: isWild(aiResultsToShow.discard, round) }} showOriginalTag={false} />
                                                            </div>
                                                        </div>
                                                    </div>
                                                )}
                                            </div>
                                        </div>
                                        
                                        <div style={{marginTop: 'auto', paddingTop: '12px', display: 'flex', gap: '10px', justifyContent: 'flex-end'}}>
                                            {(() => {
                                                const nextIndex = (currentPlayerIndex + 1) % players.length;
                                                const isLastPlayer = nextIndex === roundWinner;
                                                return (
                                                    <>
                                                        {isLastPlayer && (
                                                            <button 
                                                                className="success"
                                                                onClick={() => {
                                                                    openScoreboard();
                                                                }}
                                                                style={{fontSize: '14px', padding: '8px 16px'}}
                                                            >
                                                                Show Scoreboard
                                                            </button>
                                                        )}
                                                        <button 
                                                            className="success"
                                                            onClick={() => {
                                                                if (isLastPlayer) {
                                                                    // Skip scoreboard and go directly to next round
                                                                    const winnerIdx = roundWinner;
                                                                    
                                                                    // Clear all display states
                                                                    setShowingAIMelds(false);
                                                                    setAiResultsToShow(null);
                                                                    setShowingHumanFinalPlay(false);
                                                                    setHumanFinalPlayResults(null);
                                                                    setAllFinalPlaysComplete(false);
                                                                    setPlayersWhoHaveTakenFinalTurn(new Set());
                                                                    setRoundWinner(null);
                                                                    nextFinalTurnActionRef.current = null;
                                                                    
                                                                    // Start next round
                                                                    if (round < 11) {
                                                                        const updatedPlayers = players.map((player, idx) => {
                                                                            const roundScore = idx === winnerIdx ? 0 : calculateScore(player.hand);
                                                                            const newScore = player.score + roundScore;
                                                                            
                                                                            const cleanMelds = player.melds.map(meld => 
                                                                                meld.map(card => ({
                                                                                    rank: card.rank,
                                                                                    suit: card.suit,
                                                                                    isRed: card.isRed,
                                                                                    id: card.id,
                                                                                    representsCard: card.representsCard
                                                                                }))
                                                                            );
                                                                            
                                                                            const cleanRemainingCards = player.hand.map(card => ({
                                                                                rank: card.rank,
                                                                                suit: card.suit,
                                                                                isRed: card.isRed,
                                                                                id: card.id
                                                                            }));
                                                                            
                                                                            const cleanPlayedOnCards = (player.playedOnCards || []).map(card => ({
                                                                                rank: card.rank,
                                                                                suit: card.suit,
                                                                                isRed: card.isRed,
                                                                                id: card.id,
                                                                                playedOn: card.playedOn
                                                                            }));
                                                                            
                                                                            const roundData = {
                                                                                round: round,
                                                                                melds: cleanMelds,
                                                                                remainingCards: cleanRemainingCards,
                                                                                playedOnCards: cleanPlayedOnCards,
                                                                                roundScore: roundScore,
                                                                                runningScore: newScore,
                                                                                wasWinner: idx === winnerIdx
                                                                            };
                                                                            
                                                                            return { 
                                                                                ...player, 
                                                                                score: newScore,
                                                                                hand: [],
                                                                                melds: [],
                                                                                playedOnCards: [],
                                                                                roundHistory: [...(player.roundHistory || []), roundData]
                                                                            };
                                                                        });
                                                                        
                                                                        const nextDealerIdx = (dealerIndex + 1) % updatedPlayers.length;
                                                                        const deckCount = updatedPlayers.length <= 2 ? 1 : updatedPlayers.length <= 5 ? 2 : 3;
                                                                        
                                                                        setPlayers(updatedPlayers);
                                                                        setDealerIndex(nextDealerIdx);
                                                                        setMessage(`Round ${round} complete! Starting round ${round + 1}...`);
                                                                        
                                                                        startRound(round + 1, updatedPlayers, deckCount, nextDealerIdx);
                                                                        setRound(round + 1);
                                                                    }
                                                                } else {
                                                                    // Not last player - just continue to next player
                                                                    setShowingAIMelds(false);
                                                                    setAiResultsToShow(null);
                                                                    if (nextFinalTurnActionRef.current) {
                                                                        nextFinalTurnActionRef.current();
                                                                        nextFinalTurnActionRef.current = null;
                                                                    }
                                                                }
                                                            }}
                                                            style={{fontSize: '14px', padding: '8px 16px'}}
                                                        >
                                                            {isLastPlayer ? 'Next Round' : 'Continue'}
                                                        </button>
                                                    </>
                                                );
                                            })()}
                                        </div>
                                    </>
                                ) : (
                                    <>
                                        <div className="meld-building-title-row" style={{display: 'flex', justifyContent: 'space-between', alignItems: 'center', gap: '15px', flexWrap: 'wrap'}}>
                                            <h3 style={{margin: 0}}>
                                                {buildingPayMe ? 'Build Your Pay Me Melds' : 
                                                 isHumanTurn ? (
                                                    <>
                                                        Build Your Final Melds
                                                        <span 
                                                            style={{
                                                                marginLeft: '8px',
                                                                fontSize: '14px',
                                                                cursor: 'help',
                                                                opacity: 0.7
                                                            }}
                                                            title="Click cards below to build melds. Build any valid melds (3+ cards each). Leftover cards will count against you."
                                                        >
                                                            â„¹ï¸
                                                        </span>
                                                    </>
                                                 ) : 
                                                 `${players[currentPlayerIndex]?.name} is Building Melds...`}
                                            </h3>
                                            
                                            {/* Finalize button next to title for human player */}
                                            {isHumanTurn && gamePhase === 'finallaydown' && !buildingPayMe && !showingHumanFinalPlay && (
                                                <button className="success" onClick={finalizeFinalMelds}>Finalize Melds and Discard</button>
                                            )}
                                            
                                            {/* Pay Me finalize buttons next to title */}
                                            {buildingPayMe && (
                                                <div style={{display: 'flex', gap: '10px'}}>
                                                    <button className="success" onClick={finalizePayMe}>
                                                        Finalize & Discard
                                                    </button>
                                                    <button className="danger" onClick={cancelPayMeDeclaration}>Cancel</button>
                                                </div>
                                            )}
                                        </div>
                                        
                                        {/* Subtitles below title row */}
                                        {buildingPayMe && (
                                            <div className="meld-building-subtitle">
                                                You need exactly {round + 2} cards in valid melds (3+ cards each). The remaining card will be automatically discarded.
                                            </div>
                                        )}
                                        {!isHumanTurn && !buildingPayMe && (
                                            <div className="meld-building-subtitle">
                                                {players[currentPlayerIndex]?.name} is organizing their cards into melds and playing off on {players[roundWinner]?.name}'s winning hand...
                                            </div>
                                        )}
                                        
                                        {/* Show AI's melds during their turn */}
                                        {!isHumanTurn && players[currentPlayerIndex]?.melds && players[currentPlayerIndex].melds.length > 0 && (
                                            <div style={{marginBottom: '15px', padding: '10px', background: '#e7f5ff', borderRadius: '8px', border: '2px solid #4dabf7'}}>
                                                <h4 style={{margin: '0 0 10px 0', fontSize: '14px', color: '#1971c2'}}>
                                                    {players[currentPlayerIndex].name}'s Melds:
                                                </h4>
                                                <div style={{display: 'flex', gap: '10px', overflowX: 'auto', WebkitOverflowScrolling: 'touch', flexWrap: 'nowrap'}}>
                                                    {players[currentPlayerIndex].melds.map((meld, idx) => (
                                                        <div key={idx} style={{
                                                            background: 'white',
                                                            border: '2px solid #4dabf7',
                                                            borderRadius: '6px',
                                                            padding: '8px',
                                                            display: 'flex',
                                                            alignItems: 'center',
                                                            gap: '6px'
                                                        }}>
                                                            <span style={{fontSize: '11px', fontWeight: 'bold', color: '#1971c2'}}>Meld {idx + 1}:</span>
                                                            <div style={{display: 'flex', gap: '2px'}}>
                                                                {meld.map((card, cardIdx) => (
                                                                    <MiniCard key={cardIdx} card={{ ...card, isWildForRound: isWild(card, round) }} />
                                                                ))}
                                                            </div>
                                                        </div>
                                                    ))}
                                                </div>
                                            </div>
                                        )}
                                        
                                        {/* Horizontal layout: Current Meld on left, Saved Melds on right */}
                                        <div className="meld-building-content">
                                            {/* Left: Current Meld (building area) */}
                                            <div className={`current-meld-section ${playerMelds.length > 0 ? 'with-saved-melds' : ''}`}>
                                                <div className="meld-group">
                                                    <div className="meld-header">
                                                        <div className="meld-label">Current Meld: {currentMeld.length} cards</div>
                                                        {currentMeld.length >= 3 && (
                                                            <button className="success" onClick={saveCurrentMeld}>Save This Meld</button>
                                                        )}
                                                    </div>
                                                    <div className="cards-container" style={{minHeight: '120px', border: currentMeld.length === 0 ? '2px dashed #ccc' : 'none', borderRadius: '8px', display: 'flex', alignItems: 'center', justifyContent: 'center'}}>
                                                        {currentMeld.length === 0 ? (
                                                            <div style={{color: '#999', fontSize: '14px', textAlign: 'center'}}>
                                                                Click cards below to add them to this meld
                                                            </div>
                                                        ) : (
                                                            currentMeld.map((card, cardIdx) => (
                                                                <React.Fragment key={card.id || `${card.rank}${card.suit}-${cardIdx}`}>
                                                                    {/* Show insertion indicator before this card */}
                                                                    {dropTargetMeldIndex === cardIdx && draggedMeldCardIndex !== null && (
                                                                        <div className="card-insertion-indicator"></div>
                                                                    )}
                                                                    
                                                                    <Card
                                                                        card={{ ...card, isWildForRound: isWild(card, round) }}
                                                                        draggable={true}
                                                                        isDragging={draggedMeldCardIndex === cardIdx}
                                                                        onDragStart={(e) => handleMeldDragStart(e, cardIdx)}
                                                                        onDragOver={(e) => handleMeldDragOver(e, cardIdx)}
                                                                        onDrop={(e) => handleMeldDrop(e, cardIdx)}
                                                                        onDragEnd={() => handleMeldDragEnd()}
                                                                        onTouchStart={(e) => handleMeldTouchStart(e, cardIdx)}
                                                                        onTouchMove={(e) => handleMeldTouchMove(e, cardIdx)}
                                                                        onTouchEnd={(e) => handleMeldTouchEnd(e, cardIdx)}
                                                                        onClick={() => {
                                                                            if (isWild(card, round)) {
                                                                                assignWildCard(cardIdx);
                                                                            }
                                                                        }}
                                                                        onDoubleClick={() => {
                                                                            // Remove from current meld and return to hand
                                                                            const updatedPlayers = [...players];
                                                                            if (!updatedPlayers[0].hand.some(c => c.id === card.id)) {
                                                                                updatedPlayers[0].hand.push(card);
                                                                            }
                                                                            setPlayers(updatedPlayers);
                                                                            setCurrentMeld(currentMeld.filter((_, i) => i !== cardIdx));
                                                                            setMessage('Card returned to hand');
                                                                        }}
                                                                        disabled={false}
                                                                    />
                                                                    
                                                                    {/* Show insertion indicator after last card */}
                                                                    {cardIdx === currentMeld.length - 1 && dropTargetMeldIndex === currentMeld.length && draggedMeldCardIndex !== null && (
                                                                        <div className="card-insertion-indicator"></div>
                                                                    )}
                                                                </React.Fragment>
                                                            ))
                                                        )}
                                                    </div>
                                                </div>
                                            </div>
                                            
                                            {/* Right: Saved Melds (horizontal layout) */}
                                            {isHumanTurn && playerMelds.length > 0 && (
                                                <div className="your-melds-section">
                                                    {playerMelds.map((meld, idx) => (
                                                        <div key={idx} className="saved-meld-item">
                                                            <div style={{
                                                                background: 'white',
                                                                border: '2px solid #28a745',
                                                                borderRadius: '8px',
                                                                padding: '8px',
                                                                display: 'flex',
                                                                flexDirection: 'column',
                                                                gap: '8px',
                                                                height: '100%'
                                                            }}>
                                                                <div style={{
                                                                    display: 'flex',
                                                                    justifyContent: 'space-between',
                                                                    alignItems: 'center',
                                                                    marginBottom: '4px'
                                                                }}>
                                                                    <span style={{fontSize: '12px', fontWeight: 'bold', color: '#28a745'}}>Meld #{idx + 1}</span>
                                                                    <div style={{display: 'flex', gap: '4px'}}>
                                                                        <button 
                                                                            onClick={() => {
                                                                                // Load this meld into currentMeld for editing
                                                                                setCurrentMeld([...meld]);
                                                                                // Remove from saved melds
                                                                                const updatedMelds = playerMelds.filter((_, i) => i !== idx);
                                                                                setPlayerMelds(updatedMelds);
                                                                                setMessage(`Editing meld #${idx + 1}`);
                                                                            }}
                                                                            style={{
                                                                                background: '#007bff',
                                                                                color: 'white',
                                                                                border: 'none',
                                                                                borderRadius: '4px',
                                                                                padding: '3px 7px',
                                                                                fontSize: '11px',
                                                                                cursor: 'pointer',
                                                                                fontWeight: 'bold'
                                                                            }}
                                                                            title="Edit this meld"
                                                                        >âœŽ</button>
                                                                        <button 
                                                                            onClick={() => removeMeld(idx)}
                                                                            style={{
                                                                                background: '#dc3545',
                                                                                color: 'white',
                                                                                border: 'none',
                                                                                borderRadius: '4px',
                                                                                padding: '3px 7px',
                                                                                fontSize: '11px',
                                                                                cursor: 'pointer',
                                                                                fontWeight: 'bold'
                                                                            }}
                                                                            title="Delete this meld"
                                                                        >Ã—</button>
                                                                    </div>
                                                                </div>
                                                                <div style={{
                                                                    display: 'flex',
                                                                    gap: '4px',
                                                                    flexWrap: 'nowrap',
                                                                    justifyContent: 'flex-start',
                                                                    flex: 1,
                                                                    overflowX: 'auto'
                                                                }}>
                                                                    {meld.map((card, cardIdx) => (
                                                                        <div 
                                                                            key={cardIdx}
                                                                            style={{cursor: 'pointer'}}
                                                                            onClick={() => {
                                                                                // Remove this card from meld and return to hand
                                                                                const updatedPlayers = [...players];
                                                                                if (!updatedPlayers[0].hand.some(c => c.id === card.id)) {
                                                                                    updatedPlayers[0].hand.push(card);
                                                                                }
                                                                                
                                                                                const updatedMelds = [...playerMelds];
                                                                                updatedMelds[idx] = meld.filter((_, i) => i !== cardIdx);
                                                                                
                                                                                if (updatedMelds[idx].length < 3) {
                                                                                    updatedMelds[idx].forEach(c => updatedPlayers[0].hand.push(c));
                                                                                    updatedMelds.splice(idx, 1);
                                                                                }
                                                                                
                                                                                setPlayers(updatedPlayers);
                                                                                setPlayerMelds(updatedMelds);
                                                                                setMessage('Card returned to hand');
                                                                            }}
                                                                        >
                                                                            <Card card={{ ...card, isWildForRound: isWild(card, round) }} disabled={true} />
                                                                        </div>
                                                                    ))}
                                                                </div>
                                                            </div>
                                                        </div>
                                                    ))}
                                                </div>
                                            )}
                                        </div>
                                    </>
                                )}
                            </div>
                        )}

                        {/* Keep "Your Hand" panel visible during Final Round until scoreboard or next round 
                            - Removed !humanFinalPlayResults condition to prevent panel from disappearing too early */}
                        {humanPlayer.hand.length > 0 && !showingHumanFinalPlay && !allFinalPlaysComplete && (
                            <div 
                                className="hand-area sticky-hand"
                                onDragOver={(e) => {
                                    // Always allow dragging for reordering or from winner melds
                                    e.preventDefault();
                                    e.dataTransfer.dropEffect = 'move';
                                }}
                                onDrop={handleDropBackToHand}
                            >
                                <div className="hand-label">
                                    Your Hand:
                                    {(buildingPayMe || (isHumanTurn && gamePhase === 'finallaydown' && !meldBuildingComplete)) && (
                                        <span style={{color: '#666', fontSize: '12px', marginLeft: '10px'}}>
                                            (Drag cards from melds back here to undo)
                                        </span>
                                    )}
                                </div>
                                <div 
                                    className="cards-container"
                                    onDragOver={(e) => {
                                        e.preventDefault();
                                        // Accept drops from winner melds or for reordering
                                        e.dataTransfer.dropEffect = 'move';
                                    }}
                                    onDrop={(e) => {
                                        // Check if dropping from winner meld first
                                        const winnerMeldIndex = e.dataTransfer.getData('winnerMeldIndex');
                                        if (winnerMeldIndex !== '') {
                                            handleDropBackToHand(e);
                                            return;
                                        }
                                        // Fallback drop handler for reordering - use dropTargetIndex if set
                                        if (dropTargetIndex !== null && draggedCardIndex !== null) {
                                            handleDrop(e, dropTargetIndex);
                                        }
                                    }}
                                >
                                    {humanPlayer.hand.map((card, idx) => {
                                        // During meld building (Pay Me or final turn), hide cards that are in any meld (saved or current) OR played on winner
                                        const isBuildingMelds = buildingPayMe || (isHumanTurn && gamePhase === 'finallaydown' && !meldBuildingComplete);
                                        const cardInSavedMeld = isBuildingMelds && cardsInMelds.has(idx);
                                        const cardInCurrentMeld = isBuildingMelds && cardsInCurrentMeld.has(idx);
                                        const cardPlayedOnWinner = cardsPlayedOnWinner.has(idx);
                                        const cardBeingDropped = cardBeingDroppedOnWinner === idx;
                                        if (cardInSavedMeld || cardInCurrentMeld || cardPlayedOnWinner || cardBeingDropped) return null;
                                        
                                        return (
                                            <React.Fragment key={idx}>
                                                {/* Show insertion indicator before this card */}
                                                {dropTargetIndex === idx && draggedCardIndex !== null && (
                                                    <div className="card-insertion-indicator"></div>
                                                )}
                                                
                                                <Card
                                                    card={{ ...card, isWildForRound: isWild(card, round) }}
                                                    selected={false}
                                                    inMeld={false}
                                                    draggable={true} // Always draggable
                                                    isDragging={draggedCardIndex === idx}
                                                    onDragStart={(e) => handleDragStart(e, idx)}
                                                    onDragOver={(e) => handleDragOver(e, idx)}
                                                    onDrop={(e) => handleDrop(e, idx)}
                                                    onDragEnd={() => handleDragEnd()}
                                                    onTouchStart={(e) => handleTouchStart(e, idx)}
                                                    onTouchMove={(e) => handleTouchMove(e, idx)}
                                                    onTouchEnd={(e) => handleTouchEnd(e, idx)}
                                                    onClick={(e) => {
                                                        if (buildingPayMe || (isHumanTurn && gamePhase === 'finallaydown' && !meldBuildingComplete)) {
                                                            // Building your own melds
                                                            toggleCardInMeld(idx);
                                                        } else if (gamePhase === 'paymediscard') {
                                                            const cardElement = e.currentTarget;
                                                            animateCardDiscard(cardElement, card, () => discardForPayMe(idx));
                                                        } else if (isHumanTurn && (gamePhase === 'discard' || gamePhase === 'finaldiscard')) {
                                                            const cardElement = e.currentTarget;
                                                            animateCardDiscard(cardElement, card, () => discardCard(idx));
                                                        }
                                                    }}
                                                    disabled={!isHumanTurn && !buildingPayMe && gamePhase !== 'paymediscard' && gamePhase !== 'finallaydown'}
                                                />
                                                
                                                {/* Show insertion indicator after last card */}
                                                {idx === humanPlayer.hand.length - 1 && dropTargetIndex === humanPlayer.hand.length && draggedCardIndex !== null && (
                                                    <div className="card-insertion-indicator"></div>
                                                )}
                                            </React.Fragment>
                                        );
                                    })}
                                </div>
                            </div>
                        )}

                        
                        {/* Regular melds display when not in finaldiscard */}
                        {humanPlayer.melds.length > 0 && !buildingPayMe && roundWinner !== 0 && !(gamePhase === 'finaldiscard' && meldBuildingComplete) && !(gamePhase === 'finallaydown' && meldBuildingComplete) && !showingHumanFinalPlay && !showingAIMelds && !allFinalPlaysComplete && !humanFinalPlayResults && (
                            <div className="melds-area">
                                <h3>Your Melds:</h3>
                                {humanPlayer.melds.map((meld, idx) => (
                                    <div key={idx} className="meld-group">
                                        <div className="meld-label">Meld {idx + 1}:</div>
                                        <div className="cards-container">
                                            {meld.map((card, cardIdx) => (
                                                <Card key={cardIdx} card={{ ...card, isWildForRound: isWild(card, round) }} disabled={true} />
                                            ))}
                                        </div>
                                    </div>
                                ))}
                            </div>
                        )}

                        <div className="actions">
                            {isHumanTurn && !buildingPayMe && gamePhase === 'discard' && (
                                <button onClick={startPayMeDeclaration}>Declare "Pay Me"!</button>
                            )}
                            {isHumanTurn && gamePhase === 'finaldiscard' && meldBuildingComplete && !showingHumanFinalPlay && (
                                <button 
                                    className="success" 
                                    onClick={() => {
                                        // Restore cards from melds back to hand
                                        const updatedPlayers = [...players];
                                        const meldCards = [];
                                        updatedPlayers[0].melds.forEach(meld => meldCards.push(...meld));
                                        updatedPlayers[0].hand.push(...meldCards);
                                        updatedPlayers[0].melds = [];
                                        setPlayers(updatedPlayers);
                                        
                                        // Go back to meld building
                                        setMeldBuildingComplete(false);
                                        setGamePhase('finallaydown');
                                        setMessage('Build your melds. Click cards to add to Current Meld.');
                                    }}
                                >
                                    Edit My Melds
                                </button>
                            )}
                        </div>

                        {/* Show human player's final play after they've discarded - sticky panel remains visible until scoreboard or next round */}
                        {humanFinalPlayResults && roundWinner !== null && !allFinalPlaysComplete && (
                            <div className="your-final-play-panel">
                                <h3>ðŸ‘¤ Your Final Play</h3>
                                
                                <div className="final-play-content" style={{overflowX: 'auto', WebkitOverflowScrolling: 'touch'}}>
                                    <div style={{display: 'flex', gap: '8px', alignItems: 'flex-start', whiteSpace: 'nowrap'}}>
                                        
                                        {/* Melds section */}
                                        {humanFinalPlayResults.melds.length > 0 && (
                                            <>
                                            <div style={{display: 'inline-flex', flexDirection: 'column', gap: '2px'}}>
                                                <h5 style={{margin: 0, fontSize: '11px', color: '#28a745', whiteSpace: 'nowrap'}}>Melds:</h5>
                                                <div style={{display: 'flex', gap: '6px'}}>
                                                    {humanFinalPlayResults.melds.map((meld, meldIdx) => (
                                                        <div key={meldIdx} style={{
                                                            display: 'flex', 
                                                            gap: '3px',
                                                            padding: '4px',
                                                            border: '2px solid #28a745',
                                                            borderRadius: '4px',
                                                            background: 'rgba(40, 167, 69, 0.05)'
                                                        }}>
                                                            {meld.map((card, cardIdx) => (
                                                                <div key={`${meldIdx}-${cardIdx}`} style={{display: 'inline-block', flexShrink: 0}}>
                                                                    <WinnerHandCard 
                                                                        card={{ ...card, isWildForRound: isWild(card, round) }} 
                                                                        showOriginalTag={false} 
                                                                    />
                                                                </div>
                                                            ))}
                                                        </div>
                                                    ))}
                                                </div>
                                            </div>
                                            {(humanFinalPlayResults.playedOnCards?.length > 0 || humanFinalPlayResults.remaining.length > 0) && (
                                                <div style={{borderLeft: '2px solid #dee2e6', height: '60px', alignSelf: 'center'}}></div>
                                            )}
                                            </>
                                        )}
                                        
                                        {/* Played on Winner section */}
                                        {humanFinalPlayResults.playedOnCards && humanFinalPlayResults.playedOnCards.length > 0 && (
                                            <>
                                            <div style={{display: 'inline-flex', flexDirection: 'column', gap: '2px'}}>
                                                <h5 style={{margin: 0, fontSize: '11px', color: '#17a2b8', whiteSpace: 'nowrap'}}>Played on Winner:</h5>
                                                <div style={{
                                                    display: 'flex', 
                                                    gap: '3px',
                                                    padding: '4px',
                                                    border: '2px solid #17a2b8',
                                                    borderRadius: '4px',
                                                    background: 'rgba(23, 162, 184, 0.05)'
                                                }}>
                                                    {humanFinalPlayResults.playedOnCards.map((card, idx) => (
                                                        <div key={idx} style={{display: 'inline-block', flexShrink: 0}}>
                                                            <WinnerHandCard card={{ ...card, isWildForRound: isWild(card, round), addedBy: card.addedBy }} showOriginalTag={false} />
                                                        </div>
                                                    ))}
                                                </div>
                                            </div>
                                            {(humanFinalPlayResults.remaining.length > 0 || humanFinalPlayResults.discard) && (
                                                <div style={{borderLeft: '2px solid #dee2e6', height: '60px', alignSelf: 'center'}}></div>
                                            )}
                                            </>
                                        )}
                                        
                                        {/* Remaining Cards section */}
                                        {humanFinalPlayResults.remaining.length > 0 && (
                                            <>
                                            <div style={{display: 'inline-flex', flexDirection: 'column', gap: '2px'}}>
                                                <h5 style={{margin: 0, fontSize: '11px', color: '#dc3545', whiteSpace: 'nowrap'}}>
                                                    Remaining ({humanFinalPlayResults.points} pts):
                                                </h5>
                                                <div style={{
                                                    display: 'flex', 
                                                    gap: '4px',
                                                    padding: '4px',
                                                    border: '2px solid #dc3545',
                                                    borderRadius: '4px',
                                                    background: 'rgba(220, 53, 69, 0.05)'
                                                }}>
                                                    {humanFinalPlayResults.remaining.map((card, idx) => (
                                                        <div key={idx} style={{display: 'inline-block', flexShrink: 0}}>
                                                            <WinnerHandCard card={{ ...card, isWildForRound: isWild(card, round) }} showOriginalTag={false} />
                                                        </div>
                                                    ))}
                                                </div>
                                            </div>
                                            {humanFinalPlayResults.discard && (
                                                <div style={{borderLeft: '2px solid #dee2e6', height: '60px', alignSelf: 'center'}}></div>
                                            )}
                                            </>
                                        )}
                                        
                                        {/* Discarded Card section */}
                                        {humanFinalPlayResults.discard && (
                                            <div style={{display: 'inline-flex', flexDirection: 'column', gap: '2px'}}>
                                                <h5 style={{margin: 0, fontSize: '11px', color: '#6c757d', whiteSpace: 'nowrap'}}>Discarded:</h5>
                                                <div style={{
                                                    display: 'flex', 
                                                    gap: '3px',
                                                    padding: '4px',
                                                    border: '2px solid #6c757d',
                                                    borderRadius: '4px',
                                                    background: 'rgba(108, 117, 125, 0.05)'
                                                }}>
                                                    <div style={{display: 'inline-block', flexShrink: 0}}>
                                                        <WinnerHandCard card={{ ...humanFinalPlayResults.discard, isWildForRound: isWild(humanFinalPlayResults.discard, round) }} showOriginalTag={false} />
                                                    </div>
                                                </div>
                                            </div>
                                        )}
                                    </div>
                                </div>
                                    
                                    {/* Show Continue button only when human is the last player - outside scrollable content */}
                                    <div style={{paddingTop: '12px', display: 'flex', gap: '10px', justifyContent: 'flex-end', flexShrink: 0}}>
                                    {humanFinalPlayResults && (() => {
                                        // Check if the player who just finished (in humanFinalPlayResults) was the last player
                                        // We need to find their index and check if next player is the winner
                                        const humanPlayerIndex = players.findIndex(p => p.id === humanFinalPlayResults.player.id);
                                        if (humanPlayerIndex === -1) return null;
                                        
                                        const nextIndex = (humanPlayerIndex + 1) % players.length;
                                        const isLastPlayer = nextIndex === roundWinner;
                                        
                                        // Only render buttons if this is the last player
                                        if (!isLastPlayer) return null;
                                        
                                        return (
                                            <>
                                                {isLastPlayer && (
                                                    <button 
                                                        className="success"
                                                        onClick={() => {
                                                            openScoreboard();
                                                        }}
                                                        style={{fontSize: '14px', padding: '8px 16px'}}
                                                    >
                                                        Show Scoreboard
                                                    </button>
                                                )}
                                                <button 
                                                    className="success"
                                                onClick={() => {
                                                    if (isLastPlayer) {
                                                        // Skip scoreboard and go directly to next round
                                                        const winnerIdx = roundWinner;
                                                        
                                                        // Clear all display states
                                                        setShowingHumanFinalPlay(false);
                                                        setHumanFinalPlayResults(null);
                                                        setShowingAIMelds(false);
                                                        setAiResultsToShow(null);
                                                        setAllFinalPlaysComplete(false);
                                                        setPlayersWhoHaveTakenFinalTurn(new Set());
                                                        setRoundWinner(null);
                                                        nextFinalTurnActionRef.current = null;
                                                        
                                                        // Start next round
                                                        if (round < 11) {
                                                            const updatedPlayers = players.map((player, idx) => {
                                                                const roundScore = idx === winnerIdx ? 0 : calculateScore(player.hand);
                                                                const newScore = player.score + roundScore;
                                                                
                                                                const cleanMelds = player.melds.map(meld => 
                                                                    meld.map(card => ({
                                                                        rank: card.rank,
                                                                        suit: card.suit,
                                                                        isRed: card.isRed,
                                                                        id: card.id,
                                                                        representsCard: card.representsCard
                                                                    }))
                                                                );
                                                                
                                                                const cleanRemainingCards = player.hand.map(card => ({
                                                                    rank: card.rank,
                                                                    suit: card.suit,
                                                                    isRed: card.isRed,
                                                                    id: card.id
                                                                }));
                                                                
                                                                const cleanPlayedOnCards = (player.playedOnCards || []).map(card => ({
                                                                    rank: card.rank,
                                                                    suit: card.suit,
                                                                    isRed: card.isRed,
                                                                    id: card.id,
                                                                    playedOn: card.playedOn
                                                                }));
                                                                
                                                                const roundData = {
                                                                    round: round,
                                                                    melds: cleanMelds,
                                                                    remainingCards: cleanRemainingCards,
                                                                    playedOnCards: cleanPlayedOnCards,
                                                                    roundScore: roundScore,
                                                                    runningScore: newScore,
                                                                    wasWinner: idx === winnerIdx
                                                                };
                                                                
                                                                return { 
                                                                    ...player, 
                                                                    score: newScore,
                                                                    hand: [],
                                                                    melds: [],
                                                                    playedOnCards: [],
                                                                    roundHistory: [...(player.roundHistory || []), roundData]
                                                                };
                                                            });
                                                            
                                                            const nextDealerIdx = (dealerIndex + 1) % updatedPlayers.length;
                                                            const deckCount = updatedPlayers.length <= 2 ? 1 : updatedPlayers.length <= 5 ? 2 : 3;
                                                            
                                                            setPlayers(updatedPlayers);
                                                            setDealerIndex(nextDealerIdx);
                                                            setMessage(`Round ${round} complete! Starting round ${round + 1}...`);
                                                            
                                                            startRound(round + 1, updatedPlayers, deckCount, nextDealerIdx);
                                                            setRound(round + 1);
                                                        }
                                                    } else {
                                                        // Not last player - just continue to next player
                                                        setShowingHumanFinalPlay(false);
                                                        // humanFinalPlayResults stays visible through AI plays
                                                        const nextIndex = (currentPlayerIndex + 1) % players.length;
                                                        setCurrentPlayerIndex(nextIndex);
                                                        setGamePhase('finaldraw');
                                                        setIsDiscarding(false);
                                                        const isNextHuman = !players[nextIndex].isAI;
                                                        if (isNextHuman) {
                                                            setMessage('Your final turn - draw a card');
                                                        } else {
                                                            setMessage(`${players[nextIndex].name}'s final turn...`);
                                                        }
                                                    }
                                                }}
                                                style={{fontSize: '14px', padding: '8px 16px'}}
                                            >
                                                {isLastPlayer ? 'Next Round' : 'Continue'}
                                            </button>
                                            </>
                                        );
                                    })()}
                                    </div>
                                </div>
                            )}

                        {/* Show all players' final hands after all final plays are complete */}
                        {allFinalPlaysComplete && !showingHumanFinalPlay && (
                            <div className="score-details-modal">
                                <div className="score-details-header">
                                    <h2>Round {round} Complete - Scoreboard</h2>
                                    <button onClick={() => {
                                        // Close button is hidden for now - use Next Round button instead
                                    }} style={{visibility: 'hidden'}}>âœ•</button>
                                </div>
                                <div className="score-details-content">
                                {/* Display each player's final hand - winner always first */}
                                {[...players]
                                    .map((player, playerIdx) => ({ player, playerIdx }))
                                    .sort((a, b) => {
                                        // Winner always first
                                        if (a.playerIdx === roundWinner) return -1;
                                        if (b.playerIdx === roundWinner) return 1;
                                        // Then sort by points (low to high)
                                        const aPoints = calculateScore(a.player.hand);
                                        const bPoints = calculateScore(b.player.hand);
                                        return aPoints - bPoints;
                                    })
                                    .map(({ player, playerIdx }) => {
                                    const isWinner = playerIdx === roundWinner;
                                    const points = calculateScore(player.hand);
                                    
                                    return (
                                        <div key={player.id} style={{
                                            marginBottom: '8px',
                                            padding: '8px',
                                            background: isWinner ? '#d4edda' : '#f8f9fa',
                                            border: isWinner ? '3px solid #28a745' : '2px solid #dee2e6',
                                            borderRadius: '6px'
                                        }}>
                                            {/* Name and score on same line as cards */}
                                            <div style={{
                                                display: 'flex',
                                                alignItems: 'flex-start',
                                                gap: '12px',
                                                flexWrap: 'wrap'
                                            }}>
                                                {/* Name and score */}
                                                <div style={{
                                                    display: 'flex',
                                                    flexDirection: 'column',
                                                    minWidth: '120px'
                                                }}>
                                                    <h4 style={{margin: 0, fontSize: '15px', color: isWinner ? '#28a745' : '#333'}}>
                                                        {player.avatar} {player.name} {isWinner && 'ðŸ‘‘'}
                                                    </h4>
                                                    <div style={{fontSize: '13px', fontWeight: 'bold', color: isWinner ? '#28a745' : '#dc3545', marginTop: '4px'}}>
                                                        {isWinner ? '0 pts (Winner!)' : `${points} pts`}
                                                    </div>
                                                    <div style={{fontSize: '12px', color: '#666', marginTop: '4px'}}>
                                                        Total: {player.score + points} pts
                                                    </div>
                                                </div>
                                                
                                                {/* All cards in single horizontal scrollable line */}
                                                <div style={{flex: 1, overflowX: 'auto', WebkitOverflowScrolling: 'touch'}}>
                                                    <div style={{display: 'flex', gap: '8px', alignItems: 'flex-start', whiteSpace: 'nowrap'}}>
                                                        
                                                        {/* Melds section */}
                                                        {player.melds.length > 0 && (
                                                            <>
                                                            <div style={{display: 'inline-flex', flexDirection: 'column', gap: '2px'}}>
                                                                <h5 style={{margin: 0, fontSize: '11px', color: '#28a745', whiteSpace: 'nowrap'}}>Melds:</h5>
                                                                <div style={{display: 'flex', gap: '6px'}}>
                                                                    {player.melds.map((meld, meldIdx) => (
                                                                        <div key={meldIdx} style={{
                                                                            display: 'flex', 
                                                                            gap: '3px',
                                                                            padding: '4px',
                                                                            border: '2px solid #28a745',
                                                                            borderRadius: '4px',
                                                                            background: 'rgba(40, 167, 69, 0.05)'
                                                                        }}>
                                                                            {meld.map((card, cardIdx) => (
                                                                                <div key={`${meldIdx}-${cardIdx}`} style={{display: 'inline-block', flexShrink: 0}}>
                                                                                    <WinnerHandCard 
                                                                                        card={{ ...card, isWildForRound: isWild(card, round) }} 
                                                                                        showOriginalTag={false} 
                                                                                    />
                                                                                </div>
                                                                            ))}
                                                                        </div>
                                                                    ))}
                                                                </div>
                                                            </div>
                                                            {(player.playedOnCards?.length > 0 || player.hand.length > 0) && (
                                                                <div style={{borderLeft: '2px solid #dee2e6', height: '60px', alignSelf: 'center'}}></div>
                                                            )}
                                                            </>
                                                        )}
                                                        
                                                        {/* Played on Winner section */}
                                                        {player.playedOnCards && player.playedOnCards.length > 0 && (
                                                            <>
                                                            <div style={{display: 'inline-flex', flexDirection: 'column', gap: '2px'}}>
                                                                <h5 style={{margin: 0, fontSize: '11px', color: '#17a2b8', whiteSpace: 'nowrap'}}>Played on Winner:</h5>
                                                                <div style={{display: 'flex', gap: '3px'}}>
                                                                    {player.playedOnCards.map((card, idx) => (
                                                                        <div key={idx} style={{display: 'inline-block', flexShrink: 0}}>
                                                                            <WinnerHandCard card={{ ...card, isWildForRound: isWild(card, round) }} showOriginalTag={false} />
                                                                        </div>
                                                                    ))}
                                                                </div>
                                                            </div>
                                                            {player.hand.length > 0 && (
                                                                <div style={{borderLeft: '2px solid #dee2e6', height: '60px', alignSelf: 'center'}}></div>
                                                            )}
                                                            </>
                                                        )}
                                                        
                                                        {/* Remaining Cards section */}
                                                        {player.hand.length > 0 && (
                                                            <div style={{display: 'inline-flex', flexDirection: 'column', gap: '2px'}}>
                                                                <h5 style={{margin: 0, fontSize: '11px', color: '#dc3545', whiteSpace: 'nowrap'}}>
                                                                    Remaining ({points} pts):
                                                                </h5>
                                                                <div style={{display: 'flex', gap: '4px'}}>
                                                                    {player.hand.map((card, idx) => (
                                                                        <div key={idx} style={{display: 'inline-block', flexShrink: 0}}>
                                                                            <WinnerHandCard card={{ ...card, isWildForRound: isWild(card, round) }} showOriginalTag={false} />
                                                                        </div>
                                                                    ))}
                                                                </div>
                                                            </div>
                                                        )}
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    );
                                })}
                                
                                {/* Continue to Next Round Button - at bottom of modal */}
                                <div style={{padding: '20px', borderTop: '2px solid #dee2e6', textAlign: 'center', background: '#f8f9fa'}}>
                                    <button 
                                        className="success"
                                        onClick={() => {
                                            // Save roundWinner before clearing it
                                            const winnerIdx = roundWinner;
                                            
                                            // Use closeScoreboard helper and clear states
                                            closeScoreboard();
                                            setShowingHumanFinalPlay(false);
                                            setHumanFinalPlayResults(null);
                                            setShowingAIMelds(false);
                                            setAiResultsToShow(null);
                                            
                                            // Transition to next round immediately
                                            if (round < 11) {
                                                const updatedPlayers = players.map((player, idx) => {
                                                    const roundScore = idx === winnerIdx ? 0 : calculateScore(player.hand);
                                                    const newScore = player.score + roundScore;
                                                    
                                                    const cleanMelds = player.melds.map(meld => 
                                                        meld.map(card => ({
                                                            rank: card.rank,
                                                            suit: card.suit,
                                                            isRed: card.isRed,
                                                            id: card.id,
                                                            representsCard: card.representsCard
                                                        }))
                                                    );
                                                    
                                                    const cleanRemainingCards = player.hand.map(card => ({
                                                        rank: card.rank,
                                                        suit: card.suit,
                                                        isRed: card.isRed,
                                                        id: card.id
                                                    }));
                                                    
                                                    const cleanPlayedOnCards = (player.playedOnCards || []).map(card => ({
                                                        rank: card.rank,
                                                        suit: card.suit,
                                                        isRed: card.isRed,
                                                        id: card.id,
                                                        playedOn: card.playedOn
                                                    }));
                                                    
                                                    const roundData = {
                                                        round: round,
                                                        melds: cleanMelds,
                                                        remainingCards: cleanRemainingCards,
                                                        playedOnCards: cleanPlayedOnCards,
                                                        roundScore: roundScore,
                                                        runningScore: newScore,
                                                        wasWinner: idx === winnerIdx
                                                    };
                                                    
                                                    return { 
                                                        ...player, 
                                                        score: newScore,
                                                        hand: [],
                                                        melds: [],
                                                        playedOnCards: [],
                                                        roundHistory: [...(player.roundHistory || []), roundData]
                                                    };
                                                });
                                                
                                                const nextDealerIdx = (dealerIndex + 1) % updatedPlayers.length;
                                                const deckCount = updatedPlayers.length <= 2 ? 1 : updatedPlayers.length <= 5 ? 2 : 3;
                                                
                                                setPlayers(updatedPlayers);
                                                setDealerIndex(nextDealerIdx);
                                                setMessage(`Round ${round} complete! Starting round ${round + 1}...`);
                                                
                                                // Start next round immediately
                                                startRound(round + 1, updatedPlayers, deckCount, nextDealerIdx);
                                                setRound(round + 1);
                                            }
                                        }}
                                        style={{fontSize: '16px', padding: '12px 30px'}}
                                    >
                                        Continue to Next Round
                                    </button>
                                </div>
                                </div>
                            </div>
                        )}

                        {gameOver && (
                            <div className="scoreboard">
                                <h3>Final Scores</h3>
                                <table className="score-table">
                                    <thead>
                                        <tr><th>Player</th><th>Score</th><th>Quarters</th></tr>
                                    </thead>
                                    <tbody>
                                        {[...players].sort((a, b) => a.score - b.score).map(player => (
                                            <tr key={player.id}>
                                                <td>{player.avatar} {player.name}</td>
                                                <td>{player.score}</td>
                                                <td>{player.quarters}</td>
                                            </tr>
                                        ))}
                                    </tbody>
                                </table>
                                <button onClick={() => window.location.reload()} style={{marginTop: '20px'}}>New Game</button>
                            </div>
                        )}
                        
                        {/* Wild Card Value Picker */}
                        {wildCardToAssign !== null && (
                            <div className="wild-picker-overlay" onClick={cancelWildAssignment}>
                                <div className="wild-picker-modal" onClick={(e) => e.stopPropagation()}>
                                    <h3>ðŸƒ Select Value for Wild Card</h3>
                                    {currentMeld[wildCardToAssign] && (
                                        <p style={{textAlign: 'center', color: '#666', marginBottom: '15px'}}>
                                            What should {currentMeld[wildCardToAssign].rank}{currentMeld[wildCardToAssign].suit} represent?
                                        </p>
                                    )}
                                    <div className="wild-picker-cards">
                                        {getPossibleWildValues().map((option, idx) => {
                                            const isRed = option.suit === 'â™¥' || option.suit === 'â™¦';
                                            return (
                                                <div 
                                                    key={idx}
                                                    className={`wild-picker-card ${isRed ? 'red' : 'black'}`}
                                                    onClick={() => selectWildValue(option.rank, option.suit)}
                                                >
                                                    <span className="rank">{option.rank}</span>
                                                    <span className="suit">{option.suit}</span>
                                                </div>
                                            );
                                        })}
                                    </div>
                                    {getPossibleWildValues().length === 0 && (
                                        <p style={{textAlign: 'center', color: '#dc3545', marginBottom: '15px'}}>
                                            Add more non-wild cards to the meld first to determine possible values.
                                        </p>
                                    )}
                                    <button className="wild-picker-cancel" onClick={cancelWildAssignment}>
                                        Cancel
                                    </button>
                                </div>
                            </div>
                        )}
                        
                        {/* Winner Meld Wild Card Picker */}
                        {winnerMeldWildPicker !== null && (
                            <div className="wild-picker-overlay" onClick={cancelWinnerMeldWildPicker}>
                                <div className="wild-picker-modal" onClick={(e) => e.stopPropagation()}>
                                    <h3>ðŸƒ Where should this wild card go?</h3>
                                    <p style={{textAlign: 'center', color: '#666', marginBottom: '15px'}}>
                                        Adding {winnerMeldWildPicker.card.rank}{winnerMeldWildPicker.card.suit} to {players[roundWinner]?.name}'s meld
                                    </p>
                                    <div className="wild-picker-cards">
                                        {winnerMeldWildPicker.options.map((option, idx) => {
                                            const isRed = option.suit === 'â™¥' || option.suit === 'â™¦';
                                            return (
                                                <div 
                                                    key={idx}
                                                    className={`wild-picker-card ${isRed ? 'red' : 'black'}`}
                                                    onClick={() => selectWinnerMeldWildValue(option.rank, option.suit)}
                                                >
                                                    <span className="rank">{option.rank}</span>
                                                    <span className="suit">{option.suit}</span>
                                                </div>
                                            );
                                        })}
                                    </div>
                                    <button className="wild-picker-cancel" onClick={cancelWinnerMeldWildPicker}>
                                        Cancel
                                    </button>
                                </div>
                            </div>
                        )}
                        
                        {/* Meld Picker Modal */}
                        {showMeldPicker && (
                            <div className="wild-picker-overlay" onClick={handleMeldPickerCancel}>
                                <div className="wild-picker-modal" onClick={(e) => e.stopPropagation()} style={{maxWidth: '600px'}}>
                                    {meldPickerAllWilds ? (
                                        <>
                                            {/* Multi-step picker for all-wilds melds */}
                                            {meldPickerStep === 1 && (
                                                <>
                                                    <h3>Choose Meld Type</h3>
                                                    <div style={{display: 'flex', gap: '20px', justifyContent: 'center', margin: '20px 0'}}>
                                                        <button 
                                                            onClick={() => handleAllWildsMeldTypeSelection('set')}
                                                            style={{padding: '15px 30px', fontSize: '18px'}}
                                                        >
                                                            Set
                                                        </button>
                                                        <button 
                                                            onClick={() => handleAllWildsMeldTypeSelection('run')}
                                                            style={{padding: '15px 30px', fontSize: '18px'}}
                                                        >
                                                            Run
                                                        </button>
                                                    </div>
                                                </>
                                            )}
                                            
                                            {meldPickerStep === 2 && meldPickerSelectedType === 'set' && (
                                                <>
                                                    <h3>Choose Rank</h3>
                                                    <div className="wild-picker-cards">
                                                        {['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'].map(rank => (
                                                            <div 
                                                                key={rank}
                                                                className="wild-picker-card black"
                                                                onClick={() => handleAllWildsSuitOrRankSelection(rank)}
                                                            >
                                                                <span className="rank">{rank}</span>
                                                            </div>
                                                        ))}
                                                    </div>
                                                </>
                                            )}
                                            
                                            {meldPickerStep === 2 && meldPickerSelectedType === 'run' && (
                                                <>
                                                    <h3>Choose Suit</h3>
                                                    <div className="wild-picker-cards">
                                                        {SUITS.map(suit => {
                                                            const isRed = suit === 'â™¥' || suit === 'â™¦';
                                                            return (
                                                                <div 
                                                                    key={suit}
                                                                    className={`wild-picker-card ${isRed ? 'red' : 'black'}`}
                                                                    onClick={() => handleAllWildsSuitOrRankSelection(suit)}
                                                                >
                                                                    <span className="suit" style={{fontSize: '32px'}}>{suit}</span>
                                                                </div>
                                                            );
                                                        })}
                                                    </div>
                                                </>
                                            )}
                                            
                                            {meldPickerStep === 3 && meldPickerSelectedType === 'run' && (
                                                <>
                                                    <h3>Choose Starting Card</h3>
                                                    <div style={{maxHeight: '400px', overflowY: 'auto'}}>
                                                        {['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K']
                                                            .filter((rank, idx) => idx + currentMeld.length < 13)
                                                            .map(startRank => {
                                                                const rankOrder = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
                                                                const startIdx = rankOrder.indexOf(startRank);
                                                                
                                                                // Skip if rank not found
                                                                if (startIdx === -1) return null;
                                                                
                                                                const isRed = meldPickerSelectedSuit === 'â™¥' || meldPickerSelectedSuit === 'â™¦';
                                                                
                                                                return (
                                                                    <div 
                                                                        key={startRank}
                                                                        onClick={() => handleAllWildsRunSelection(startRank)}
                                                                        style={{
                                                                            display: 'flex',
                                                                            gap: '3px',
                                                                            padding: '10px',
                                                                            margin: '5px 0',
                                                                            background: '#f8f9fa',
                                                                            borderRadius: '6px',
                                                                            cursor: 'pointer',
                                                                            border: '2px solid transparent',
                                                                            transition: 'all 0.2s'
                                                                        }}
                                                                        onMouseEnter={(e) => e.currentTarget.style.borderColor = '#2a5298'}
                                                                        onMouseLeave={(e) => e.currentTarget.style.borderColor = 'transparent'}
                                                                    >
                                                                        {currentMeld.map((_, idx) => {
                                                                            const rankIdx = startIdx + idx;
                                                                            // Validate index is within bounds before accessing
                                                                            if (rankIdx >= 0 && rankIdx < rankOrder.length) {
                                                                                const rank = rankOrder[rankIdx];
                                                                                return (
                                                                                    <div 
                                                                                        key={idx}
                                                                                        className={`wild-picker-card ${isRed ? 'red' : 'black'}`}
                                                                                        style={{pointerEvents: 'none'}}
                                                                                    >
                                                                                        <span className="rank">{rank}</span>
                                                                                        <span className="suit">{meldPickerSelectedSuit}</span>
                                                                                    </div>
                                                                                );
                                                                            }
                                                                            return null;
                                                                        })}
                                                                    </div>
                                                                );
                                                            })}
                                                    </div>
                                                </>
                                            )}
                                        </>
                                    ) : (
                                        <>
                                            {/* Single-step picker for melds with at least one non-wild */}
                                            <h3>Choose Meld Interpretation</h3>
                                            <div style={{maxHeight: '400px', overflowY: 'auto', marginBottom: '15px'}}>
                                                {/* Create card lookup map once for all options for efficient O(1) access */}
                                                {(() => {
                                                    const cardLookupMap = new Map(currentMeld.map(c => [c.id, c]));
                                                    
                                                    return meldPickerOptions.map((option, idx) => {
                                                        // Handle sets differently - display is a string label
                                                        if (option.type === 'set' && typeof option.display === 'string') {
                                                            return (
                                                                <div 
                                                                    key={idx}
                                                                    onClick={() => handleMeldPickerSelection(option)}
                                                                    style={{
                                                                        padding: '15px 20px',
                                                                        margin: '8px 0',
                                                                        background: '#f8f9fa',
                                                                        borderRadius: '6px',
                                                                        cursor: 'pointer',
                                                                        border: '2px solid transparent',
                                                                        transition: 'all 0.2s',
                                                                        textAlign: 'center',
                                                                        fontSize: '18px',
                                                                        fontWeight: '600',
                                                                        color: '#1e3c72'
                                                                    }}
                                                                    onMouseEnter={(e) => e.currentTarget.style.borderColor = '#2a5298'}
                                                                    onMouseLeave={(e) => e.currentTarget.style.borderColor = 'transparent'}
                                                                >
                                                                    {option.display}
                                                                    <div style={{
                                                                        fontSize: '12px',
                                                                        fontWeight: 'normal',
                                                                        color: '#666',
                                                                        marginTop: '5px'
                                                                    }}>
                                                                        (Suits will be auto-assigned)
                                                                    </div>
                                                                </div>
                                                            );
                                                        }
                                                        
                                                        // Handle runs normally - display is an array of card strings
                                                        return (
                                                        <div 
                                                            key={idx}
                                                            onClick={() => handleMeldPickerSelection(option)}
                                                            style={{
                                                                display: 'flex',
                                                                gap: '3px',
                                                                padding: '10px',
                                                                margin: '8px 0',
                                                                background: '#f8f9fa',
                                                                borderRadius: '6px',
                                                                cursor: 'pointer',
                                                                border: '2px solid transparent',
                                                                transition: 'all 0.2s',
                                                                justifyContent: 'center'
                                                            }}
                                                            onMouseEnter={(e) => e.currentTarget.style.borderColor = '#2a5298'}
                                                            onMouseLeave={(e) => e.currentTarget.style.borderColor = 'transparent'}
                                                        >
                                                            {option.display.map((cardStr, cardIdx) => {
                                                                const match = cardStr.match(/^(A|[2-9]|10|J|Q|K)([â™¥â™¦â™£â™ ])$/);
                                                                if (!match) return null;
                                                                const [, rank, suit] = match;
                                                                const isRed = suit === 'â™¥' || suit === 'â™¦';
                                                                
                                                                // Get the actual card using cardIds mapping
                                                                // For runs, option.cardIds[cardIdx] gives us the card ID at this display position
                                                                const cardId = option.cardIds ? option.cardIds[cardIdx] : null;
                                                                // Fallback to index-based lookup for backwards compatibility (e.g., sets or old data)
                                                                const originalCard = cardId ? cardLookupMap.get(cardId) : currentMeld[cardIdx];
                                                                const isWildCard = originalCard && originalCard.rank && originalCard.suit && isWild(originalCard, round);
                                                                
                                                                if (isWildCard) {
                                                                    // Show wild card with original appearance and "=X" indicator
                                                                    const originalIsRed = originalCard.isRed !== undefined ? originalCard.isRed : (originalCard.suit === 'â™¥' || originalCard.suit === 'â™¦');
                                                                    const representedCardStr = `${rank}${suit}`;
                                                                    const representsIsRed = suit === 'â™¥' || suit === 'â™¦';
                                                                    const isJoker = originalCard.rank === 'JOKER';
                                                                    
                                                                    return (
                                                                        <div 
                                                                            key={cardIdx}
                                                                            className={`wild-picker-card ${originalIsRed ? 'red' : 'black'}`}
                                                                            style={{
                                                                                pointerEvents: 'none',
                                                                                background: 'linear-gradient(135deg, #ffd700 0%, #ffed4e 50%, #ffd700 100%)',
                                                                                borderColor: '#b8860b',
                                                                                position: 'relative',
                                                                                display: 'flex',
                                                                                alignItems: 'center',
                                                                                justifyContent: 'center'
                                                                            }}
                                                                        >
                                                                            {isJoker ? (
                                                                                <>
                                                                                    <div style={{
                                                                                        fontSize: '45px',
                                                                                        lineHeight: '1'
                                                                                    }}>ðŸƒ</div>
                                                                                    {/* Show represents indicator */}
                                                                                    <div style={{
                                                                                        position: 'absolute',
                                                                                        bottom: '3px',
                                                                                        left: '50%',
                                                                                        transform: 'translateX(-50%)',
                                                                                        fontSize: '9px',
                                                                                        fontWeight: '600',
                                                                                        background: 'rgba(255,255,255,0.9)',
                                                                                        padding: '1px 4px',
                                                                                        borderRadius: '2px',
                                                                                        border: '1px solid #b8860b',
                                                                                        color: representsIsRed ? '#e74c3c' : '#000',
                                                                                        whiteSpace: 'nowrap'
                                                                                    }}>
                                                                                        = {representedCardStr}
                                                                                    </div>
                                                                                </>
                                                                            ) : (
                                                                                <>
                                                                                    {/* For round wilds (like 2 when 2 is wild), show joker emoji with original card indicator */}
                                                                                    <div style={{
                                                                                        display: 'flex',
                                                                                        flexDirection: 'column',
                                                                                        alignItems: 'center',
                                                                                        justifyContent: 'center',
                                                                                        height: '100%',
                                                                                        position: 'relative'
                                                                                    }}>
                                                                                        <div style={{
                                                                                            fontSize: '32px',
                                                                                            lineHeight: '1',
                                                                                            marginBottom: '2px'
                                                                                        }}>ðŸƒ</div>
                                                                                        <div style={{
                                                                                            fontSize: '10px',
                                                                                            fontWeight: '600',
                                                                                            color: originalIsRed ? '#e74c3c' : '#000',
                                                                                            whiteSpace: 'nowrap'
                                                                                        }}>({originalCard.rank}{originalCard.suit})</div>
                                                                                    </div>
                                                                                    {/* Show represents indicator */}
                                                                                    <div style={{
                                                                                        position: 'absolute',
                                                                                        bottom: '3px',
                                                                                        left: '50%',
                                                                                        transform: 'translateX(-50%)',
                                                                                        fontSize: '9px',
                                                                                        fontWeight: '600',
                                                                                        background: 'rgba(255,255,255,0.9)',
                                                                                        padding: '1px 4px',
                                                                                        borderRadius: '2px',
                                                                                        border: '1px solid #b8860b',
                                                                                        color: representsIsRed ? '#e74c3c' : '#000',
                                                                                        whiteSpace: 'nowrap'
                                                                                    }}>
                                                                                        = {representedCardStr}
                                                                                    </div>
                                                                                </>
                                                                            )}
                                                                        </div>
                                                                    );
                                                                } else {
                                                                    // Show normal card
                                                                    return (
                                                                        <div 
                                                                            key={cardIdx}
                                                                            className={`wild-picker-card ${isRed ? 'red' : 'black'}`}
                                                                            style={{pointerEvents: 'none'}}
                                                                        >
                                                                            <span className="rank">{rank}</span>
                                                                            <span className="suit">{suit}</span>
                                                                        </div>
                                                                    );
                                                                }
                                                            })}
                                                        </div>
                                                    );
                                                });
                                            })()}
                                            </div>
                                        </>
                                    )}
                                    
                                    <button className="wild-picker-cancel" onClick={handleMeldPickerCancel}>
                                        Cancel
                                    </button>
                                </div>
                            </div>
                        )}
                        </div>
                        </div>
                    </div>
                </div>
            );
        }

        ReactDOM.render(<PayMeGame />, document.getElementById('root'));
    </script>
</body>
</html>
